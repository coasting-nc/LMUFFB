"""
LMUFFB Project Context Generator

This script collects all source code files and documentation from the LMUFFB project
into a single consolidated markdown file. This file can be used as context when
querying Large Language Models (LLMs) about the project.

The script:
- Recursively walks through the project directory
- Collects all code files (.cpp, .h, .py, etc.) and documentation (.md, .txt)
- Formats each file in markdown code blocks with appropriate syntax highlighting
- Outputs everything to docs/dev_docs/FULL_PROJECT_CONTEXT.md

This is useful for providing complete project context to AI assistants or for
documentation purposes.

Usage:
    python scripts/create_context.py

Output:
    docs/dev_docs/FULL_PROJECT_CONTEXT.md
"""

import os
import re

OUTPUT_FILE = "FULL_PROJECT_CONTEXT.md"

# Extensions to include
EXTENSIONS = {
    '.cpp', '.h', '.c', '.hpp', 
    '.md', '.txt', 
    '.iss', '.cmake', 'CMakeLists.txt',
    '.py'
}

# Directories to exclude
EXCLUDE_DIRS = {
    'build', 'build_test', 'build_tests', 'build-tests', '.git', 'python_prototype', 'vendor', '__pycache__', '.vscode', '.specstory', '.pytest_cache'
}

# Files to exclude
EXCLUDE_FILES = {
    OUTPUT_FILE, 'LICENSE', 'compile_commands.json', 'TODO.md', 'prompts_for_coding_agents.md', 'create_context.py'
}

def is_text_file(filename):
    """
    Check if a file should be included based on its extension.
    
    Args:
        filename (str): The name of the file to check
        
    Returns:
        bool: True if the file extension is in EXTENSIONS, False otherwise
    """
    return any(filename.endswith(ext) or filename == ext for ext in EXTENSIONS)

def main():
    """
    Main function that generates the consolidated project context file.
    
    Walks through the project directory, collects all relevant files,
    and writes them to a single markdown file with proper formatting.
    """
    root_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
    output_dir = os.path.join(root_dir, 'docs', 'dev_docs')
    os.makedirs(output_dir, exist_ok=True)
    output_path = os.path.join(output_dir, OUTPUT_FILE)

    with open(output_path, 'w', encoding='utf-8') as outfile:
        # AUTO-GENERATED WARNING
        outfile.write("# ⚠️ AUTO-GENERATED FILE - DO NOT EDIT MANUALLY\n\n")
        outfile.write("> **WARNING**: This file is automatically generated by `scripts/create_context.py`.\n")
        outfile.write("> Any manual edits will be overwritten the next time the script runs.\n")
        outfile.write("> To modify the content, edit the source files directly.\n\n")
        outfile.write("---\n\n")
        
        # Project header
        outfile.write("# LMUFFB Project Context\n\n")
        outfile.write("This file contains the full source code and documentation of the project.\n")
        outfile.write("It is generated automatically to provide complete context for LLM queries.\n\n")

        for dirpath, dirnames, filenames in os.walk(root_dir):
            # Modify dirnames in-place to filter directories
            dirnames[:] = [d for d in dirnames if d not in EXCLUDE_DIRS]

            for filename in filenames:
                if filename in EXCLUDE_FILES:
                    continue
                
                if not is_text_file(filename):
                    continue

                filepath = os.path.join(dirpath, filename)
                relpath = os.path.relpath(filepath, root_dir)
                
                # Exclude files under docs/dev_docs/code_reviews or docs/dev_docs/code reviews
                relpath_normalized = relpath.replace('\\', '/')
                if 'docs/dev_docs/code_reviews' in relpath_normalized or 'docs/dev_docs/code reviews' in relpath_normalized:
                    print(f"Skipping (code review): {relpath}")
                    continue

                if 'docs/dev_docs/code reviews' in relpath_normalized or 'docs/dev_docs/code reviews' in relpath_normalized:
                    print(f"Skipping (code review): {relpath}")
                    continue

                if 'docs/dev_docs/done_features' in relpath_normalized:
                    print(f"Skipping (done features): {relpath}")
                    continue

                if 'docs/dev_docs/done implementations reports' in relpath_normalized:
                    print(f"Skipping (implementation reports): {relpath}")
                    continue

                if 'docs/dev_docs/drafts' in relpath_normalized:
                    print(f"Skipping (drafts): {relpath}")
                    continue

                if 'docs/dev_docs/non project guides' in relpath_normalized:
                        print(f"Skipping (non project guides): {relpath}")
                        continue

                if 'docs/dev_docs/prompts' in relpath_normalized:
                        print(f"Skipping (prompts): {relpath}")
                        continue

                if 'docs/dev_docs/pending_todos' in relpath_normalized:
                    print(f"Skipping (pending todos): {relpath}")
                    continue

                if 'docs/bug_reports' in relpath_normalized:
                    print(f"Skipping (bug reports): {relpath}")
                    continue

                if 'tmp' in relpath_normalized:
                    print(f"Skipping (tmp): {relpath}")
                    continue

                if 'tmp/diffs' in relpath_normalized:
                    print(f"Skipping (tmp/diffs): {relpath}")
                    continue

                if relpath_normalized == 'src/stb_image_write.h':
                    print(f"Skipping (excluded explicitly): {relpath}")
                    continue
                
                # Exclude .txt files in root directory except for allowed ones
                if dirpath == root_dir and filename.endswith('.txt'):
                    allowed_root_txt = {'README.txt', 'build_commands.txt'}
                    if filename not in allowed_root_txt:
                        print(f"Skipping (root .txt): {relpath}")
                        continue

                print(f"Adding {relpath}...")

                outfile.write(f"\n# File: {relpath}\n")
                
                # Determine language for fencing
                ext = os.path.splitext(filename)[1].lower()
                lang = ""
                if ext in ['.cpp', '.h', '.c']: lang = "cpp"
                elif ext == '.py': lang = "python"
                elif ext == '.md': lang = "markdown"
                elif ext == '.cmake' or filename == 'CMakeLists.txt': lang = "cmake"
                
                outfile.write(f"```{lang}\n")
                
                try:
                    with open(filepath, 'r', encoding='utf-8', errors='ignore') as infile:
                        content = infile.read()
                        
                        # Reformat youtube urls: https://www.youtube.com/watch?v=ID -> youtube: ID
                        # Using a more precise regex to avoid consuming trailing characters like ` or )
                        content = re.sub(r'https?://(?:www\.)?youtube\.com/watch\?v=([\w-]+)(?:&[\w%=+-]*)?', r'youtube: \1', content)
                        content = re.sub(r'https?://youtu\.be/([\w-]+)(?:\?[\w%=+-]*)?', r'youtube: \1', content)

                        # General URL unlinking: find strings starting with http://, https:// or www.
                        # and replace dots with underscores and remove protocol.
                        def general_unlink(match):
                            url = match.group(0)
                            # Remove protocol
                            url = re.sub(r'^https?://', '', url, flags=re.IGNORECASE)
                            # Replace dots with underscores
                            url = url.replace('.', '_')
                            return f"unlinked: {url}"

                        # Regex for URLs: http(s)://... or www....
                        # We stop at characters that are likely not part of the URL in a markdown context
                        url_regex = r'(?:https?://|www\.)[\w\-\.\/\?\=\&\%\#\+\:]+(?<![\.\,\?\!\:\|\)\]\(`])'
                        content = re.sub(url_regex, general_unlink, content, flags=re.IGNORECASE)
                        
                        outfile.write(content)
                except Exception as e:
                    outfile.write(f"Error reading file: {e}")
                
                outfile.write("\n```\n")

    print(f"\nContext file generated: {output_path}")

if __name__ == "__main__":
    main()
