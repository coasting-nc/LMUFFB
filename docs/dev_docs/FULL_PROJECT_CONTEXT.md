# ⚠️ AUTO-GENERATED FILE - DO NOT EDIT MANUALLY

> **WARNING**: This file is automatically generated by `scripts/create_context.py`.
> Any manual edits will be overwritten the next time the script runs.
> To modify the content, edit the source files directly.

---

# LMUFFB Project Context

This file contains the full source code and documentation of the project.
It is generated automatically to provide complete context for LLM queries.


# File: CMakeLists.txt
```cmake
cmake_minimum_required(VERSION 3.10)
project(LMUFFB_CPP)

set(CMAKE_CXX_STANDARD 17)

# Security & Debug Flags (MSVC)
if(MSVC)
    # Compile flags: Buffer Security Check (/GS) is usually default, but good to ensure.
    add_compile_options(/GS)
    
    # Always generate PDBs, even in Release mode (required for OpenCppCoverage)
    add_compile_options(/Zi)

    # Linker flags: ASLR (/DYNAMICBASE) and DEP (/NXCOMPAT)
    add_link_options(/DYNAMICBASE /NXCOMPAT)
    
    # Force debug info generation in the linker
    add_link_options(/DEBUG)
endif()

# ImGui Core Detection & FetchContent
include(FetchContent)
set(IMGUI_DIR "${CMAKE_SOURCE_DIR}/vendor/imgui")

if(EXISTS "${IMGUI_DIR}/imgui.cpp")
    message(STATUS "ImGui Core found locally.")
    set(IMGUI_LOCAL_FOUND TRUE)
else()
    message(STATUS "ImGui not found locally. Using FetchContent...")
    FetchContent_Declare(
      imgui
      GIT_REPOSITORY unlinked: github_com/ocornut/imgui_git
      GIT_TAG        v1.91.8
    )
    FetchContent_GetProperties(imgui)
    if(NOT imgui_POPULATED)
        FetchContent_Populate(imgui)
    endif()
    set(IMGUI_DIR "${imgui_SOURCE_DIR}")
    set(IMGUI_FETCHED TRUE)
endif()

if(EXISTS "${IMGUI_DIR}/imgui.cpp")
    add_definitions(-DENABLE_IMGUI)

    set(IMGUI_CORE_SOURCES
        ${IMGUI_DIR}/imgui.cpp
        ${IMGUI_DIR}/imgui_demo.cpp
        ${IMGUI_DIR}/imgui_draw.cpp
        ${IMGUI_DIR}/imgui_tables.cpp
        ${IMGUI_DIR}/imgui_widgets.cpp
    )
    include_directories(${IMGUI_DIR})
    include_directories(${IMGUI_DIR}/backends)
endif()

# Platform specific Backends
option(BUILD_HEADLESS "Build without GUI support" OFF)
if(BUILD_HEADLESS)
    add_definitions(-DHEADLESS_GUI)
endif()
set(IMGUI_BACKEND_SOURCES "")

if(NOT BUILD_HEADLESS AND IMGUI_CORE_SOURCES)
    if(WIN32)
        list(APPEND IMGUI_BACKEND_SOURCES
            ${IMGUI_DIR}/backends/imgui_impl_win32.cpp
            ${IMGUI_DIR}/backends/imgui_impl_dx11.cpp
        )
        link_libraries(d3d11 d3dcompiler dxguid)
        add_definitions(-DUNICODE -D_UNICODE -DNOMINMAX -DIMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCTIONS)
    else()
        # Linux / GLFW + OpenGL
        find_package(glfw3 REQUIRED)
        find_package(OpenGL REQUIRED)

        list(APPEND IMGUI_BACKEND_SOURCES
            ${IMGUI_DIR}/backends/imgui_impl_glfw.cpp
            ${IMGUI_DIR}/backends/imgui_impl_opengl3.cpp
        )

        include_directories(${OPENGL_INCLUDE_DIR})
    endif()
endif()

set(IMGUI_SOURCES ${IMGUI_CORE_SOURCES} ${IMGUI_BACKEND_SOURCES})

include_directories(src)
if(NOT WIN32)
    include_directories(src/lmu_sm_interface/linux_mock)
    include_directories(src/lmu_sm_interface)
endif()

# Copy icon file into build directory (Windows only)
if(WIN32)
    configure_file(${CMAKE_SOURCE_DIR}/icon/lmuffb.ico ${CMAKE_BINARY_DIR}/lmuffb.ico COPYONLY)
endif()

# Read Version
file(STRINGS "VERSION" LMUFFB_VERSION)

# Parse version for Resource File (e.g. 0.7.29 -> 0,7,29,0)
string(REPLACE "." ";" VERSION_LIST ${LMUFFB_VERSION})
list(GET VERSION_LIST 0 VERSION_MAJOR)
list(GET VERSION_LIST 1 VERSION_MINOR)
list(GET VERSION_LIST 2 VERSION_PATCH)
set(LMUFFB_VERSION_STR "${LMUFFB_VERSION}")
set(LMUFFB_VERSION_COMMA "${VERSION_MAJOR},${VERSION_MINOR},${VERSION_PATCH},0")

# Auto-generate versioned files in the BUILD directory
# This keeps the source tree clean and ensures a single source of truth.
configure_file(src/Version.h.in ${CMAKE_CURRENT_BINARY_DIR}/src/Version.h @ONLY)
if(WIN32)
    configure_file(src/res.rc.in ${CMAKE_CURRENT_BINARY_DIR}/src/res.rc @ONLY)
endif()

include_directories(${CMAKE_CURRENT_BINARY_DIR}/src)
add_definitions(-DLMUFFB_VERSION="${LMUFFB_VERSION}")

# Core Library (Shared between App and Tests)
set(CORE_SOURCES
    src/GuiLayer_Common.cpp
    src/GuiLayer.h
    src/Config.cpp src/Config.h
    src/DirectInputFFB.cpp src/DirectInputFFB.h
    src/GameConnector.cpp src/GameConnector.h
    src/FFBEngine.h src/FFBEngine.cpp
    src/VehicleUtils.cpp
)

if(WIN32)
    list(APPEND CORE_SOURCES src/GuiLayer_Win32.cpp ${CMAKE_CURRENT_BINARY_DIR}/src/res.rc)
else()
    list(APPEND CORE_SOURCES src/GuiLayer_Linux.cpp)
endif()

add_library(LMUFFB_Core STATIC ${CORE_SOURCES} ${IMGUI_SOURCES})
target_include_directories(LMUFFB_Core PUBLIC src ${IMGUI_DIR} ${IMGUI_DIR}/backends ${CMAKE_CURRENT_BINARY_DIR}/src)

if(WIN32)
    target_link_libraries(LMUFFB_Core PUBLIC dinput8.lib dxguid.lib winmm.lib)
endif()

if(NOT WIN32 AND NOT BUILD_HEADLESS)
    target_link_libraries(LMUFFB_Core PUBLIC glfw OpenGL::GL dl pthread)
endif()

# Main Application
set(APP_SOURCES
    src/main.cpp
)

add_executable(LMUFFB ${APP_SOURCES})
target_link_libraries(LMUFFB PRIVATE LMUFFB_Core)

# Tests
add_subdirectory(tests)

# Copy Distribution Files
add_custom_command(TARGET LMUFFB POST_BUILD
    COMMAND ${CMAKE_COMMAND} -E copy
            "${CMAKE_SOURCE_DIR}/README.txt"
            "$<TARGET_FILE_DIR:LMUFFB>/README.txt")

```

# File: docs\dev_docs\implementation_plans\Slope Detection Accuracy Tools.md
```markdown
# Implementation Plan - Accuracy Tools (Surface Type & Phase Analysis)

## 1. Context
Following the stabilization of the Slope Detection algorithm (Plan: [Slope Fix](./Slope%20Detection%20Fixes%20&%20Telemetry%20Enhancements%20v0.7.35.md)), this phase focuses on **Accuracy** and **Tuning**. To perfectly tune the Slope Detection window (`m_slope_sg_window`), we need to measure the physical phase lag between steering input and tire force generation. Additionally, to prevent false positives in the analysis, we must be able to filter out data generated by non-flat surfaces (curbs, grass, rumble strips).

**Goal:**
1.  **Contextual Logging:** Add `SurfaceType` to the telemetry log to allow filtering of noisy data (curb strikes).
2.  **Phase Analysis:** Define the specification for a Cross-Correlation tool in the Log Analyzer to measure tire relaxation lag and recommend optimal window settings.

**Reference Documents:**
*   Previous Plan: `docs/dev_docs/implementation_plans/Slope Detection Fixes & Telemetry Enhancements v0.7.35.md`
*   Diagnostic Reports: `results_mclaren_pr.zip` (High noise noted)

## 2. Codebase Analysis

### 2.1 Architecture Overview
*   **Telemetry Data (`src/lmu_sm_interface/InternalsPlugin.hpp`):** The `TelemWheelV01` struct contains `unsigned char mSurfaceType` (0=dry, 1=wet, 5=rumblestrip, etc.).
*   **Physics Engine (`src/FFBEngine.h`):** The `calculate_force` method has access to the full `TelemInfoV01` structure.
*   **Logger (`src/AsyncLogger.h`):** Currently logs float values. Needs to be expanded to log integer surface codes.

### 2.2 Impacted Functionalities
*   **Logging Pipeline:** The `LogFrame` struct size will increase slightly.
*   **Log Analysis:** The external analyzer tool will need to parse the new columns.

## 3. FFB Effect Impact Analysis

| Effect | Technical Impact | User Perspective |
| :--- | :--- | :--- |
| **None (Direct)** | No changes to FFB generation logic. | No immediate change in feel. |
| **Slope Detection (Indirect)** | Provides data to tune `m_slope_sg_window`. | Future tuning based on this data will result in tighter, more responsive understeer cues. |

## 4. Proposed Changes

### 4.1 File: `src/AsyncLogger.h`

**A. Update `LogFrame` Struct**
Add fields for surface types. We log both front wheels as they often differ (e.g., one wheel on a curb).
```cpp
struct LogFrame {
    // ... existing fields ...
    float surface_type_fl; // Cast to float for CSV uniformity, or keep int if formatter supports it
    float surface_type_fr;
    // ...
};
```

**B. Update `WriteHeader`**
Add columns: `SurfaceFL,SurfaceFR`.

**C. Update `WriteFrame`**
Output the new fields.

### 4.2 File: `src/FFBEngine.h`

**A. Update `calculate_force`**
Extract surface data from telemetry and populate the log frame.
```cpp
// Inside logging block
frame.surface_type_fl = (float)data->mWheel[0].mSurfaceType;
frame.surface_type_fr = (float)data->mWheel[1].mSurfaceType;
```

### 4.3 Documentation: `docs/dev_docs/log_analyzer_v2.md`

**A. Create Specification for Cross-Correlation**
Since the Log Analyzer code is external, create a detailed technical specification for the "Phase Lag Analysis" feature.
*   **Input:** `dAlpha_dt` (Steering Rate) and `dG_dt` (Lateral G Rate).
*   **Algorithm:**
    1.  Filter data: Exclude frames where `SurfaceType != 0` (Asphalt) or `Speed < 10m/s`.
    2.  Normalize signals (Z-score).
    3.  Compute Cross-Correlation $R(\tau)$ for lags $\tau = 0$ to $100ms$.
    4.  Find $\tau_{peak}$ where $R(\tau)$ is max.
*   **Output:**
    *   "Measured Physical Lag: X ms"
    *   "Recommended Window Size: N samples" (where $N = \tau_{peak} / dt$).

### 4.4 File: `VERSION` & `src/Version.h`
*   Increment version (e.g., `0.7.36` -> `0.7.37`).

## 5. Test Plan (TDD)

**New Test File:** `tests/test_ffb_accuracy_tools.cpp`

### Test 1: `test_surface_type_logging`
*   **Goal:** Verify surface types are correctly captured and logged.
*   **Setup:**
    *   Initialize Engine and Logger.
    *   Create mock telemetry.
    *   Set `mWheel[0].mSurfaceType = 5` (Rumblestrip).
    *   Set `mWheel[1].mSurfaceType = 0` (Dry).
*   **Action:** Run `calculate_force` (triggering log).
*   **Assertion:**
    *   Read the generated CSV line.
    *   Verify column `SurfaceFL` is `5.0`.
    *   Verify column `SurfaceFR` is `0.0`.

### Test 2: `test_surface_type_filtering_logic` (Unit Test for Spec)
*   **Goal:** Verify the logic intended for the analyzer (filtering bad data).
*   **Setup:**
    *   Create a dataset with mixed surface types.
    *   Implement a simple filter function (mimicking the analyzer spec).
*   **Assertion:** Ensure frames with `SurfaceType != 0` are excluded from the "clean" dataset used for correlation.

## 6. Deliverables

*   [ ] **Code:** Updated `src/AsyncLogger.h` (New columns).
*   [ ] **Code:** Updated `src/FFBEngine.h` (Data extraction).
*   [ ] **Docs:** New `docs/dev_docs/log_analyzer_v2.md` (Cross-Correlation Spec).
*   [ ] **Tests:** New `tests/test_ffb_accuracy_tools.cpp`.
*   [ ] **Implementation Notes:** Update plan with any CSV formatting issues encountered.

## Implementation Notes

- **Surface Type Integrity**: Surface type data for both front wheels is now correctly extracted and logged. This is critical for filtering out curb strikes from grip analysis.
- **Log Analyzer v2 Spec**: Created a detailed specification for Cross-Correlation analysis in `docs/dev_docs/log_analyzer_v2.md`. This will allow the external Python tool to measure physical phase lag and recommend optimal window settings.

```json
{
  "status": "success",
  "plan_path": "docs/dev_docs/implementation_plans/Slope Detection Accuracy Tools.md",
  "backlog_items": []
}
```
```

# File: docs\dev_docs\implementation_plans\Slope Detection Advanced Features.md
```markdown
# Implementation Plan - Advanced Slope Detection (Torque & Slew)

## 1. Context
Following the stabilization ([Plan 1](./Slope%20Detection%20Fixes%20&%20Telemetry%20Enhancements%20v0.7.35.md)) and accuracy tooling ([Plan 2](./Slope%20Detection%20Accuracy%20Tools.md)) of the Slope Detection feature, this phase implements advanced signal processing techniques derived from deep research into the rFactor 2 / LMU physics engine.

**Goal:**
1.  **Leading Indicator (Pneumatic Trail):** Implement a secondary slope estimator based on `Steering Torque` vs. `Steering Angle`. This detects the drop in pneumatic trail *before* the car physically slides (Lateral G saturation), providing an "anticipatory" understeer cue.
2.  **Signal Hygiene (Slew Rate Limiter):** Implement a Slew Rate Limiter on the Lateral G input to physically reject non-steering events (curb strikes, suspension jolts) from the slope calculation, preventing false positives without relying on complex surface type logic.

**Reference Documents:**
*   Deep Research Report: [`docs/dev_docs/investigations/slope detection advanced features deep research.md`](../investigations/slope%20detection%20advanced%20features%20deep%20research.md)
*   Previous Plans: [`Slope Detection Fixes & Telemetry Enhancements v0.7.35.md`](./Slope%20Detection%20Fixes%20&%20Telemetry%20Enhancements%20v0.7.35.md), [`Slope Detection Accuracy Tools.md`](./Slope%20Detection%20Accuracy%20Tools.md)

## 2. Codebase Analysis

### 2.1 Architecture Overview
*   **Physics Engine (`src/FFBEngine.h`):** Currently calculates `m_slope_current` using Lateral G. Needs expansion to handle a second parallel estimator for Torque.
*   **Configuration (`src/Config.h`):** Needs new parameters to control the Slew Limiter and the Torque Slope sensitivity.
*   **Telemetry (`src/lmu_sm_interface/InternalsPlugin.hpp`):** We already have access to `mSteeringShaftTorque` and `mUnfilteredSteering`.

### 2.2 Impacted Functionalities
*   **Slope Calculation:** Will now involve two parallel derivative pipelines (G-Slope and Torque-Slope).
*   **Grip Factor Logic:** The final `ctx.grip_factor` will be a fusion of both estimators (likely a "min" function to prioritize whichever detects loss first).

## 3. FFB Effect Impact Analysis

| Effect | Technical Impact | User Perspective |
| :--- | :--- | :--- |
| **Understeer (Anticipatory)** | **New Behavior.** The FFB will lighten up *earlier* in the cornering phase. <br> **Mechanism:** Torque Slope detects the peak of the Self-Aligning Torque (SAT) curve, which occurs at lower slip angles than the Lateral Force peak. | **Faster Reaction Time.** <br> - Users will feel the wheel go light *before* the car starts to push wide. <br> - Provides a "warning" zone rather than just a "failure" zone. |
| **Curb Rejection** | **Filtering.** The Slew Rate Limiter prevents sudden G-force spikes (curbs) from triggering the understeer effect. | **Stability.** <br> - Hitting a curb won't cause the wheel to suddenly go limp (false understeer). <br> - Slope detection remains active and accurate even on bumpy tracks. |

## 4. Proposed Changes

### 4.1 File: `src/Config.h`

**A. Update `Preset` Struct**
Add parameters for the new features.
```cpp
struct Preset {
    // ... existing slope settings ...
    
    // New: Slew Rate Limiter (G-Force per second)
    float slope_g_slew_limit = 50.0f; // 50G/s allows fast turns but kills curb spikes
    
    // New: Torque Slope Settings
    bool slope_use_torque = true;
    float slope_torque_sensitivity = 0.5f;
    
    // ... setters and validation ...
};
```
*   **Synchronization Checklist:**
    *   [ ] Add to `Preset` struct.
    *   [ ] Add to `Preset::Apply()`.
    *   [ ] Add to `Preset::UpdateFromEngine()`.
    *   [ ] Add to `Preset::Validate()`.
    *   [ ] Add to `Config::Save()` / `Config::Load()` in `Config.cpp`.

### 4.2 File: `src/FFBEngine.h`

**A. Add Internal State Members**
```cpp
private:
    // Slew Limiter State
    double m_slope_lat_g_prev = 0.0;

    // Torque Slope Buffers & State
    std::array<double, SLOPE_BUFFER_MAX> m_slope_torque_buffer = {};
    std::array<double, SLOPE_BUFFER_MAX> m_slope_steer_buffer = {};
    double m_slope_torque_smoothed = 0.0;
    double m_slope_steer_smoothed = 0.0;
    
    // Torque Slope Result
    double m_slope_torque_current = 0.0;
```

**B. Implement `apply_slew_limiter`**
Helper function to clamp rate of change.
```cpp
double apply_slew_limiter(double input, double& prev_val, double limit, double dt) {
    double delta = input - prev_val;
    double max_change = limit * dt;
    delta = std::clamp(delta, -max_change, max_change);
    prev_val += delta;
    return prev_val;
}
```

**C. Update `calculate_slope_grip`**
1.  **Apply Slew Limiter:** Run `lateral_g` through `apply_slew_limiter` *before* the Low Pass Filter.
2.  **Calculate Torque Slope:**
    *   Smooth `SteeringTorque` and `SteeringAngle`.
    *   Update buffers.
    *   Calculate derivatives (`dTorque_dt`, `dSteer_dt`).
    *   Calculate Projected Slope: `(dTorque * dSteer) / (dSteer^2 + e)`.
3.  **Fusion Logic:**
    *   Calculate `grip_loss_G` (from G-Slope).
    *   Calculate `grip_loss_Torque` (from Torque-Slope).
    *   `final_grip_loss = max(grip_loss_G, grip_loss_Torque)`. (Conservative approach: if *either* indicates loss, reduce FFB).

### 4.3 File: `src/AsyncLogger.h`

**A. Update Logging**
Add `SlopeTorque` and `SlewLimitedG` to the log frame to visualize the new features.

### 4.4 File: `VERSION` & `src/Version.h`
*   Increment version (e.g., `0.7.37` -> `0.7.38`).

## 5. Test Plan (TDD)

**New Test File:** `tests/test_ffb_advanced_slope.cpp`

### Test 1: `test_slew_rate_limiter`
*   **Goal:** Verify curb spikes are rejected.
*   **Setup:**
    *   Configure `slope_g_slew_limit = 10.0`.
    *   Input: Steady G (1.0) -> Spike (5.0) -> Steady (1.0) over 3 frames.
*   **Assertion:**
    *   The value entering the slope buffer should ramp up slowly (1.0 -> 1.1 -> 1.2), ignoring the 5.0 spike.

### Test 2: `test_torque_slope_anticipation`
*   **Goal:** Verify Torque Slope drops before G Slope.
*   **Data Flow Script:**
    *   Simulate a "Pneumatic Trail" scenario:
    *   `SteeringAngle` increases linearly.
    *   `LateralG` increases linearly (Lagging).
    *   `SteeringTorque` increases then plateaus/drops (Leading).
*   **Assertion:**
    *   `m_slope_torque_current` should become negative/zero *before* `m_slope_current` (G-based).
    *   `grip_factor` should drop as soon as Torque Slope drops.

## 6. Deliverables

*   [ ] **Code:** Updated `src/Config.h` & `src/Config.cpp` (New settings).
*   [ ] **Code:** Updated `src/FFBEngine.h` (Slew Limiter & Torque Slope logic).
*   [ ] **Tests:** New `tests/test_ffb_advanced_slope.cpp`.
*   [ ] **Docs:** Update `docs/dev_docs/implementation_plans/Slope Detection Advanced Features.md`.

## Implementation Notes

- **Initialization Robustness**: The G-Slew limiter state (`m_slope_lat_g_prev`) is now initialized on the first frame to the current telemetry value. This prevents a large positive slope artifact (derivative spike) during the very first frames of a session.
- **Torque Slope Anticipation**: The pneumatic trail detector works as expected, detecting grip loss when torque drops while lateral force is still rising. This provides a leading indicator of understeer.
- **Fusion Logic**: The conservative "Max Loss" fusion correctly prioritizes the estimator (G or Torque) that detects grip loss first.

```json
{
  "status": "success",
  "plan_path": "docs/dev_docs/implementation_plans/Slope Detection Advanced Features.md",
  "backlog_items": []
}
```
```

# File: docs\dev_docs\implementation_plans\Slope Detection Fixes & Telemetry Enhancements v0.7.35.md
```markdown
# Implementation Plan - Slope Detection Fixes & Telemetry Enhancements

## 1. Context
The Slope Detection feature, intended to estimate front tire grip loss by analyzing the relationship between Lateral G and Slip Angle, is currently exhibiting mathematical instability (singularities) and logic failures during steady-state cornering. This results in erratic FFB behavior ("banging" forces) and loss of understeer feel during long corners. Additionally, the current telemetry logging lacks sufficient internal state data to fully diagnose these complex mathematical behaviors.

**Goal:** 
1.  Replace the unstable division-based slope calculation with a robust "Projected Slope" method.
2.  Implement "Hold-and-Decay" logic to maintain understeer feel during steady-state cornering.
3.  Expand the `AsyncLogger` to capture internal math states for validation.

**Reference Documents:**
*   Diagnostic Reports: 
    - `unlinked: github_com/coasting-nc/LMUFFB/issues/25#issuecomment-3899222192`
    - `unlinked: github_com/coasting-nc/LMUFFB/issues/25#issuecomment-3899252429`

*   `docs/dev_docs/investigations/Recommended Additions to Telemetry Logger.md`
*   `docs/dev_docs/investigations/improve_slope_Detection_v0.7.35+.md`
*   `docs/dev_docs/investigations/slope_detection_feasibility.md`

## 2. Codebase Analysis

### 2.1 Architecture Overview
*   **Physics Engine (`src/FFBEngine.h`):** Contains the core `calculate_slope_grip` function responsible for the logic. It uses a circular buffer and Savitzky-Golay filters to compute derivatives.
*   **Telemetry Logging (`src/AsyncLogger.h`):** Handles the high-frequency recording of physics data to CSV. It currently logs inputs and final outputs but misses intermediate calculation steps.
*   **Configuration (`src/Config.h`):** Manages user settings. While no new user settings are strictly required, the interpretation of existing sensitivity/threshold settings will change slightly due to the new math.

### 2.2 Impacted Functionalities
*   **Slope Detection Algorithm:** The fundamental math changing from `y/x` to `(x*y)/(x^2 + e)` to avoid division by zero.
*   **State Management:** New state variables are needed in `FFBEngine` to track "Hold" timers and pre-smoothed inputs.
*   **CSV Output:** The log file format will change (new columns), which may affect external analysis tools.

## 3. FFB Effect Impact Analysis

| Effect | Technical Impact | User Perspective |
| :--- | :--- | :--- |
| **Understeer (Front Grip Loss)** | **Major Change.** The `calculate_slope_grip` function drives the `ctx.grip_factor`. <br> **Old:** Fluctuated wildly (0% <-> 100%) due to noise/singularities; dropped to 0% effect (full grip) during steady turns. <br> **New:** Will use Projected Slope for stability and Hold Timer for continuity. | **Smoother & More Consistent.** <br> - No more random "jerks" or "banging" in the wheel. <br> - The wheel will stay light (understeering) during long, steady corners instead of artificially regaining weight. <br> - "Slope Sensitivity" may feel slightly less aggressive, requiring retuning. |
| **General FFB** | **Minor.** Reduced high-frequency noise injection into the main loop due to input pre-smoothing. | Slightly "cleaner" feeling FFB signal. |

## 4. Proposed Changes

### 4.1 File: `src/FFBEngine.h`

**A. Add Internal State Members**
Add variables to track pre-smoothed inputs and the hold timer.
```cpp
private:
    // ... existing slope members ...
    
    // NEW: Input Smoothing State
    double m_slope_lat_g_smoothed = 0.0;
    double m_slope_slip_smoothed = 0.0;

    // NEW: Steady State Logic
    double m_slope_hold_timer = 0.0;
    static constexpr double SLOPE_HOLD_TIME = 0.25; // 250ms hold
    
    // NEW: Debug members for Logger
    double m_debug_slope_raw = 0.0;
    double m_debug_slope_num = 0.0;
    double m_debug_slope_den = 0.0;
```

**B. Rewrite `calculate_slope_grip`**
Implement the robust logic:
1.  **Pre-Smoothing:** Apply LPF (tau ~0.01s) to `lateral_g` and `slip_angle` *before* buffering.
2.  **Projected Slope:** Calculate `slope = (dG * dAlpha) / (dAlpha^2 + epsilon)`.
3.  **Hold Logic:** 
    *   If `abs(dAlpha) > threshold`: Update slope, reset timer.
    *   Else: Decrement timer. If timer > 0, hold previous slope. If timer <= 0, decay slope to 0.

**C. Update `calculate_force`**
Populate the new debug members into the `LogFrame` struct before calling `AsyncLogger::Log`.

### 4.2 File: `src/AsyncLogger.h`

**A. Update `LogFrame` Struct**
Add fields for internal math state.
```cpp
struct LogFrame {
    // ...
    float slope_raw_unclamped;
    float slope_numerator;
    float slope_denominator;
    float hold_timer;
    float input_slip_smoothed;
    // ...
};
```

**B. Update `WriteHeader`**
Add columns: `SlopeRaw,SlopeNum,SlopeDenom,HoldTimer,InputSlipSmooth`.

**C. Update `WriteFrame`**
Output the new fields to the CSV stream.

### 4.3 File: `VERSION` & `src/Version.h`
*   Increment version (e.g., `0.7.35` -> `0.7.36`).

## 5. Test Plan (TDD)

**New Test File:** `tests/test_ffb_slope_fix.cpp`

### Test 1: `test_slope_singularity_rejection`
*   **Goal:** Verify math stability when `dAlpha` is near zero but `dG` is non-zero (e.g., bump while driving straight).
*   **Setup:** 
    *   Initialize Engine.
    *   Feed telemetry where `SlipAngle` is constant (dAlpha ~ 0).
    *   Inject a spike in `LateralG` (dG >> 0).
*   **Assertion:** 
    *   **Old Behavior:** Slope explodes (Singularity).
    *   **New Behavior:** `m_slope_current` remains near 0. `slope_denominator` should be `epsilon`.

### Test 2: `test_slope_steady_state_hold`
*   **Goal:** Verify the "Hold" logic maintains understeer during steady cornering.
*   **Data Flow Script:**
    1.  **Frames 1-20 (Transient):** Ramp `SlipAngle` and `LateralG` to simulate entering a corner. `dAlpha` > threshold.
        *   *Check:* `m_slope_hold_timer` resets to `SLOPE_HOLD_TIME`. Grip factor drops (Understeer).
    2.  **Frames 21-40 (Steady):** Hold `SlipAngle` and `LateralG` constant. `dAlpha` ~ 0.
        *   *Check:* `m_slope_hold_timer` decreases but > 0.
        *   *Check:* `m_slope_current` does **NOT** decay. Grip factor remains low.
    3.  **Frames 41+ (Decay):** Continue holding constant.
        *   *Check:* Once timer expires, `m_slope_current` decays toward 0.

### Test 3: `test_input_smoothing`
*   **Goal:** Verify 8Hz noise is attenuated.
*   **Setup:** Feed noisy `SlipAngle` signal (sine wave at 50Hz).
*   **Assertion:** `m_slope_slip_smoothed` amplitude < Raw Input amplitude.

## 6. Deliverables

*   [ ] **Code:** Updated `src/FFBEngine.h` (Logic fix).
*   [ ] **Code:** Updated `src/AsyncLogger.h` (Logging enhancement).
*   [ ] **Tests:** New `tests/test_ffb_slope_fix.cpp`.
*   [ ] **Docs:** Update `docs/dev_docs/implementation_plans/Slope Detection Fixes & Telemetry Enhancements v0.7.35.md` with implementation notes.
*   [ ] **Docs:** Create `docs/dev_docs/log_analyzer_spec.md` describing the new CSV columns for the analyzer tool.

## Implementation Notes

- **Mathematical Refinement**: The "Projected Slope" method `(dG * dAlpha) / (dAlpha^2 + e)` proved extremely stable. To further improve robustness, initialization of the smoothing state was added to avoid ramp-up artifacts on the first frame of a session or when re-enabling the feature.
- **Hold-and-Decay UX**: The 250ms hold time correctly maintains the understeer sensation during long, steady-state cornering where steering movement is minimal. Legacy tests were adjusted from 1.5s to 2.0s to allow for this hold period before verifying decay.
- **Telemetry Expansion**: Capturing the raw numerator and denominator in the log has already proved useful for identifying why positive slopes occur during recovery (both G and Alpha dropping).

```json
{
  "status": "success",
  "plan_path": "docs/dev_docs/implementation_plans/Slope Detection Fixes & Telemetry Enhancements v0.7.35.md",
  "backlog_items": []
}
```
```

# File: docs\dev_docs\investigations\improve_slope_Detection_v0.7.35+.md
```markdown
Based on the analysis of the code and the provided diagnostic reports, the Slope Detection feature is failing primarily due to **mathematical instability (singularities)** and **logic gaps during steady-state cornering**.

Here is the breakdown of the issues and the specific code fixes required.

### Analysis of the Failure

1.  **Singularities & Explosions (The "McLaren Report" Issue)**
    *   **Symptom:** The McLaren report shows `Slope Std Dev: 8.10` and `Singularities: 8268 events`.
    *   **Cause:** The current formula `m_slope_current = dG_dt / protected_denom` is numerically unstable. Even with the protection `std::max(0.005, abs_dAlpha)`, when `dAlpha` is small (e.g., 0.005) and `dG` is moderate (e.g., 0.5 due to a bump), the result is `100.0`. The code then clamps this to `20.0`, creating a square-wave "banging" effect between -20 and 20.
    *   **Evidence:** The "Binary Residence: 98.3%" in the report means the value is almost always stuck at the clamp limits.

2.  **The Steady-State Flaw (Low Active Time)**
    *   **Symptom:** `Active Time: 13.8%`.
    *   **Cause:** The code only calculates slope when `dAlpha/dt > threshold`. During a long corner (like at Paul Ricard), the driver holds the steering wheel steady. `dAlpha/dt` drops to near zero.
    *   **Result:** The code enters the `else` block: `m_slope_current` decays to 0.0. Since 0.0 slope implies "Linear/Grip", the FFB feels heavy (full grip) exactly when it should feel light (understeer), because the *rate of change* stopped, even if the car is sliding.

3.  **Noise Amplification**
    *   **Symptom:** `Zero-Crossing Rate: 8.69 Hz`.
    *   **Cause:** Taking the derivative ($d/dt$) of raw telemetry naturally amplifies high-frequency noise. The Savitzky-Golay filter helps, but the inputs (`lateral_g` and `slip_angle`) are not pre-smoothed enough before entering the derivative buffer.

---

### The Solution

We need to replace the direct division with a **Robust Least Squares** approach (Projected Slope) to eliminate singularities, and implement a **Hold-and-Decay** logic to handle steady-state cornering.

#### Step 1: Modify `FFBEngine.h`

You need to update the `FFBEngine` class to add state variables for the "Hold" logic and input smoothing.

**In `src/FFBEngine.h`, inside the `FFBEngine` class `private` section:**

Add these new member variables:
```cpp
    // ... existing slope members ...
    double m_slope_current = 0.0;
    double m_slope_grip_factor = 1.0;
    double m_slope_smoothed_output = 1.0;
    
    // NEW: Input Smoothing State
    double m_slope_lat_g_smoothed = 0.0;
    double m_slope_slip_smoothed = 0.0;

    // NEW: Steady State Logic
    double m_slope_hold_timer = 0.0;
    static constexpr double SLOPE_HOLD_TIME = 0.25; // Hold value for 250ms before decaying
```

#### Step 2: Rewrite `calculate_slope_grip`

Replace the entire `calculate_slope_grip` function in `src/FFBEngine.h` with this robust implementation.

```cpp
    // Helper: Calculate Grip Factor from Slope - v0.7.22 FIX
    // Replaces direct division with Robust Projected Slope and adds Steady-State Hold
    double calculate_slope_grip(double lateral_g, double slip_angle, double dt) {
        
        // 1. Input Pre-Smoothing (Low Pass Filter)
        // Reduces high-frequency telemetry noise before derivative calculation.
        // Tau = 0.01s (100Hz cutoff) is fast enough to catch slides but kills jitter.
        const double input_tau = 0.01; 
        double alpha_in = dt / (input_tau + dt);
        m_slope_lat_g_smoothed += alpha_in * (lateral_g - m_slope_lat_g_smoothed);
        m_slope_slip_smoothed += alpha_in * (std::abs(slip_angle) - m_slope_slip_smoothed);

        // 2. Update Buffers with SMOOTHED data
        m_slope_lat_g_buffer[m_slope_buffer_index] = m_slope_lat_g_smoothed;
        m_slope_slip_buffer[m_slope_buffer_index] = m_slope_slip_smoothed;
        m_slope_buffer_index = (m_slope_buffer_index + 1) % SLOPE_BUFFER_MAX;
        if (m_slope_buffer_count < SLOPE_BUFFER_MAX) m_slope_buffer_count++;

        // 3. Calculate Derivatives (Savitzky-Golay)
        double dG_dt = calculate_sg_derivative(m_slope_lat_g_buffer, m_slope_buffer_count, m_slope_sg_window, dt);
        double dAlpha_dt = calculate_sg_derivative(m_slope_slip_buffer, m_slope_buffer_count, m_slope_sg_window, dt);

        // Store for logging
        m_slope_dG_dt = dG_dt;
        m_slope_dAlpha_dt = dAlpha_dt;

        // 4. Robust Slope Estimation (Projected Slope)
        // Instead of slope = y/x, we use slope = (x*y) / (x*x + epsilon)
        // This mathematically projects the vector onto the axis, eliminating division by zero.
        // It naturally dampens the output when dAlpha (x) is small.
        
        double numerator = dG_dt * dAlpha_dt;
        double denominator = (dAlpha_dt * dAlpha_dt) + 0.0001; // Epsilon prevents /0
        double raw_slope = numerator / denominator;

        // 5. Steady-State Logic (Hold & Decay)
        // If dAlpha is significant, we trust the new calculation.
        // If dAlpha is near zero (steady cornering), we HOLD the last known slope.
        
        if (std::abs(dAlpha_dt) > (double)m_slope_alpha_threshold) {
            // Active transient - update slope immediately
            m_slope_current = std::clamp(raw_slope, -20.0, 20.0);
            m_slope_hold_timer = SLOPE_HOLD_TIME; // Reset hold timer
        } else {
            // Steady state - Hold, then Decay
            if (m_slope_hold_timer > 0.0) {
                m_slope_hold_timer -= dt;
                // Keep m_slope_current as is (Hold)
            } else {
                // Timer expired, slowly decay to 0 (Linear Region assumption)
                // Decay rate is slower here to prevent "heavy wheel" mid-corner
                m_slope_current += (double)m_slope_decay_rate * dt * (0.0 - m_slope_current);
            }
        }

        // 6. Calculate Grip Factor
        double current_grip_factor = 1.0;
        double confidence = calculate_slope_confidence(dAlpha_dt);

        // Map slope to loss (InverseLerp)
        // m_slope_min_threshold (e.g. -0.3): Start of loss
        // m_slope_max_threshold (e.g. -2.0): Max loss
        double loss_percent = inverse_lerp((double)m_slope_min_threshold, (double)m_slope_max_threshold, m_slope_current);
        
        // Apply confidence
        // Note: We allow confidence to be lower during hold, but we don't zero it out completely
        // to ensure we feel the understeer during the steady state.
        if (m_slope_hold_timer > 0.0) confidence = 1.0; // Trust the held value

        current_grip_factor = 1.0 - (loss_percent * 0.8 * confidence);

        // Apply Floor (Safety)
        current_grip_factor = (std::max)(0.2, (std::min)(1.0, current_grip_factor));

        // 7. Output Smoothing
        double alpha = dt / ((double)m_slope_smoothing_tau + dt);
        alpha = (std::max)(0.001, (std::min)(1.0, alpha));
        m_slope_smoothed_output += alpha * (current_grip_factor - m_slope_smoothed_output);

        return m_slope_smoothed_output;
    }
```

### Summary of Changes

1.  **Input Pre-Smoothing:** Added `m_slope_lat_g_smoothed` and `m_slope_slip_smoothed`. This cleans up the 8.69Hz noise before it gets differentiated, making `dG_dt` and `dAlpha_dt` much cleaner.
2.  **Robust Division:** Replaced `dG / dAlpha` with `(dG * dAlpha) / (dAlpha^2 + epsilon)`. This mathematically prevents the "Singularities" (8268 events) reported in the McLaren log. It naturally tends toward zero when `dAlpha` is small, rather than exploding to infinity.
3.  **Hold Timer:** Added `m_slope_hold_timer`. When the driver holds the wheel steady in a corner (`dAlpha` drops below threshold), the code now **remembers** that the car was understeering 100ms ago and maintains the lightness in the wheel, rather than immediately restoring full grip. This fixes the "Low Active Time" issue.
```

# File: docs\dev_docs\investigations\Recommended Additions to Telemetry Logger.md
```markdown
### Recommended Additions to Telemetry Logger (`AsyncLogger.h`)

To properly diagnose the "Singularities" and "Steady-State" issues discussed in the previous step, we need to log the **internal state of the math**, not just the inputs and outputs.

Here are the specific changes to make to `AsyncLogger.h` and `FFBEngine.h`.

#### A. Update `LogFrame` Struct
We need to capture the "Hold" state (to verify the fix for low active time) and the raw math components (to verify the fix for singularities).

**File:** `src/AsyncLogger.h`

```cpp
struct LogFrame {
    // ... existing fields ...

    // --- NEW DIAGNOSTIC FIELDS ---
    float slope_raw_unclamped; // The raw result of (num / den) before clamping to +/-20
    float slope_numerator;     // dG * dAlpha
    float slope_denominator;   // dAlpha^2 + epsilon
    float hold_timer;          // Value of m_slope_hold_timer (are we in steady state?)
    float input_slip_smoothed; // The pre-smoothed slip angle feeding the derivative
    
    // ... existing fields ...
};
```

#### B. Update CSV Header
**File:** `src/AsyncLogger.h` (inside `WriteHeader`)

```cpp
    void WriteHeader(const SessionInfo& info) {
        // ... existing headers ...
        
        // Add new columns to the CSV header string
        m_file << "Time,DeltaTime,Speed,LatAccel,LongAccel,YawRate,Steering,Throttle,Brake,"
               << "SlipAngleFL,SlipAngleFR,SlipRatioFL,SlipRatioFR,GripFL,GripFR,LoadFL,LoadFR,"
               << "CalcSlipAngle,CalcGripFront,CalcGripRear,GripDelta,"
               << "dG_dt,dAlpha_dt,SlopeCurrent,SlopeSmoothed,Confidence,"
               // NEW COLUMNS HERE:
               << "SlopeRaw,SlopeNum,SlopeDenom,HoldTimer,InputSlipSmooth," 
               << "FFBTotal,FFBBase,FFBSoP,GripFactor,SpeedGate,Clipping,Marker\n";
    }
```

#### C. Update Write Logic
**File:** `src/AsyncLogger.h` (inside `WriteFrame`)

```cpp
    void WriteFrame(const LogFrame& frame) {
        m_file << std::fixed << std::setprecision(4)
               // ... existing fields ...
               << frame.dG_dt << "," << frame.dAlpha_dt << "," << frame.slope_current << "," << frame.slope_smoothed << "," << frame.confidence << ","
               
               // NEW FIELDS
               << frame.slope_raw_unclamped << "," 
               << frame.slope_numerator << "," 
               << frame.slope_denominator << "," 
               << frame.hold_timer << ","
               << frame.input_slip_smoothed << ","
               
               << frame.ffb_total << "," // ... rest of line
    }
```

#### D. Populate Data in Engine
**File:** `src/FFBEngine.h` (inside `calculate_force`, where `LogFrame` is populated)

You will need to expose these internal variables from `calculate_slope_grip` to the class scope or return them in a struct so `calculate_force` can access them.

```cpp
// Inside FFBEngine::calculate_force logging block:

frame.slope_raw_unclamped = (float)m_debug_slope_raw; // You need to store this in class member during calc
frame.slope_numerator     = (float)m_debug_slope_num;
frame.slope_denominator   = (float)m_debug_slope_den;
frame.hold_timer          = (float)m_slope_hold_timer;
frame.input_slip_smoothed = (float)m_slope_slip_smoothed;
```

---

### 3. Recommended Additions to Log Analyser (Python/Tool)

Since I cannot see the code, I suggest implementing these specific analyses in your tool. These are designed to visualize the specific failures identified in the reports.

#### A. The "Hysteresis Loop" Plot (G vs. Slip)
The most powerful way to visualize slope detection is not a time-series graph, but an X-Y scatter plot.

*   **X-Axis:** `CalcSlipAngle` (or `InputSlipSmooth`)
*   **Y-Axis:** `LatAccel`
*   **Color:** `SlopeCurrent` (Gradient from Red=Negative to Blue=Positive)

**Why:**
*   **Linear Region:** Points should form a straight line going up.
*   **Understeer:** The line should flatten out (plateau).
*   **The Bug:** If you see a "cloud" of points with no structure, your input noise is too high. If you see the color flickering rapidly between Red/Blue in the linear region, your derivative calculation is unstable.

#### B. The "Derivative Phase Plane" (dG vs. dAlpha)
To diagnose the "Singularities" (8268 events):

*   **X-Axis:** `dAlpha_dt`
*   **Y-Axis:** `dG_dt`
*   **Filter:** Only plot points where `HoldTimer > 0` (Active calculation).

**Why:**
*   Ideally, points should cluster along a diagonal line (Slope = 1.0).
*   **Singularities:** Look for points close to the Y-axis (where X is near 0) but high up on Y. These are the math explosions.
*   **Deadzone:** Visualize your `m_slope_alpha_threshold`. Draw vertical lines at +/- threshold. Are valid cornering events being ignored inside this zone?

#### C. State Distribution Pie Chart
Analyze the `HoldTimer` and `dAlpha_dt` to categorize every frame into one of three states:

1.  **Transient (Active):** `abs(dAlpha) > threshold`
2.  **Steady-State (Hold):** `abs(dAlpha) < threshold` AND `HoldTimer > 0`
3.  **Decay/Reset:** `abs(dAlpha) < threshold` AND `HoldTimer <= 0`

**Goal:**
*   In the McLaren report, "Active Time" was 13.8%.
*   With the fix, you want to see **"Steady-State (Hold)"** take up a significant portion (e.g., 30-40%) during cornering. If "Decay" is high during cornering, the Hold Timer is too short.

#### D. Noise Frequency Analysis (FFT)
Perform a Fast Fourier Transform (FFT) on `dAlpha_dt`.

*   **Goal:** Identify the specific frequency of the noise (reported as 8.69 Hz).
*   **Action:** If the peak is at 8-10Hz, it confirms suspension oscillation or FFB vibration feeding back into the wheel. If the peak is >50Hz, it's sensor noise. This tells you exactly how to tune the `input_tau` smoothing factor.
```

# File: docs\dev_docs\investigations\slope detection advanced features deep research.md
```markdown
# **Advanced Real-Time Estimation of Tire Friction and Cornering Dynamics within the isiMotor 2.5 Physics Environment**

The development of high-fidelity Force Feedback (FFB) systems for simulation platforms such as rFactor 2 and Le Mans Ultimate requires a sophisticated synthesis of tire physics, recursive estimation theory, and digital signal processing. At the core of these platforms is the isiMotor 2.5 engine, a complex architecture that utilizes a physically-based Tire Graphical Model (TGM) rather than the empirical "Magic Formula" models common in other simulators. To provide a driver with an accurate sensation of the tire-road interface, an FFB system must estimate the tire-road friction coefficient (![][image1]) and the instantaneous cornering stiffness (![][image2]) in real-time, often operating at frequencies between 400 Hz and 2400 Hz. This report investigates the robust algorithms required for these estimations, the specific transient behaviors of the isiMotor 2.5 engine, and the signal processing techniques necessary to isolate useful physics data from the high-frequency noise inherent in a racing environment.

## **The isiMotor 2.5 Tire Physics Framework**

To implement a robust estimation algorithm, one must first understand the data source. The isiMotor 2.5 TGM is a brush-based model that represents the tire as a series of independent bristles capable of localized interaction with the track surface. These bristles are integrated into a 6-degree-of-freedom (6-DOF) rigid ring structure that simulates the frequency modes and structural deformations of the tire carcass.

### **Structural Parameters and Stiffness Modulation**

The mechanical behavior of the virtual tire is governed by structural parameters defined in the TGM master files, which dictate how the tire generates forces in response to load and slip. These parameters are non-linear and time-varying, necessitating adaptive estimation techniques.

| Parameter Group | Key Variable | Physics Influence | Typical Range/Value |
| :---- | :---- | :---- | :---- |
| **Structural Stiffness** | BeltSpringX | Lateral (sidewall) compliance and phase lag. | ![][image3] |
| **Radial Compliance** | BeltSpringZ | Vertical stiffness and load sensitivity. | ![][image4] |
| **Grip Scaling** | StaticBaseCoefficient | The theoretical maximum ![][image1] in a non-sliding state. | 1.9 \- 3.9 |
| **Adhesion Transition** | StaticDiffusiveAdhesion | Controls the "snappiness" of the friction peak. | 0.75 \- 0.99 |
| **Thermal Dynamics** | StaticCurve | Temperature-dependent grip multipliers. | 250K \- 520K |

The TGM model allows for a high degree of fidelity, particularly in how the contact patch responds to rotational speeds. The recent transition from global centrifugal calculations to "point-based acceleration" in the Quasi-Static Analysis (QSA) model has significantly altered the high-speed stability of tires in rFactor 2\. This update results in a longer contact patch at high loads and speeds, which increases stability but also makes the tire more prone to overheating at the trailing edge of the patch due to increased sliding speed. Any estimation algorithm must therefore account for the fact that cornering stiffness is not a constant value but is influenced by velocity, load, and temperature.

### **Thermodynamic Influence on Cornering Stiffness**

The isiMotor 2.5 engine includes a detailed thermodynamic model that influences the friction coefficient. The StaticCurve defines three Kelvin temperature points and their corresponding grip multipliers. As the tire temperature moves outside its optimal window, the available friction coefficient drops, which directly impacts the slope of the Lateral Force vs. Slip Angle curve.

![][image5]  
For real-time estimation, this means the algorithm must be capable of tracking parameter drifts caused by thermal changes. This is where Recursive Least Squares (RLS) with forgetting factors becomes essential, as it allows the model to "forget" the behavior of a cold tire as the rubber reaches its operating temperature.

## **Mathematical Stability in Parametric Estimation**

The primary goal of friction estimation in FFB is to identify the slope of the lateral force curve before the tire reaches saturation. This slope, or cornering stiffness (![][image2]), is defined as:

![][image6]  
In a real-time environment, the algorithm must identify this parameter while handling the non-stationary nature of the system and the inherent noise in the telemetry data.

### **Recursive Least Squares with Variable Forgetting Factors**

The Recursive Least Squares (RLS) algorithm is preferred in automotive control because it minimizes a weighted linear least-squares cost function relating the input signals (Slip Angle) to the output signals (Lateral Force). The standard RLS update law is:

![][image7]  
where ![][image8] is the parameter vector (containing ![][image2]), ![][image9] is the gain vector, ![][image10] is the measured lateral force, and ![][image11] is the input vector containing slip angles.

The inclusion of a forgetting factor (![][image12]) allows the algorithm to weight recent data more heavily than older data. However, a fixed forgetting factor (FFF) presents a fundamental engineering trade-off: a ![][image12] close to 1.0 ensures stability and noise rejection but is too slow to track the rapid changes in grip encountered when a car hits a curb or grass; conversely, a ![][image12] significantly less than 1.0 (e.g., 0.95) tracks changes quickly but becomes highly sensitive to sensor noise and can lead to "estimator windup".

To resolve this, Variable Forgetting Factor (VFF) schemes adjust ![][image12] based on the prediction error ![][image13]. In the isiMotor 2.5 environment, where high-frequency vibrations from the road surface are constant, a robust VFF logic is required:

![][image14]  
where ![][image15] is a tuning parameter that determines the sensitivity to the error. This ensures that when the car experiences a sudden change in surface (large ![][image13]), the algorithm "forgets" the old surface quickly, but remains stable during steady-state cornering.

### **Addressing Excitation Loss and Singularities**

A critical failure point for RLS in sim racing is "excitation loss." This occurs during steady-state cornering on a constant radius, where the slip angle and lateral force derivatives approach zero. In these conditions, the algorithm lacks "rich" data to identify the parameters, and the covariance matrix ![][image16] in the RLS update law can grow exponentially, leading to numerical singularities and the "blow-up" of the estimated values.

To prevent this, FFB developers must implement techniques to handle poor excitation:

1. **Directional Forgetting:** Rather than a scalar ![][image12], forgetting is only applied to the directions in the parameter space where new information is available. If a driver is holding a constant steering angle, the algorithm should not "forget" the previously learned cornering stiffness, as no new data is contradicting it.  
2. **Conditional Update (Dead-Zone):** The parameter update is only executed when the excitation exceeds a predefined threshold, such as a minimum rate of change in slip angle (![][image17]). This prevents the estimator from trying to derive information from pure noise during static conditions.  
3. **Covariance Trace Resetting:** If the trace of the covariance matrix ![][image16] exceeds a safety limit, it is reset or regularized to prevent the gain ![][image9] from becoming too large.

### **Savitzky-Golay Filters for Slope Analysis**

While RLS is an adaptive model-based approach, the Savitzky-Golay (SG) filter is a non-recursive signal processing technique that can be used for "slope detection" by calculating the first derivative of the Lateral G vs. Slip Angle relationship. The SG filter fits a low-degree polynomial to a sliding window of data points using the method of linear least squares.

![][image18]  
where ![][image19] are pre-calculated convolution coefficients for the first derivative.

The primary advantage of the SG filter over a simple moving average or a first-order differentiator is its ability to smooth the signal while preserving the integrity of the peaks and the underlying signal tendency. In FFB applications, an SG filter is often used as a pre-processor for the raw telemetry stream, smoothing the lateral G and slip angle signals before they enter the RLS estimator. This reduces the "jitter" in the estimated ![][image2] that would otherwise be caused by high-frequency road textures.

| Feature | VFF-RLS | Savitzky-Golay |
| :---- | :---- | :---- |
| **Computational Model** | Recursive / Adaptive | Finite Impulse Response (FIR) |
| **Numerical Stability** | Prone to windup without logic | Inherently stable (no feedback loop) |
| **Transient Tracking** | Extremely fast (optimal for non-stationary) | Limited by window size (introduces lag) |
| **Implementation Complexity** | High (Matrix math, SVD, regularization) | Low (Static coefficients and convolution) |
| **Requirement** | Rich excitation | Evenly spaced data points |

## **Transient Dynamics and Phase Delay in isiMotor 2.5**

The isiMotor 2.5 engine's use of a 6-DOF rigid ring and bristle model introduces physical delays that are not present in simpler simulators. Understanding these delays is paramount for FFB developers who seek to align the tactile sensations with the visual cues.

### **Tire Relaxation Length and Build-up Lag**

"Relaxation length" refers to the distance a tire must roll to develop steady-state lateral force after a change in slip angle. In rFactor 2, this is not a single hard-coded parameter but an emergent behavior of the carcass stiffness (BeltSpringX) and the damping properties (TemporaryBristleDamper).

In low-speed corners, the relaxation length translates into a significant temporal delay, as the tire rolls slowly. This results in a phase lag between steering input and the generation of lateral G. Telemetry analysis of isiMotor 2.5 cars typically reveals a phase delay of approximately 10ms to 40ms, depending on the speed and the stiffness of the tire modeled. If the FFB torque is calculated purely based on the instantaneous lateral acceleration, the driver will feel a "numbness" or a "softness" during initial turn-in, as the force build-up in the simulation lags behind the driver's intention.

### **Hysteresis Compensation in Force Feedback**

To compensate for this build-up lag and the resulting hysteresis, FFB developers use a combination of leading and lagging indicators. While lateral G is a lagging indicator (force is already generated), variables related to the steering geometry, such as aligning torque and pneumatic trail, act as leading indicators.

Pneumatic trail is the distance between the center of the contact patch and the point where the lateral force is concentrated. As the tire reaches its limit, the pneumatic trail begins to decrease before the total lateral force peaks. By blending a signal derived from the change in steering arm force with the lateral G signal, FFB developers can create a "anticipatory" feel that warns the driver of impending grip loss before the car physically begins to understeer.

Furthermore, the "Quasi-Static Analysis" (QSA) process in the TGM model, which generates the look-up tables used in real-time, can be tuned with a DT (Delta Time) multiplier. A lower DT during the table generation phase in tTool leads to a more stable but potentially "slower" tire response, while a higher DT increases the reactivity but risks numerical instability and "spiky" force generation.

## **Signal Processing: Isolating Saturation from Noise**

The telemetry signals from isiMotor 2.5 are famously "raw," containing not just the macro-level vehicle dynamics but also the micro-level vibrations of the suspension, the "buzz" of road textures, and the impulsive shocks of curb strikes. Separating the "useful" tire saturation signal from this noise is a significant signal processing challenge.

### **Total Least Squares and Orthogonal Distance Regression**

A major limitation of standard RLS (Ordinary Least Squares) is the assumption that the input signal (Slip Angle) is perfectly known and only the output (Lateral G) contains noise. In a sim racing environment, both signals are contaminated with noise. Slip angle is derived from the vehicle's yaw rate and lateral velocity, both of which are subject to integration errors and sensor-like noise in the engine.

Total Least Squares (TLS), implemented via Singular Value Decomposition (SVD), is a more robust alternative. TLS minimizes the orthogonal distance from the data points to the fitted line, accounting for errors in both variables.

For a C++ implementation in an FFB plugin, the TLS approach involves:

1. Maintaining a ring buffer of the last ![][image20] samples of ![][image21].  
2. Normalizing the data to remove DC offsets.  
3. Constructing a covariance matrix ![][image22].  
4. Applying SVD to ![][image22] to find the principal components.  
5. The slope of the line is then derived from the eigenvector corresponding to the smallest singular value.

This "Projected Slope" method provides a significantly more stable estimate of cornering stiffness when the car is vibrating over road textures, as the orthogonal minimization prevents the noise on the X-axis (Slip Angle) from biasing the slope estimate towards zero.

### **Curb Filtering and Slew Rate Management**

Curbs and road textures in isiMotor 2.5 often produce high-frequency vertical deflections that manifest as rapid spikes in the lateral acceleration channel. These spikes can cause "violent snaps" in high-end direct drive wheels, which can be physically dangerous or simply unrealistic.

To mitigate this without losing the "feel" of the road, developers employ a slew rate limiter or a non-linear compressor. A slew rate limiter constrains the maximum rate of change of the FFB signal (![][image23]), effectively acting as a low-pass filter that only activates during impulsive shocks. This allows the high-frequency road "buzz" to pass through at low amplitudes while "taming" the massive spikes caused by hitting a 3D curb at high speed.

## **Telemetry Proxies and the LMU Variable Shift**

A major point of technical debate for FFB and telemetry tool developers has been the availability of physics variables in Le Mans Ultimate (LMU). Historically, the mGripFract (approximation of what fraction of the contact patch is sliding) and mTireLoad variables were zeroed out in the legacy shared memory interface.

### **The LMU 1.2 "Zeroed-Out" Issue**

While the release of LMU update 1.2 and the accompanying SDK changes revised the InternalsPlugin.hpp header to explicitly include these fields, they remain non-functional in the current implementation.1 Developers have confirmed that the game consistently returns **zero (0)** for mGripFract and mTireLoad in the live data stream, despite their presence in the shared memory interface.1 This limitation is attributed to license agreements and specific implementation choices by the game developers.2

| Data Channel | Old Interface (Legacy) | New Interface (TelemWheelV01) | Actual LMU 1.2 Status |
| :---- | :---- | :---- | :---- |
| **Tire Load** | mTireLoad (0.0) | mTireLoad | **Always 0.0** 1 |
| **Grip Fraction** | mGripFract (0.0) | mGripFract | **Always 0.0** 1 |
| **Patch Velocity** | mLateralPatchVel | mLateralPatchVel | Available |
| **Torque** | mSteeringArmForce | mSteeringShaftTorque | Available |

### **Workaround Strategies for LMU FFB**

Because direct tire load and grip fraction data are currently unavailable, FFB plugin developers (such as those for the lmuFFB app) must utilize alternative estimation methods:

* **Suspension Telemetry Approximation:** Developers can derive an approximated tire load value using vertical suspension travel and spring rate telemetry, which remains accessible.1 However, this approximation is often considered less accurate than direct direct tire data for high-frequency FFB signals.1  
* **Aligning Torque Derivatives:** Monitoring the relationship between mSteeringShaftTorque and steering angle serves as the primary leading indicator for understeer detection.1

### **Contact Patch Velocity for Tactile Feedback**

The mLateralPatchVel variable remains functional and represents the speed at which the tire tread is scrubbing against the track surface. For FFB systems that include tactile transducers, this variable acts as the primary driver for "Slide Texture". By mapping the lateral patch velocity to a frequency generator, the FFB can provide a "gritty" vibration that increases in intensity as the tire slides more aggressively.

## **System Integration and Performance Optimization**

Implementing these robust algorithms requires careful consideration of the computational environment. The isiMotor 2.5 engine's physics thread typically runs at 400 Hz, but many FFB plugins attempt to interpolate or run their own estimation loops at much higher frequencies to reduce "stair-stepping" in the force output.

### **C++ Implementation Considerations**

A real-time FFB plugin must avoid any operations that could cause thread blocking. For RLS and TLS algorithms, this means using fixed-size matrices and optimized linear algebra libraries like Eigen or Armadillo, which can be compiled with SIMD instructions to ensure the estimation loop completes in under 0.5ms.

The use of SVD for Total Least Squares is computationally expensive. In a 2400 Hz FFB loop, even a ![][image24] SVD must be carefully implemented to avoid performance hits. Many developers choose to run the "heavy" parameter identification (RLS/TLS) on a separate thread at 100 Hz, while the FFB torque calculation uses the "latest known" cornering stiffness at the full 2400 Hz rate.

### **Handling Signal Artifacts**

The isiMotor 2.5 engine occasionally produces "periodic, high-frequency oscillations" that are not related to road texture but are artifacts of the physics solver's stability. These oscillations can cause an intermittent "buzz" in the steering wheel. Robust estimation algorithms must include a "validity check" on the estimated cornering stiffness: if ![][image2] jumps by more than a certain percentage between samples, or if it becomes negative (beyond the friction peak), the estimator should revert to a "fallback" nominal value derived from the car's TGM files to prevent a feedback loop that could damage the wheel hardware.

## **Conclusions and Future Outlook**

Robust tire friction estimation in the isiMotor 2.5 environment is a multi-layered problem that transitions from raw bristle-level physics to high-level adaptive signal processing. The investigation confirms that while Recursive Least Squares with Variable Forgetting Factors is the standard for tracking non-stationary grip levels, it must be shielded from excitation loss and road noise through conditional updates and Savitzky-Golay pre-filtering.

Despite updates to the LMU shared memory interface, the continued zeroing of mGripFract and mTireLoad means that developers must still rely on recursive observers or suspension-based proxies to estimate the tire's state. The ultimate success of an FFB system in this domain lies in its ability to reconcile the high-frequency chaos of the isiMotor physics engine into a coherent, tactile narrative that guides the driver toward the limit of performance.

#### **Works cited**

1. lmuFFB App | Page 3 | Le Mans Ultimate Community, accessed February 14, 2026, [unlinked: community_lemansultimate_com/index_php?threads/lmuffb-app_10440/page-3](unlinked: community_lemansultimate_com/index_php?threads/lmuffb-app_10440/page-3)  
2. Add missing parameters to telemetry for plugins | Page 25 \- Le Mans Ultimate Community, accessed February 14, 2026, [unlinked: community_lemansultimate_com/index_php?threads/add-missing-parameters-to-telemetry-for-plugins_66/page-25](unlinked: community_lemansultimate_com/index_php?threads/add-missing-parameters-to-telemetry-for-plugins_66/page-25)

[image1]: <data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAVCAYAAAB/sn/zAAAA8ElEQVR4AeyQPQ5BURCF/ZRoFFRCQRR+WgU6iegsgsYKJKLR6K2ATmURIgoJGkKilah0dBK+I5nkkhAL8DLfm3nnnnl37vV5fnz+xq8X9X49cdw5cMPPR8g1BhFG0AYvWHQpZq4xgpCGJdxBEeBVgo1rzCKEYQEWUYoMTF1jBeEIB7Cw5q0ZNV+e1TWcwaJA8Ww2YwxBp12Rb6BQc5FCzVczphA0n4anfEaVdxnUnDCj5tNJWyz0YQw6xJBch46M2kLzTRA0woDcgB4o18hNGbWo+eYIFziBMsmjXXS4i4yaT39170+mF2RMouxhBx/jAQAA//9D0/NTAAAABklEQVQDAC4SJoGwTPTvAAAAAElFTkSuQmCC>

[image2]: <data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAACFklEQVR4AdyUSyhnURzH77wW81rNTM3UPJqaxcxIUrJgQ2FlqVBiYcNakXeysfLaK8WGJIqIIm8RkY0FIhtEWBF5fL4357r/fzg3j43b93N+5/zuOed3zr2/c146T/w8/wAf+IIJkAb/4BVI7ym+g1W3faL/jJyCLciHn1AMfRABHfAXrAoP8IYRZbAA3fAF0qEWsqEaFDgSuwxW+QNo8kZGVEIm1MAR+DVLYwwWYRes8gfIpXceVEAn3KRjnJp4Aqs65m6ZAH/opolXsK1wAbfplBczEEgmQBa9v0E7bMJdKuDlCASSAphU1KqHA4w6pI92gbFLAT7S7Tdswxo8qhTATHhCJTxrcIVISRAX4rE0FEDZsGPpp9efKGJBiYAJJgXYp+so/IAouEkvcOZAL/gX85l2KfRAIbyF11dgHEcBVNEB08pKaHwFvzSoHIeSwH8+fuFrgjZIhXdQBIkQA65MgA1aKaDo+tHN1LXiBuwAjEM9KAjGUT+d9EEaWhjGmaNIgmjQScdc70CNdYp40EXXhVU6ame6TYdom8mpOrqj9Dl1Z6lt0D+ap+Eli9kBPleaRIEUQKziPYNwnePYA6U2xpWSYJLaNHgKD+C9sFT0o/U/dJVn0LcKzEJ04+q2xRX6iVxHwEI7raOvkqIfqxu4BZsM+tFLWFf33YE7mEJn6ABrpCtEB9a0vTT1HI9deegOrOu5BAAA//+fm+FxAAAABklEQVQDAO9tYjF+ZGtsAAAAAElFTkSuQmCC>

[image3]: <data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFwAAAAUCAYAAAAA5FpZAAAD9ElEQVR4AeyYachNWxjH9526Y93bvTdlzJAPvhg+mGWIJEMo8zxEQkJ8oVDITIgPJJFCmQopIpQhcyRlyEyIzEPG3+/UetOxj/Nyzj6dD+/b89vP2muts/ba/73Ws5/9/hiV/RVUgTLBCyp3FJUJXiZ4gRUo8OUKscJ/4p56QFUorf1Ax4awBJZDc7AOV2LdKTWBv8C2cvh+UBeK1pIS/HfuuBMshhuwGv6D0tgvdJoKS2El6Kfjp4HC4qKfOSj4Ifwz+AD3oDNchaK1pAT3ht9x2Aor4FvMBzWJH0yBc3ABJsNoaASaYz+lcB5uwmboCL3gCRStJSX4K+54F+yH11Ba+42OQ+EtPIBgVyg8h94QzGsM5KQKdIOd8B6ymbvE8KbP1Nfd+GemxlzqkxL8e+dkqPjajdZmYGM27rvNd0offj0W4kSvRf1a+B/ybsUmeLYbrEyH8EAUy5fkKepuwRGoB9nMcDSPThVgAjgOLmWKPZ/SSLgOebcguBftyei3wW25EV8J4swbHhbXkIc6w4ZhyPmEuTlsDQ4K5A4I9c7jPvX1wbkuw++FBpDNDFm+J8xsguiJi+2kwuTbcDIAWkF52A17oDFEabilf02ry+epGY0r1jkpvFnLIC6g2LgSG0NpLrhAcJEP6mUUReMgvS9VX9jnovtiT3Rlh6sruJNrScUQuAiumlV4s4VFeOuNexQjfX8KlyApcyu3ZfDWoPDH8AfA9NKUzzSQ00gfxPbcsrjCfelZlw1Fdzd3oKMhyWtQTM4U/B+GfwzmsbgSu0ypPbQDUzMfwnHK1WAfJGnXGNwVXhFvXD6Bd2edxRt2BuPNvUfg080F5H2l18ed+5E0k4YW4G9CeOE0GfMi5q3rMgz/iHpjuzmuaZ6x263syqApZ3PHmKKZDobB6lA4A10gWE0Kfkytx2vGXsON5YBjyee7ILTFecWeQ8NwcMfOwnuNREVXcMW7y8Uy2UcaDDWb8CfBbYv7JlMcr5X+I2OzAhm3XZm2m1cruoJ4/jcHH/IavDsMFx3k4EvSXUcxZU05msr5Zeou4DSjOfYMWhXbEEYxUofERY8TwYvnihnEBgZxh8zGu3KMxXcoL4Rgvi/ecHIawoO07IN1tfoRZObh16Qrz5SOrtFRDj4oX+72Cf9zGU/9Fvia/UFjXxgFQWyKKVN0Q4xziksYUp1yOSQl+Asm5Wf2v3hXd8DUTlGoTtl2joYTsw13EqeRL8pmFBT6Ib4rGLMdk2LK7LuAkpmVfXZQrg7+o8s2ihnNTGYireliU5UyH7wP8HDqLM+HpATPdZr+O8A0bxsDubpxsWabfVzpvotiOxVTZbEKXkwa5XUunwAAAP//SYP5gQAAAAZJREFUAwAqaLkpSJwzMQAAAABJRU5ErkJggg==>

[image4]: <data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFwAAAAUCAYAAAAA5FpZAAAEaUlEQVR4AeyYV6hURxjHJyYh9SEhhfQKgZCEJJCE9B4IqS+Jir1gQUVUVFDxQVDELooKViwviooVwYYo9oYdrNgQxd7F+vutzrLeu3tW2Hsu+3Av32+/b+bMOWfO/8x8M+fWCjV/1apAjeDVKncINYLXCF7NClTz7dIc4Q/zLH/CyHv8h38CitnjNGgEH4Kx13mNuCW8BdH+J/ganoaH4EVoAJ9A2Vpagj/KEw+Fz2AQbIaJsB7ehCRT5LY02AZX4AYchvfgKGiP8KPgK/EX4BYch3/hAJStpSX4Lzzx+zAW9sEYaAUfQE9QMFxeU+CTHNkB+8EX9SW+C1wHzTbnCWzjy5hB/BfUhXNQtpaW4B/zxIreCx9tGYEj9Cf8c5BkCv4bDd6FJrAWbkOuOfobU/EGmK7m429CMTP9mJr0hdrav6cKHSylPi3Bl9CpLbAOoimGOLrTum+8V5J3TahHgw6QT3Rn5iSOPQ9Vbmk9+AZ66uI1Gh/N0foKhU1wBpLMPG4K2U4jZ8VsvKMSlzXFcpH0ekeoXQ2fQjEzHQ2gkX3pjPc6uIwp9kCiNnAQqtyi4N60Dlf34RyFU4ndGeAqmVOtRaXa5AoX0eY0uQh94Sok2TMcNI18hLcfW/ELIXfBtR8nqPscbDMC78z6Al/MXAu608idTRQ9dbG5X/bD51cKbsXMry8T+3CL8F9BqIDbsMcq1BUr/kOD38GdRW6aoaqSXaLGnDwNb96WOcSK2hQfrT1Bf3CA4IJrxOUQQkcwbeESLVd0Z2KqIzv2xBFu536kohnsBkfNOPzfMASsN+8RBn1Dgj3woOaI60FjRV+ML2YK7FZPH9u67bP8LRWObFywTRTbsrF4Pxc964qh6M5mvxdMSYeKnVDqcQV3+p7lQu5jcVnbS/QHODJ34X0J7qPfJl4KD2I+/GAa1gbP9eWad70nVXmtH7UK4S6F8D7zfNOfI92X0Pq+o3cLtvG57paSf11n+tDkB/CcmF4opmPexH3rlAKXP029ud097gJic7dTWUEoJpr5tist6oMvDxcU+vsQgiMRF5wxLoYukpblJX7sFy5rlhXajxpTjrnXcrYBgdcS2zj6qUo0xfbl+gXrjHVt8Us4VdF9EMU7ltA1p7KpZjptNkIUi7CgKdpkjv4MK8CpKjuJFd09NGFwj61AE0IIjkxc8MWagmL6UVjXmGscHAX2ZzneRdJZR5ixb/h1Kzcc7+KMK2iK3Zujih13I+qQuui1uGka5gfJd1z4WXg9hxeIHU1uzQiD64VC+ukfX6RfjZ7jC/Y6fmk66tw7xwV3DSf7olzc3f0Mo+z/bDrhZ0KSPclBZ53/PohiU5UxRTfF2Kd8G4ZMo1J+0hLcqerIzIejN/Z5LoHpxN2GI5di8KHbEXQD08d4/KvgyMdlzLb+j8ad1Slq5sE7oOgeIyxo7mTc41cUO57gi/cFrooVVenTErzUPipaTGNu9wrt2/0/yixu5kh3LSIsbytXwctbtRJ6dwcAAP//k7bJmQAAAAZJREFUAwDTmtopS2L1xgAAAABJRU5ErkJggg==>

[image5]: <data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAmwAAAAiCAYAAADiWIUQAAAItElEQVR4AeydBagtVRSGj93dja3YjYld2IEBBgoWtiKK+hRssQsTE7E7URFFxRaxO7ExsNv/u7y5nnffOe/d++49756Z+WSts/bs2TOz9zc6/qy9Z+6EDf+RgAQkIAEJSEACEuhqAgq2rr49dk4CEpBAWQjYTwlIoJMEFGydpOu5JSABCUhAAhKQwBAQULANAURPUQ4C9lICEpCABCRQVgIKtrLeOfstAQlIQAISkMBwEBiWayrYhgW7F5WABCQgAQlIQAL9J6Bg6z8rW0pAAhIoBwF7KQEJVI6Agq1yt9QBSUACEpCABCRQNQIKtqrd0XKMx15KQAISkIAEJDAAAgq2AcCyqQQkIAEJSEAC3USgPn1RsNXnXjtSCUhAAhKQgARKSkDBVtIbZ7clIIGuITBJejJLvNnmyMaC8UYHfO6cc6G4JgEJ1IiAgq1GN9uhSkACQ05g2pzxkfhd8WXj2KT5OTj+SRw7KT8vx1+Mfxh/NU75tcSN4wO1r3LAqfHZ45oEJFATAgq2mtzo9sN0jwQkMAgCq+XYT+NnxT+KY7vk5/X4H/GZ4zxnV01cJ/5bfKf4CvED4hybMCDjvIfmiB3jmgQkUBMCPEhqMlSHKQEJhADZn6kTsQnyM3G8rDZDOl48wyZKmfEkjDebPFdaKf5Y/M74d3Fs9fzcH8cWy8+18V/ii8SniH8c/zf+ffzL+LgY51gxB3K+BE0CXUDALnSUQPGw6+hFPLkEJNA1BHZOT/aPY6vk56b4cD8HEI2TpR+tHIGZXaMZbR9I7Txx+n9j4prx8WVc85BcjGwa2bMtUi4M8ci0JdtP5IdsW0KDdu+k8HMcY1r0awrj6PSB9WzjeLiHSUACZSLAf/Bl6q99lYAEBkeAqbgi+0P51pzun3inDYHVLgO2aC6+bhtfI/WtRNv0qSej9Xkigm+mRIQRAuaclFtlnlI9IOPFAaY6i4xk88EwOzMV78X3id8Sx2j7E4UWjkBmvdtfTfsYG1xwplfZbto9xiLCb7YxtnCnBCRQGQIKtsrcSgcigbESmDItEEdvJiIQVk58Kt5pQzzdnYtME29lb6Xy0Tb+ZOr/jPe1ZVJBhor1XIgWpha/Td1n8d9HesKgbM4czZTmVImtjDdDEaKsS2ve/3fzxsgyWTfO9eDIbQJC89IUWOfGfsQmQjBV/bZ2fev3CWwoAQmUg4CCrZvuk32RQGcJ8CkI1l0haMhQLZDLsbaKzA6i6oRsHx7nbcfjExERmyWy75jETeIHxbeKk1UikzVfygjBkxP3jiM6DkvcLn55nLcoj0tEKCIQUxzNlkjNpm18/dS3yjptk/pn4xhTjc+nQP9mTGRsJybyfEN0nZvyenHEFeeiP0xnpqoxf34ui7fq2wupZ/yIwRRHsyVTwzq0hF5DvE3Xu/V/Ya4UEWiI5RQblI9KAfZkF3dI+cc4LC9JZKp130TGQPnslBHZCb3GeL7p3bIgAQlUmgAPg0oP0MFJQAK9BNZOCYGyeeKucabmWM/G5ydGZPuMOFkrRM/iKSN2ECyzpkxbnhdMAf6Q7Y3iZM1Y+M8UK5k6pugQcEtnH5kxBAjZI7JKCLyHU9/K+OTFbdnRyu9NPQIzodfI1G2YrS3ju8WXiyOIuBbC655ss3YMEbhHyog3xBGCh2lJslLvp54s3dGJ98X5RAb7UxzFxpTxYkr5pVFaNxpwQuhyDXbBDq5FJo2+wIh2rB9EPMKPe4DYhedzOZDPf8CaT4Ig7mCE2M6uXiOTR5veCgsSKAgYq0eAB3D1RuWIJCCBvgQQI2ulEoGGmDo/Zb4BRlaN5wDrtRBYCC8ySrz1uHDasC6MbUQD05aIIc6FyGE9FuLk7bRDWN2ciOBjihPxRlaN6UxE4tPZh9BKGLQVLxocmTOxdgwxNiLla+KINL5vNm/KjOvdRITcQ4kIHvrDtCkZN8ZHFvD27GMsvLmZ4liNdWqIxOXTspUI/SD17E9o8PIBWUtYIyr5HEfx+Q/eGn0ljegnIg7WtOctU8qITkT2HWlzXZzp34Qeow+8Kdo3w9ez0x8JSKB6BHhQVG9UjkgCEuhLAGFFFumZ7GCtF5kjMleIAAQMbytum31k31g0z3Tf9tkmy8bUG9kcpk9T1WBqFQFE+Y38kC3aPZFsHOvJEBtMC3JO1nmRbSITxnnSDBuUk8HjUxqIG4QhJ0NsIrh4iYLpWKY+H88O/toA2T3GgdNHjkFgwmKDtDkwjmBK6JdtnVYXxeHIVGyKo9gF2YLd2J6vTBczvYyQReCR/aMOTmQxf815Lo7TZq9ExpfQY3zDjbH2bPgjAQlUn8DYHijVJ+AIJVAPAgg0vo6PyOk7YrJOR6SSTA5ZMjJArGHbL3XHxhEPpycWdkUKTNklNBBxtCMDhIDgWLJzTPHtmQZk3C5MPC8+VOutyOCdkvM1C5hs9hhZQNZ7cT2yT6ellr86QJYLIUkm7srUMU1LH2FC/9iX6n4ZYo91cZwLdn0PIiN5VSoRgwlt7frsYRz0g3V/9Jv7U0xXM76r04Z2CETuYTYbS+WHz4PwFxNS1CQggToQULC1uctWS6BiBPifPdOZxFZDQxw0iw8yb811ZNiK45rL1DW3o4xTT+aNyDVxykPhrBsrFu+3Ol/zOOgD/Snq6Ad1xXHU9x1Psa9dJLN2Q3Z+EW9n9BFR2G4/9fSruDblwpv7RzsyocTCmUZlKpixFHVGCUig4gQUbBW/wQ5PAhKQgASGlYAXl8CQEFCwDQlGTyIBCUhAAhKQgAQ6R0DB1jm2nlkC5SBgLyUgAQlIoOsJKNi6/hbZQQlIQAISkIAE6k6gDIKt7vfI8UtAAhKQgAQkUHMCCraa/wvg8CUgAQnUh4AjlUB5CSjYynvv7LkEJCABCUhAAjUhoGCryY12mOUgYC8lIAEJSEACrQgo2FpRsU4CEpCABCQgAQl0EYEBCrYu6rldkYAEJCABCUhAAjUh8B8AAAD//0DOFHEAAAAGSURBVAMAQJ9CVHVwdPQAAAAASUVORK5CYII=>

[image6]: <data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAmwAAAAwCAYAAACsRiaAAAAIr0lEQVR4AeydZ6hcRRiG1y72rljxh2AFG4hdsYAKitixgWBUbFGj6A8lGBMN/pEEFSIISrA3hICCYERQY0SMNQYLliQqiok1dp/3kr3cJJvkbvbsvXN2n8v3npkze3Z25pnL4WPOmW/WbvgnAQlIQAISkIAEJFA0AR22oofHxklAAhKoCwHbKQEJdJOADls36Vq3BCQgAQlIQAISqICADlsFEK2iHgRspQQkIAEJSKCuBHTY6jpytlsCEpCABCQggdEgMCq/qcM2Ktj9UQlIQAISkIAEJDB8Ajpsw2fllRKQgATqQcBWSkACPUdAh63nhtQOSUACEpCABCTQawR02HptROvRH1spAQlIQAISkEAbBHTY2oDlpRKQQF8R2JjeboA0CUigWAL90zAdtv4Za3sqgX4gsBedHIt2Q53acVSwP9IkIAEJjDoBHbZRHwIbIAEJVETgbOrZGz2GLkMHoljuc2PIzEOz0FQ0BT2DpqOumpVLQAISqIJAbmRV1GMdEpCABEabwIU0YCH6Bj2L7kHroX/RNDQfTUZXo2vQ5ehtpElAAhIonoAOW/FD1O0GWr8EeoZAZtVOpze3oE3R7mh9FNuEw/bodRQ7msNfaCbSJCABCRRPQIet+CGygRKQwDAI7Ms1E9EkdB+6Fi1Gf6NY3kVbh0wctXGk26IfkTNsQNAkUAkBK+kqAR22ruK1cglIYAQIrMtvPIBmoDhhcdR+Jp931P4gjZ3PIY9JHyfNbNtcUk0CEpBAbQjosNVmqGyoBCSwEgKbUZ4Zs+bjzo04z+PQzLSRbSQ8xwmNRmM2J/+h59AnSJOABCRQGwI6bLUZKhsqAQmshECcsK/4LLNrJI1TOcxB36LYdhx2RO+j2DsclqBt0N0oj0sPIN0VaRKQgASKJKDDVtKw2BYJ9A6BBJxNHLP96NJaaCuUMpLKbRE1vomyAvRm0rzPlnfY4shdwflbaEP0Eso7bCTL2D+cnYTixJFoEpCABMojoMNW3pjYIgnUmUDeD8ujyJvoRF74j6MWRyqPIbt1v4ljFkftTn7zYXQrygpQksb9HLZG+e1dSF9BTfuVTMoSBmQf8j8hTQI9QcBO9B6B3MR6r1f2SAISGA0CcYwyixWnaAINSBq9sTT/O2m3LE7bAiqPkie7WotD+S5XXYny+LS5QIFTTQISkEBZBHTYyhoPWyOBOhNIQNpf6EBWY5IMWh5ZPjV4NpAp4nAQrcjig7TvLvLDdfS4VJOABCQwsgR02EaWt78mgV4lkEeh59G58ehPNNQyy5aZrKFlK8tfzAd5vNlK5/BZlfesLD74mjqzldV3pJoEJCCBYglUefMrtpNr0jC/IwEJtEUgqzATTuO9Ft9K2I3hzl49xPcz29VKiaGWbaa4ZBnLwoY10R7UknhtCQnS/H52Q6BYk4AEJFAWAR22ssbD1kigrgR+o+FR3gsjO2gJnXHW4NnqM1twSRyoVspnfKxJoFYEbKwEKiGgw1YJRiuRQN8TWAiBbPN0BmnCeJA0Ekoje3s+nROU0Blnk+axaWa0st8np8tYFi7sQEkrZcVps24uGbTM6lWlLD4YrNiMBCQggVII6LCVMhK2QwKjRaCa300ss6uoagx6EI1F09Cj6AcUR2xP0idQwmecSZoFCiTL2Kecrcz5+ozPhvtodTeuTXiPi0jzSJZEk4AEJFBfAjps9R07Wy6B0gjEMTuSRl2P4rTFWWo6ZYl3lt0I+KiRmbUEuh2u85XvtKPEVLuBL2QXgwTNTVy47DdKkSYBCUigngTq4LDVk6ytlkB/EogTli2iMos2lEBmzfJ+27EUvojycv/GpN2wLID4nooTV+1D0iyGyCNWspoEJCCBehLQYavnuNlqCdSNQB6ZZreDl2l4AulmBi47DXBauSWMSGb78lsnU3tCjjQfi2Z7rMRfO5Ty5Ekard6LS7nqOQJ2SAL1JaDDVt+xs+USkMCKBNajaDqajY5BWaWavUUz63cA5wkbktWsmXVLMN+dKYvzRqJJQAISKJeADlu5Y2PL+pCAXe6YwCXUkPfm8o4c2cYSDln5mUekE8k/gj5C+Xwn0ktRgueSaBKQgATKJaDDVu7Y2DIJSKA9AllYkN0WZg752uHkn0Tro7w3l8elZBvZjSHv22Vrqi9ToCQgAQmUTKBNh63krtg2CUigzwlkF4S5MGgueNiOfGK33UuaBQiZaYuTxmnjYA6bo9dQVq2SVGanUNOJKCtV8/tkNQlIQAKdEdBh64yf35aABMohEIftRpqTlajZk3Qy+XFoMcoK1Smkt6PbUHZNyGeJHZdVpRSt0rIwIdcl4G9m61Z17zyeml5FH6CEOSHRViBggQQk0BaBVd102qrIiyUgAQkUQCB7gyYOXAL25n22zKo1m/UCmevQBDQDZdVqrv2Y/OrsCC44BMVZi1N4Lvk70PPL6TDOs60WyYDlPbmBjAcJSEACnRDQYeuEnt/tZQL2rb4EEkKk+Y7a8r3II9GoWT403yxrlZ5GYZyzz0mPQnH+JpFesJyyOjWPXykesKxIHch4kIAEJNAJAR22Tuj5XQlIoJcJZHZu/tIO5rHqluQzY/YFae6dmW1LGJGhSvk8Pk+g3mzFNYe8JgEJ9DWBajqfm0s1NVmLBCQggd4iMIvuNEN+5P23DTnP9lrjSRMuZBFpAvQOVWbXplKeWb7EedNhA4YmAQl0TkCHrXOG1iABCfQ+gcywxXmLk7aA7ibWG0lLy2PQhArJ9VkI0fKikgptiwQkUD4BHbbyx8gWSkACEpCABCTQ5wR02Pr8H6Ae3beVEpCABCQggf4moMPW3+Nv7yUgAQlIQAL9Q6DGPdVhq/Hg2XQJSEACEpCABPqDgA5bf4yzvZSABOpBwFZKQAISaElAh60lFgslIAEJSEACEpBAOQR02MoZi3q0xFZKQAISkIAEJDDiBHTYRhy5PygBCUhAAhKQgATaI/A/AAAA///fT4KeAAAABklEQVQDAOzOFHDPUYjNAAAAAElFTkSuQmCC>

[image7]: <data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAmwAAAAjCAYAAAApBFa1AAAJkklEQVR4AeydBag11RqG53Z3c7u43dzkNtywWxQTVFAxMDAQREFURLALUSxUVBQVFRREVOzEDuzu7nqf4azteNjnePb55/jvPfPI982KWbNmrWd0fPnWmn3eX/mPBCQgAQlIQAISkMBYE1CwjfXjcXASkIAEJoWA45SABBaSgIJtIenatwQkIAEJSEACEmiBgIKtBYh2MRkEHKUEJCABCUhgUgko2Cb1yTluCUhAAhKQgAQWB4HFck8F22LB7k0lIAEJSEACEpDA3Ako2ObOypYSkIAEJoOAo5SABDpHQMHWuUfqhCQgAQlIQAIS6BoBBVvXnuhkzMdRSkACEpCABCQwAgEF2wiwbCqBDhH4Webyofi42EcykF/HPxDXJCABCcyRQH+aKdj686ydqQQKgY2TWT6+Y/x98XGwLTKIv8XXjmsSkIAEJDCNgIJtGhCLEug4ASJZV2SOu8YPj4/DO+CTGcdp8f3iF8fHRURmKItu9iABCUigDQLj8LJuYx72IQEJzI3Ay2l2WRyRdHfS1+PFvpnMp+LFeD80lyg/mBM/iFOfpDV7Lj3dHP90/Jb4m/Fi307mw/FijKft+5e+SRGLzHFxLRdz3x9nIM05wj1VA/t8cngSTQIS6AuB5kuhL3N2nu8gYKFnBBA8u2TOG8abS6LfSHnT+EtxjGXT25NZNl4McfebFP4bb9MQJIyJ5dC1Gh3/LvnV46/FMdowpj9SaNF/kr6+EscQizBamUJL/tP0c0P8jvg1cQThZ5NeHqdur6TFVk0GMf1GUsZ0VVKij03R+krqDorTRxJNAhLoAwEFWx+esnOUwNsE1k22iITvJ09EJ0m1Zg77xF+NYwfmQNTr2qTFEDMnp/CvOEurSVqxndPLRfGD4/+IF1slGcaBeEm22iOHZ+N3xtswBNF66ejE+BfixRCFf0/h5/HZDKH3tdkaTJ27MSkC+N6kiFD6J5p5dMrch/17yVaM4VfJsGSdpHo4B87xHBBpKdZGRBJm8KkrPEhgLAg4iAUloGBbULx2LoGxIvDljAZhdmRShNp3kn48Tj1RKwRCirURvSHShMggulMEGlG2x9OC9kkW2RAuCKMz09PH4ojIjyb9Vpz7P5O02NeTQaw9lpQ2ROaSnbcx38Ny9QPxpjFHRNxyzcoheSJncxFsLLPS19VTfSDaEGb7pnxfvBgC7KZSSMp1yyQlEkee5WrSVFWIwL8mw7NJoklAAl0noGDr+hN2fhJ4mwDLbYgUBAnRJfZBPZ/TiAeEGfUp1vaXHO+Jfym+VXz7eLFbk1kqvqiG+NgynSBIiKIh0lKsWJYlikckkHJxom/np/DL+LbxzeKj2ChtWcL83igXzNIWcfm/nOeDih2S/jt+bLxpiNMlU3FlvNgnkmFJ+rqka8S3jv8hXgyxxlJ2KZtKQAIdJqBg6/DDdWoSaBBAHP1zqswy297JF/HGxv4HU2bJM0nFe2GlZFgeRRyxRMfHCqmqjevYh4XIqCumDvy2G33P5ETypprWCRE1hB9RKq45NLUIpSQV0atHyUw50bSlkyfShwAiEkWkLVUDY47s/xrmRBIHDeeQYemVKOT0poy59M846LdZnt6e8hdzIJIIS/rdIGU+sEgyMOZH3dODmqpCwMLst6kjOsf1TyVfjKXRr5aCqQQk0G0CvJi7PcNJmp1jlcDCEeC/dZYU2eCOv5BbsexHZCvZCnFGiiNK2Fv1+xQQC0S1dku+aUTnEEjNOpbp+GmOmbwpwLgOsYMgYTyHpIKIEhvsk62tfGxAgfv9KRmWCPmKkrEflXLTiAZuk4phzh6yYQIszWc0xtM8iahaPxWl/xWSXydeynyoMJ1JTlc/yoFlV35KhX1rCLwinnNqYDyLZpQTAcxzWjEtuDf34yvaFAf2uUHOjAQk0GkCvMQ7PUEnJwEJ1ASInj2Z3CNxolQIC/aypVixT4wN79RRRviQ/j8H9qqxNPif5IuxFIcAQWCUOlIiZbSbydkXR7viiJMnUuD+3IPN9eeljLFP7jNkppwN/vwMCV+ostcLAbfE1LmSMDe+fB3me6ZRU5SmOKsRPSSC1WyEgESMlv6Py0m+1izlY1KGc5J32J9TOjXO8jPzOj55vn5NMjBYci0itlQimDdJgXvulJRlbMRfsrXxHB6qcx4kMI2Axe4RULB175k6IwkMI4AgOD0n+AsHuyflJzKI3iRb3ZYDS3ZFsCGezk4dYor9akTbyrlUV7Q9Nxn6TDIwRNxZKc3kCMacHhhC7YSUGBN7tIiClaVX9nIREczp2thnd0pyLCnen5Q9Yc0N+6ka2RCmCKLv5kq+FmUPWbK1EflDANaFeR6I6LH8ydwQW3xcgSDji0+EJ3vSKNM9YhDWLINShjcfhVyQAvPlXU00j+XoVNWGwLurznmQgAQ6T4CXQOcn6QQlIIGaANEg9omxX6zsFeME+8H4nz8RG8osgW6eDHVs7meDPAIuVbUR7eKrzrowv0N9FRG27ZKjfz5qIPqUYm2X5IhoQrgkW7FkypIi+Y1yQHyyGT/ZeRtLtPvn6h/G+bCiOSf21l2a+tmMiB1zmKkN5+HNEi4/p3J9GhJlY84sZRL1K6IZ1kTeykcFlBFojJHI42q5lvZlDxv759h32GSWJpoEJNBVAgq2rj5Z5yWB4QSmL/PRiq8yWc5j6Y4y0R6cPFE0olrkcSJFRMoQC5Tb8GFjQtiwX4uN9tyDyBtjIY8Qao6JujadvWtEGc94l07PyXnEbpJW7ML0wju5COcXUy5GvsyfOiJ3/CYeeV0CEugBAV4OPZjm6FP0Cgn0jABLnL/InFmGSzLUiOqwfwxxN7RBy5VHpD9+ymP63rdUL5ixd429cUTeEEmz3YjzLG/O1maUc0Tr+CgBMVZE27DridhxX/4KwrDz1klAAh0koGDr4EN1ShKYBwGiVvyQ62x7oojEIWTeq43uCCLGVJYB5zGtkS9BNJ2Uq/hrBEnec+PDigNyVwRZkqHGEilLxIx1aAMrx4qAg5FAKwQUbK1gtBMJSEACEpCABCSwcAQUbAvH1p4lMBkEHKUEJCABCYw9AQXb2D8iBygBCUhAAhKQQN8JTIJg6/szcv4SkIAEJCABCfScgIKt5/8COH0JSEAC/SHgTCUwuQQUbJP77By5BCQgAQlIQAI9IaBg68mDdpqTQcBRSkACEpCABIYRULANo2KdBCQgAQlIQAISGCMCIwq2MRq5Q5GABCQgAQlIQAI9IaBg68mDdpoSkIAExoqAg5GABEYi8BYAAAD//3UpnsMAAAAGSURBVAMAwepGVvjNqzkAAAAASUVORK5CYII=>

[image8]: <data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAYCAYAAADDLGwtAAABf0lEQVR4AaySOyiFYRjHj8thQEkMymURkgwyGQwGShmUXcpIKYxKmUi5jQZJJoOUsFoUBkQWk0thcBkot+P4/T7nnM5ldXp+7/O8/+//vd/zvu/JDmX+cpBGYR+qIQtC6cZcxBFohFlYghrIMNYivsMArMMYdEFO+ooXiAvwDcYpwzxE0o1oQeQzFkHieaJANJzbUyuTdmiBPEjp0d01IdpXM9ndz5DVUoxViJNwDXOwBU/QAwmjPfUjaF4lRyAao4EctidyqI6hD3bgFoxCBl+0x+B4NHcjlsEu/IBRylAJ9/ChqYCiAzy7NvJQjEFyMVxCVGM5RT2cwzMY6r7kywdxoYKiBDZgMcYaWdMJ+QyCXftpd+h1qYln58GvMPGIAuMbk1d4AcNd9lIcwiYEm7OXKyZ3EAZvp5PsahPkBwhC4w3VMgzDOLjaNPkIbIkUCj79SaXRa9umnoI9cDOkv3BFq0cGj+GY7H/yi5wScaOiTXvH1hkkGzMeJgv/b/wFAAD//9klsPsAAAAGSURBVAMAaadIMUUFXTUAAAAASUVORK5CYII=>

[image9]: <data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAAYCAYAAAD3Va0xAAABgklEQVR4AeyTzStEURjGr48Ns0H5SFaSJKUosiTKzgLJAv+BP0A2UrZkb4OSsmFNytdCyoYoFrJQyMdGZpqpmd8zdW5nzj01i5ndzPT8zvuec9955t73vlMZFOlTQkbDtOwT0hbf5HNgtEpiXz9kH3N7dMphI2yBiseIDbADRtsk1yDzGuIE/LlGnAX1LL3wCg9ga4TNOszALsQhK59RC1fa4R6+QKpiWQTd4TTxBXLkM+qjQo9zRtQvxoib8ANL8A8R+YwGqUrBJXTCBfTDEahvhKhcI/VniLI3UJ9WiAkYAJ0T/HKNTH/aKK+DediACliAavDKNTL9WaZ6DZKgkXgkjkMXeOUaaSDVn3OqTT/eyfdBdzhF9Mo2Un/UF83Pk1N9wP4XND/NxIhsI81ONxW3YOaHNCs92gmZHk2zRJorGY1ypLd0Q6yFSdB+lig1sVyBzgmB/i53JB0QSkbH7FpBb8agL+9xJn2w6PWba4o9nD1DKBmFm0KSslH+7hWtRxkAAAD///PvT2gAAAAGSURBVAMAfqRDMWl5VYEAAAAASUVORK5CYII=>

[image10]: <data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAYCAYAAADDLGwtAAABMklEQVR4AezRTSumURgH8LuZNE3NNM3MbpqmphTFjshGysIHsCRlLbbK2kLKzsvKZ6DYKFmw8bLAgqSk2AkLVvL6+z+6xYJ8AE/X71zXOc/Vfc597k/FO38fjW9eVHk9n3U10EoVz+OHSVUa88eYSQfDjFBGjWKfzjS2KU4Z546/ZAepaDR85yCN1Yo56mhihlsSzYbDSOOUYptsfS6vkfhpaGGLszTKxTdDjrAqH5P4Z8gZl+X7sjHn+G9hgxsS9Yav7FCUjXmJsiHruZJeRd54T35qPDGZpJ9pFmlnnTOeGr+YTFDLEANcssA9lcbc26bJPFnME3rURyxRiZzxt+oXs1zRR7btlnMkqag8cVc1Shcr/CFfJPenfIw88VqZb53LjUHzC15EGl8svDZ5d+MDAAAA//+mMZ8FAAAABklEQVQDAPkqNzG5D1F7AAAAAElFTkSuQmCC>

[image11]: <data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAXCAYAAAA/ZK6/AAABcklEQVR4AbSSOUsDURSFxwW3iKC4gYgKVi6IooUgCpZiofgLrBWxsLLSQrBW7Gyt3EDt/AEWiohYiI1aiCIhabKHLN8Jk8dkMiSkSLjfO/e9uSfvzk1qrQo/VTHUOJsod0MHxd1gopxhlco5MFHKUE/VMLyDiVKGLqra4BtMeBn0kj4qpiACCTDhNKhwiCcrMAvLEIclmIcGsPIG6QIH6zANrdAJjzAI2yCTMcxwsAshOIAn+IN7OAE/bECLvln9brFRfoqqb7X2ZedJ9B9GwKeiPpJFuIMAKCZYXkHRxDIKvxCToZGkGT5BoYIBkg9QTLKMwRmEZfgheQCNsQ7tAU1M7zBOvgPncA1pGYIk+6CpHKKboH730DW4giPQi+emlGGj8R2jN9AO0lv0Ai5BtyFWzqAkxaL/zDMaBg1Abb6Rx8CEWjIbkl7Qr6uJ6Ga2heE29PP4BXQjUhxug9rQNIor7RO3Qe1E7Wee4jZ4FjkPswAAAP//SVnU8wAAAAZJREFUAwDV4kEvTz1lFgAAAABJRU5ErkJggg==>

[image12]: <data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAAZCAYAAADnstS2AAABLUlEQVR4AdTSzSpEYRgHcJ+zUCx8rZTylRKJC1AIuQCxs5GNch0WZGPjClhYKWLBCis2E1kpG2slLHz+nqk5nWNmFjbK9PzmPe/z/DtzOvPWVP3i83fhJk8VLKWVfoxa4zlO2KKBTKXDnyYHXLDAEJlKh79MHtijnmmqSSodLjbzLm6YpZmkyoUfTY8YYJikyoU/TI95Z4okk1xopuvaJkxYWyhUpXCbaY5+RihUuXCvySJnvDFDHVU/w32aK8Rr3LReMU78UibcrblKO9vcc0gPoyThTpsIDlrXiWDc/dT1C/HOc/EYjTbLjLHBJcW6dXHOJB0RjlPWZbPGPnFHS6Gefe9yR2uE4zws2ewQf4glU9Gf18lHOO70ZBOnzlJS0Y8j8Brhkmmlxn8MfwMAAP//ly3s2gAAAAZJREFUAwAxqDMzYiX8VAAAAABJRU5ErkJggg==>

[image13]: <data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACMAAAAYCAYAAABwZEQ3AAADQUlEQVR4AdyWWahNURjHjzEzmafMGfJgipQpD0LGpJRSMpR4EkmZ40WEvBlfSEopb54MRXhQpjyYIiFTCJnj99unvdtnn3XPvfvk4XZv/9/+1vrWcL619rfWvo0L9eivwQTTnk1tBnlkf8cFx1S7M7OYbSuE1AZnV2gCIe3AuQDKVE0wo5hlPeyGXxBrKoW38BlOQQvIyv47ca6AcVCivMG0ZPR2OARvIK2LVAz0BfYGfIWQ3uM8CLvAXcQUlTeYKQzrB/4wpkxD8fQAg8HUqGu0GMhsbKI8wTRi1CK4DK8hJLf+Iw0PoZI+0eiCFmKbQqRQMN1omQOTwezHROrE0x+7hA3JHJlAw114DsoxMym4W5gSXaE2FrpDpHQwg/FchwPQGiaBiWieUCz05dEWnkFIPXGOhjvwBQzC3DCxj1B3Tkwic84TlwQaBzOCLlfhHCyG03AYWkE7UP6YO/XBSoAB+DzSF7DzoTfshVXgrmFK9JLaHyjZGVduZv+gwSD+Yn1VnhpfiSvAFeknz28QkjvgHHNpdM6j2AewDVZDTacrXmzBnfH1eEpclcnpq1rH4OPgygyOYkW58pH0MBndlXmUh4EB7McaFCYoFx41GEwXSh6zLdg+MB42wE2oSyB0K3Tm4aveg+0F5oynZQjl2pScPIPxmH1nxH3IypwxyfSbK+aMO2g9Tfp+8TWaex3p4EJN0H2Um0Navkrn+x07DcYt9AS4I7Ff67E7RqEDKG9OrT+gTTOGirl1DxvrHQWT1CvCS9B8w5XIY2/gT2OPwbgzZrwfvzM0eIrMG0+V35A4CO8OAx9In7TcOY/0bZyvQLk4x3m0p+M4D1mZq84pUZvBWLjFw9WtwW4GL6+1WBMQE8k88HRNo2aiYiJ5PJdTMnFdKcWCd5HfqaVUVoILxiRyvJ8C53PeqCEOxoqTutViWV+WkzgGgTmCSeSE5l3ioOAX2lcVmsvvW3/6OB+mqHQwRU/l5yOaT8Ay8FuFyS3HLWHUWXgMifIG40DzwFMQ/AfJDrUwkfbh4L8hJVdHNcG4/RuZzEvOTwDFOss7aAa9zbFsHkU3MG25ZWJ7ST7JOdJ/vDYxpiwQfFUH49j/zj8AAAD//4kqdg4AAAAGSURBVAMArFOUMZvWEh4AAAAASUVORK5CYII=>

[image14]: <data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAmwAAAAiCAYAAADiWIUQAAANP0lEQVR4AezdBYwb0RUFUJeZmZmZmZnUViozM6itSlKZuWqrMqnMjCozqszMzMxwj5WJJo69kPVms7s3em8+052x/933/jiHnfRfESgCRaAIFIEiUASKwCGNQAnbIX17OrkiUASKwHZBoPMsAkVgMxEoYdtMdNt3ESgCRaAIFIEiUASWgEAJ2xJAbBfbA4HOsggUgSJQBIrAdkWghG273rnOuwgUgSJQBIpAEdgKBLZkzBK2LYG9gxaBIlAEikARKAJFYO0IlLCtHavWLAJFoAhsDwQ6yyJQBHYcAiVsO+6WdkFFoAgUgSJQBIrATkOghG2n3dHtsZ7OsggUgSJQBIpAEVgHAiVs6wCrVYtAESgCRWDNCBw1NY8f7T4TECqbhcDu6bcfpN1zr7vSIlAEisDBQuDYGegi0YtFHxU9XLRSBIrABhAoYdsAeG26qxE4fFa/aBPyubpgysdy5CTkJ5jKMXO1oSVYqhwpvY3HSXLL5WiZwRWjmzUv98H9yBBLk5Omp7NHNywb6MAczrqB9stqCtvZZ/Uo6Xx8P4+b9MWjh4kSz/cZE/lI9ApR1rZjJbxcdKiTaKUIFIG1IjD+wK21TesVgSIwmVwmIPw6epboWGxGt0qGDSzBVF6b66+iJ4sO8sdEzhw9cXRZ4vN8z3T2sagNMsGWCzxulFl8LvrfKHJlM79G4kePLkOQmu+lowtFlyU/TUdXiW4VjnC6Tcb/WnSr5faZgD8EEkyOmMubo3+KniQ6yG8T8TyfPCH5YS7PjJ4j+tHoX6J/iCKhZ0tYKQJFYJ0I+IJfZ5NW31kIdDUHiMB70+7l0WtHx4Kosa4pH/Ifn8iPowhegr3ynsReGmV9S7BhQYietKeXS+8JNyvw3XHTdM76kmChnCEl54wirAkmp82FleWRCW3+CTYsX0oPz4giOAmWJh9IT0+IWmuCgyo3yGg/if4vupWCsJ4qE/hwlPwzl4dHPxOdfZ7fkbxHRI8QJafM5XjRh0QR9wSTt+Ry9+iy7n26qhSB3YHAVnwR7Q5ku8qdjgBy9Owskrtn2KCSnJwvl3dH/xUd5NyJvCv6j6gNjPUk0cnPcvl39NTRZYkN9fXp7DrRzRQb8JkywLCWROfK9ZP7vugg30rkDdG/RpcprJiwXyYRYN3iFj3OOieKlJ4mbWCE0CI9dBz3zHARHiP1KMuT+klO1LtuIgh9gjWLdqdI7TEG6/2O5+rUx3BfEf/Pps//RAfxPL8tCc+alwqGukg5q5v1e84flzqebQTNepOcsMyxrLKKSld3EgJdy6YisN4P86ZOpp0XgW2GwBczX5vV2MVzieR9IzqWiybxuujNoo+O3ilKkLX3J3K66KzYdLmh5umw+c22kWaReUkirFo28ES3TBAQ8/j8QZgBIvj9jHP+6LLkz+nou1GkJMGq4vv0Aal1peg1o+LOfn05cS7wKyfkOoTHDRP3nDjjde/E7xdFcPSBNPmD4OfJW6tog0R9Ow1YG2Fv7LXiof5N0vZF0UtGbxslLH2wFR8UiXtrElz/D0p4rShB4Fg7EfnfJEPbJyZ8cPTvUYL4fSWRc0UrRaAIrAMBXw7rqN6qRaAIjBBAqiTvnMvwWeI+sjknayo2Um7B8yTF0vSphGN36deTPlF0LPo6bzIuu0BZklK0UBzyP2FKEYcEqwrC6VzZahXNy9t/LE7U2sbpWSKJBHD3Oru0Wt9D+ewYxhmUJWqoNxsaG8lBIBYR1XEbruu1kAYkkLVo3BZWT00GjBPsFff4lkkhzFzdiDnCh7R+MPlCec56vTjpu0blm/P9E2etvVpC82eBRICSnAoL3YDDOIQ/nG+XWtzMniUEywsA+vtC8sfi5Q/54zzxS+XCvc/NjfT9LmnzcCbN+bMkp2I8zwvSxpLs+fWHy7QwF23NIdGFAlOWuIUVWlAEisD+CPhy3D+3OUWgCKyGgE38aankYDViNZAJFi6aoqlwjanL0mETfUFyvxodC1IzTiMe3FCsb/PUAf5x/XEcOeSCekwy7xEdSGWiC4ULzJgLK+wpQHK4Wrk5r5c87kKuO2k6z1IIC5rqaxJuQpYZ/c0qMoOYzXaEODo79eoUsA4hGYmuKMgW6+WKlVKIDM1iiDAhLe5rquwV62dxvXly4PTQhMg7S90dEmdhfWfCMdYDKWOBYlFD5lJlwhI1xs2zM4uHtHE8e89Kow9Ffx9FGL3o8abEueET7JULJIY4Jtgr1niXpPTjvBk8uZiTNZXxfFnPkDZ/UJgTax6COK245zL7PO/J3icwxj4ZTRSBIrAyAiVsK+NzcEs72nZBwIbEdfTkTNjG5oWC4UwOV5CNL0VTYc3gPmKFYwVBqBCSaWEu6tpkE90rNtALJ3XVBWqjTNF+cvrkOPjtUDj3mLcmnY1CAsyV9cQLEPIRTRuvccwJcUB6WGCczZt9+zVdTxwyf14iyIE6n078uVFpytqS5D5is2eR2idzhQTLjr7m6SvTbnw2MMnpW4uvSsR5L2f3uBi5oL19i7h4G1VfMHhh6nlTl7Xq1okjzkiP+4FcIZ/J3kfURbjGmT9Iwn11xi3RvYK4sEp5NozJAoV0yfP2LuzMYR7plGfOLHLImudiTBSdgdTnrOoTKRwTM25X5Np89k5uT8RvonFT7klOA3PknkfWWPq8bGE+7p2+WGynFXNhifPM3zFxpJBF2RvTSU7F+bTZ53laMLroz30eZTVaBIrAagiUsK2GUMuLwP4IIDvIgDNICATywoLCusL6ZePVStqZNhugetxcrETIlHLETPks0bGBspYgIPN07FLVD2XtQcacnfplMpBIh/svnzjxm1jcb/IdDufGYm2x0bNq2URZ81iJnKVy3kq7jah1GG9s8WLdeXo6NY43WhHEJA9YuAHfntbczUgH4oWEIQ6sVj9KGfy56RA762Il4uZzNg2pMSdzcW8QlTSZiri61jDNGF2QmVFyGnVWzT1g3UTOvQ3r/jq/iEy/MbVYWr1d7E3iJCfcqNykyDKLmLW4J6x/SJs661Vtkem/zWnonszJnjw2mTeOIrIPTMiCaI1wRfqTNRWWNX8UwFb/njdvjCq0nyh3jk16nnrm/dSH+c0rb96SEGg3Ow8BH7Cdt6quqAhsLgKsCzb/YfNj+blbhrTBfTwhC4+NiaWEG4yFzebmcDay4k25VJuwcHnjzrmfyQb/sYQ4yO5At66M7TzVK5Jg8UACuNxOkDQrDsJkXPNEahBK1rZPpBy5+2RC1qUEC0W/1ryoAnz8jAOX8VAHUWRtNI9bJJPlKMEBi4P9rE7WqxO/+cWS+IskuKO/mZAVyHqQJUSBZU1994T1C2bm46crENc0mYqfpUACYTvNWOUCw6ekzr2icH9OQuQGqWGRgzdizZLnLGOKJwg+qxvrlsP55sTaKR+ZU2e9qp17A/+1tjUeK+Br0oCFdiBhfnMNeUv2VDxT/mCwVi8pwJ6FTyHijygjwdLzlHUaBiuRunntmlcEdj0CJWy7/hEoAAeAAOvCuBnS4mC9DdIPuLLmIAvqsKrJF7cRI07iFEG6byLDhpfoAYsxZueFlLAkmQsrD9ckq5FBEDVvETp4z12IuLD6IHMOhHO76lPdeapvB+9t3PPKhzxuQWPNfNcMxRsOx3gOncHTPUDSrIGFyDydm+IOhgPXKMvf1dPIwXwkwlm+MWFjIfMGp/uWamsWcxpI+aJGiAuSaFyW2LHb1ZxZOR3sX9R+pXz3lLV0pTrzyswbduMyvwVnnjCUj1AKqfpjbFjXuFw9c8rnqaMDXMaz48yr27wiUARGCGzWl+hoiEaLwK5CAJG5T1aM8NiIE50ryIJzRtx1cyssMRNx4YZzBs0ZJV0jiqxArDusVCwyDrAjnvL8YOx4c9ZmVseb9WzZkEZmnXNzqJ2rbsjf7PA7GYBrzxq8fOG+eBvz+cnnEjYfVqSHJc3CBiOWJQQlWROkx/92oB/pZStrFOvfy9KxFyAS7CMIDXc4qyzCu0/hKgluTG9irlJtTcXII7ezN45XmoffXkOCWTAXdawcqTsYz/yiOTS/CGxbBErYFty6ZheBDSDAwuBnG5CERd04F2WzXlS+zHykycarT3EhV9+QN8yTFUqZ/KGe9EbVDwSzxrHIbLSvtbYfr2FYi3UOcevXl1BdceVCyurGlS2+Gcpl60UJyqo5bwxvCjv3NsxvXp15edyN47XMq7OePGQeiV9pHtbgmYfnor6RYeR91hK8qH7zi0ARGCFQwjYCo9EiUASKQBEoAktGoN0VgaUgUMK2FBjbSREoAkWgCBSBIlAENg+BErbNw7Y9F4HtgUBnWQSKQBEoAoc8AiVsh/wt6gSLQBEoAkWgCBSB3Y7AdiBsu/0edf1FoAgUgSJQBIrALkeghG2XPwBdfhEoAkVg9yDQlRaB7YtACdv2vXedeREoAkWgCBSBIrBLEChh2yU3usvcHgh0lkWgCBSBIlAE5iFQwjYPleYVgSJQBIpAESgCReAQQmCdhO0QmnmnUgSKQBEoAkWgCBSBXYLA/wEAAP//1J/wYwAAAAZJREFUAwAHwAdjIeBjsgAAAABJRU5ErkJggg==>

[image15]: <data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAAYCAYAAAAs7gcTAAAA90lEQVR4AeyRv8tBURyHb2+95Z3epEwmg5SBwcIkZTAazRZ/gM1oshqVzWCjlGLxL7BgMYjBIsmIeD7kdm85wuz2ec73/Hg653bOj/XG95Wdl/XxbXjYJQUZ+ANntOa575xmZQlDGEAX/kH5palCQHKETgPqEIM8hKAISpxmD3PJBTolKMMYWpCFBPggB5o7S64w6IAzEwYL0P9TrJkayVs6J3DmzGAFOrFNPYIlWfURcyYl6RS61lP5gNGEHVzzbOcoxgjsmGQvRhI2YMckBzH0GGuqHZMcxpiCbopyi0n2s9wDV0xyDasPrphkPZIe5iXZJd0HFwAAAP//S+O8AwAAAAZJREFUAwCTGScxgXsPhAAAAABJRU5ErkJggg==>

[image16]: <data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAAYCAYAAAAlBadpAAABP0lEQVR4AezSPUtCURzH8VvQlD3QEARFEEQRFbS1FARNvYS2aAp6AdHS0BtoDhraew9BQUMoDqKCTj6gICgoDg4+fX/ikePxXh3cxPh/Op6Hn95zz1n0pvibkfAVr6CIjqXC5xI0Vqd9wyo8d8/fDG7hA01cYAObWMAlbvGFkBtmzFvh3wGySMOuFJ0ErnHuF95m4ghRlGHXEp1ltNDwC+8zoUf9o9Wj0wzqkE+niCDmF9YjKfTPArvW6LyihkdU3XCIQX1zm/YB732ftEnkcIYwRt72DoMn+MEzXvqeaPdwhzx65f6y2a+OLMMKnbnRoD9Ublj71WVw9zsUMh07rPPVfnS+2p9ZE9ja4V1WHSMO93wZGi2FdQW1vxjT67hBAfcYWwr/skK/qrtr6JLofjMVXAoHz06YmYcnvCB3ugsAAP//VgiSZQAAAAZJREFUAwD3zjkxabhzugAAAABJRU5ErkJggg==>

[image17]: <data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADkAAAAYCAYAAABA6FUWAAAC/ElEQVR4AeSWW4hNURjHD2bcKSlSwsQLxYPLC1JIyAOKhCRKXpQ7peQSeRBFLiFeKBQSipBbKdcXCo0XIdfkkluM+P3OmGkz7T377L2nzumc/r/zrb3PWt9Z3/7W+vZqniuDT9kF2YGktoA0asZg/WhpFoeCmVzBlLpAGrVj8ErQYopDwSAbm1EbOqyDVVAJJaNCguxHVMtgMVRByaiQIO8R1SKYB48hjdz77t00PmKPLSTIn3jdByfhN6RRSwavhTMwAJq0UMUN0j04mMlMgl6QdlLf8LEUZsMsuAajwAxjUsv5dsWLVDYWpMFMo/NDGAGt4RDsAh1VYA2+FTaJ3jFoOUyAoXAdJkLSYDsydju8gD2wGqqigjTAJXTaATNgKxwBJzUTOxp6gNn4hU2jTwzeAPp0pdynPRes6JhY6kmvO9AWnJerbgHt6qggB9JhPeyEW1CnJzTewxQYBz79GmwW+oKTbTAI1F2+4gTrqtpMXwPciHU7YGoVFaQZskBcrO1a//2d1hvwifsgztLOWk7yIE43ge/lsdgo9eFHV4GHmau0n/5lOjYXFmR7frTqVWMfQVBWWZ/4SG4ehY+QpVyiZu82Ts1Qf6wVHRMqM2i9cA+6VOs47IiwIH1FuATf0snMYRroFHeuQFbyKLgQZ5fhKwyBA2BWMZFyrqF1ISxIM3UBt5Zg/5xmXlYvl9BwrjqB156ELFJcJlJnRrmfzmEtOMOwFjhXDM1YcsW5TN3LZt9Bzik/97Ag7WRVvUHjPOyFE3AcdsNk6AtOZjw2iboxyP84hhVfUZdoh2aE38Jktj2JeYqyhjhf372e0CqigjSbc/Dqk12D9TUyBvsATkNvmApbwOWNia3u9PTE42Q8BNzkulAfDAkq94orH7jvXPemfq20NVFBMiavz3y/hP/3pvc/cD+JnjNoPngeThscbv6R83rNnfrlHidI+pe2yi5ITzI/UubMUv4MH1pMcSiYyf1MyQMzJrHctx6MtYmdZD0wGGTWvovG3x8AAAD//zFEFPgAAAAGSURBVAMA9xiEMbHX6s0AAAAASUVORK5CYII=>

[image18]: <data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAmwAAAA2CAYAAAB6H8WdAAAJq0lEQVR4AeydZ4g0xRqF9wbuNWPOWQygomLEgAExggkDiqL+MMcfBkTMmDGimFEQsyJmRQQDYg6Yc845K+bnqLOs+/XOzqwzs1M9z/KefWuqe7qrnobhUF3d9e8h/yQgAQlIQAISkIAE+pqAhq2vL4+Nk4AEJFAKAdspAQl0k4CGrZt0PbYEJCABCUhAAhLoAAENWwcgeogyCNhKCUhAAhKQQKkENGylXjnbLQEJSEACEpDAZBCYlHNq2CYFuyeVgAQkIAEJSEACrRPQsLXOyj0lIAEJlEHAVkpAArUjoGGr3SW1QxKQgAQkIAEJ1I2Ahq1uV7SM/thKCUhAAhKQgATaIKBhawOWu0pAAhKQgAQk0E8EBqctGrbBudb2VAISkIAEJCCBQglo2Aq9cDZbAgNKYG76fRDaC22BTkBroF1QX4aNkoAEJNAJAhq2TlD0GBKQQK8IfMmJvkN3oG/Rs+gl9DMyJCABCdSWgIattpe21Y65nwSKIhCTNh0tfg2thx5FG6CYuGXJhgQkIIFaEtCw1fKy2ikJ1JrArfTuN3QVegXdjZKfJhsSkMBkEfC8XSWgYesqXg8uAQl0gcBTHDOG7WHyT+hN9Bj6BRkSkIAEaklAw1bLy2qnJCCBCgJWSUACEiiWgIat2EtnwyUgAQlIQAISGBQCGrZ+utK2RQISGE0gr+3Irc532XDOGMpctmvYlidH3ybndukhZEMCEpBAbQho2GpzKe2IBCaNwIyc+T+oG3EsB30DzYVuRHtUaBvqtkLro/nQ7mhr5O8bEIzBJGCv60fAH7T6XVN7JIFeEohZe5ATxlCROh5fc8RN0YfoArQQGi/OY4cD0drIkIAEJFALAhq2WlxGOyGBSSOwMGd+FX2A2oi2dn2GvY9B86Cz0LRovLiLHR5AhgQkIIFaENCw1eIy2gkJTBqBpTnz4ajbKw2cyzmuRBuhQ9F4kXlseZnuePu5XQISkEARBDRsY1wmqyUggSkIzEnNLCjxL/79H+VltU+Sux2/coJ90PNoT7Qq+qeReXfLcJDZ0ERifr40B2rEVI2CWQISkECnCWjYOk3U40mgngRWo1s7oKwykKWhFqecOWVPkPMUJ6kyZqV24zG0IfWZA0dqKT5hrzx0kNGz6yjnAQPShGJFvpVRuxiuiyg3jCjFliLLYKX9F/61dwxkRgBjZP+qMkngDwL+k0BHCGjYOoLRg0ig9gRmpod5bcY75NxqXIGchw1iniiOGTFZt7C1SrdR/wVqJ+5h56NQRvuOI0/EIP2X752OjkCZ63Y5+TMUE5pbvBSH43+UYlLXJDci54xZy3qmKac+Dzg8TiEPX7xITvtITWMBtmaUjmRIQAISaE5Aw9acj1slUH8CrfXwJnbLSNkV5JiUzcmPoJiOjFDNTrkqYo5mYkOVMrqW7WxuKzKqdTvfeBlN5Psr872v0Psoo4MZGYvxjBGNIaV6OFIfs5mnVBuVqcv74TajIq8aIQ2tzr+Yv/fI16KP0ciYhg8xhKThyPk+Hf5kQQISkEATAhq2JnDcJAEJ/I3AUnx6AeVpzeXIb6GYnpixHylXRcOoxKxUqZUnPkcfdwkqPkIno6wlSmor0ta0PcYrX0y/MmJ4GB8yV440HDn+2XxKv0nDEdO6KJ8eRblFPAP5OZSc0bp1KJ+GMk+ONJT9M+cv5Shz5/KwRurzWUlAAhJoSqAEw9a0A26UgAR6RiDzxk7ibLlFmNd4fE45t/5ianIr8QA+j46MZOXWaZUeYucvUTuRkbzMY9uJL32PJhIZGcwDAhktvJMDxIB+Q47xipmjOG7E2N3AXmegmLa83Dc8YvyWp+4+FAOYp1rPp5zXkRxJTnlnckbgpifnOCRDAhKQQHMCGrbmfNwqAQn8SWAl0hooKwhkLtuZlGNuYtSSM2IVU0Z11yK3UI/m6HmtR2N0jI8Tihi+GKesjpD+ZCQsudU5ZYtx1rRnPfLd6HqU39NtyRejGNswu5nyrmhvFMOWcrYvwufMgYvhpWj0hoBnkUC5BPIDU27rbbkEJNArAplMnwcPNuGEmc+V9TspDuXFuZlTtiUf8soNUlciT3FmxOoUjp7RPVLTmJutmXNHqowYvh/Y0hjhynyy/B62OqcsrwKJ0u+MEmYuW0xf1jzNCN6bHDu3bXMeilNERvSy7mlG2qbYaIUEJCCB0QTyAzW6zs8SkMAkEejj0+b23460L09UZvSoYUQyB+1h6mPcViF3KzKqdioHz4MGpKaRJzvzUEDa1XTHERtfp5yRrzzVSnHcuJ899keXooNRRhlzazijaHnyNcYyKzSw6Y/4lv9PoUbkdSg5X5beatSZJSABCYxJQMM2Jho3SEACLRCIectcsn3ZN3PbSB2NPAV6PEeMwckoWB5wqFLei5b3xF3Gvi+h3NpsdbSM3Q0JSEAC/U2gTcPW352xdRKQQM8JNG4p5vUYjVG3TjZiXQ62BcrIVSb3j6U8EJF9MsqXtsS4NdrG1w0JSEACZRPQsJV9/Wy9BOpOIO9by+tAMkm/HWUVhrqzKbt/tl4CEmiLgIatLVzuLAEJSEACEpCABHpPQMPWe+aesQwCtlICEpCABCTQNwQ0bH1zKWyIBCQwgkBug2YFghFVFiUgAQmUSKAzbdawdYajR5GABDpLIE+e5p1mnT2qR5OABCRQKAENW6EXzmZLoMYEss5mXpKbp05XpJ9rjdIcfK6KvLg2KzHsx8bt0YloO5Rj5fUgFI0qAtZJQAL9T0DD1v/XyBZKYNAI5CW0WWczKxFk1YAs/TRSWWkh63WeB5iszdnQknzO/qShW/gX43ctOWbN3zpAGBKQQLkE/BEr99oNUMvt6oARiMHKS3gXpN+zoyyLNVJTU/cY2g3tOkJZSSBLWGU1hHmpvxdlNC5Laq1G2ZCABCRQLAENW7GXzoZLoLYEsqJBfpuyTFTW43yfno5U5rdRVRlZQ/RptuT26NXkLBf1Brmb65xyeEMCEiiCQMGNzI9iwc236RKQQA0JvEqfLkExbKS24kb2fhs9iV5BH6Cs65lM0ZCABCRQJgENW5nXzVZLQAL1JGCvJCABCVQS0LBVYrFSAhKQgAQkIAEJ9A8BDVv/XIsyWmIrJSABCUhAAhLoOQENW8+Re0IJSEACEpCABCTQHgENW3u83FsCEpCABCQgAQn0nICGrefIPaEEJFAGAVspAQlIoH8IaNj651rYEglIQAISkIAEJFBJQMNWiaWMSlspAQlIQAISkMBgENCwDcZ1tpcSkIAEJCCBsQhYXwABDVsBF8kmSkACEpCABCQw2AR+BwAA//8Iv/F6AAAABklEQVQDAHg1Lnxo/fBdAAAAAElFTkSuQmCC>

[image19]: <data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAYCAYAAADKx8xXAAABTklEQVR4AezSvyuuURwA8Lfbvcu9w71dA6EQJgYlE0lkUYpF2ZRJyWQhNuUfMMhgsjFYsBgMklUohcnEYPBjEOLzPXrz5vV7Mnj7fp7vOec53+ec5zzvj8wnf9+Frxzc1zicQjvspJlfPBu5Wy0yY4Fp/tDCEn/Ji2xhmTurnNLDCh3UU0xeROFPo+P8Y5JrLpmhnz0iYuUBjciZKKzW6WaTIyJuXGZZ5I6IcpcabkmFVRr/2SAKpGdjy+ggF6TC7OT9GHjit368Spe8TB0pYqs7WgcUkButOnM0cMU68QApk1aM9xrSm2CeOJQ1uZ0+DtmliTh56aEwGnH8FRrxDmNyGyOccUIJ8WfYllPEVlPDJT7DsRwT08lpZ6NXI1ZrlGtJW438lnhoqUmVxLbfXTisYJQp0nfN3aqxFyMmn7sbWXo8nNT5yOW9K+Y98x4AAP//KOgZ1wAAAAZJREFUAwBTTjgxU5/XKQAAAABJRU5ErkJggg==>

[image20]: <data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAAYCAYAAAD3Va0xAAABhElEQVR4AeyTSytFURTH95XIm5SJkiExIBJDJSkTjyHlU/gmZkaG5DFS8siQkIEMzMQEyTOPAcXvvzv7dvbeZ3S7s3tv/99ee691z7rrrL1uhSnSp4QSjdKyR/hL2MHWgFMjm11wcdlNznVhjw5xtsEy/IAS92Gd3tmMwyxsQC3MwGeYCJ9pNsZUwyJUwRzkIK1ODlvwDVZZiTqIPMMaXMEU6EGMVSVrN1xCXlmJeokqwR12FdphEpxUsSq9dQ7ZrEQDBM5AWmd5hXloAqmLRb16weYVJmoh0go3IKky3dwQhxGQeliOwVOYyPXnKfnWL3YFpAUWjcIg1usPZxMmcv3RfCgujlhOYAJUVdQf/F4iXfEwznNI643DEqjJsvfsvf5w9hLpi5rcawUC9jirX7r2C/aR0q/WT7QBviDUAw6NguYrrJiQsRWNsfuAA5gGlZ2eG1xWGoVTdno1jC9VtI+rHnIJ+ntssw+lm1LD9UNhzFYUOQtxqKJCnoueKSeKWhI5/gEAAP//zwxoSAAAAAZJREFUAwCgbEMxME5c0wAAAABJRU5ErkJggg==>

[image21]: <data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADkAAAAYCAYAAABA6FUWAAAEh0lEQVR4AeSYV4hVVxSGz6T3SgpppJBCCglJIIUkJKQ3FcRHRRT0RVAsL3afRBEUBR/UBxV8sINib4gFsWNDsFdU7L3r952ZvT3nzr135g46Ig7/f9ba7Zy99l5r7X3ngeQ++LuvjXyKDX4M3it4lok+DIui2E5+Qc9h8FF4r+BDJjoaaiwij0Ij36B5MBwET8E7jb/5wI168Bx9voKlsJKGWXAArLWjWSOr6NAVLoabYWPAifndsXzsKvwRWg58iHJ76IKfR5bDZBpfh//DHLJGfkLLX3ASbEw8z8c+hnvhNpjFNQpT4Dp4EpbDBRrHQTcq57ZZI/+lww64HTYm3uJjxpSGHEMX7uSTKjV0Ac7U6OWEbvsyHT6DEcFIM+lP1C6DF2Ep2O9nGnWJV5C3A5/ykqfhcqjLIpKPePSDGmvdQnTjElEWh2ndDbUFUY1gpC7jxzZWV9d6GszdqF0BP4D2X4LsAp3I48iv4YOwUvzCAA1xF1AT39EKRdc1KemmEymrI8rChThAD0PPeaEmSTDyNUru0glkITRwKJVtYFM4ApooeiO7Q19o5jOejSGq6g0X63N6m2AmIM9CDe6IXAsbgi0MMgFFdw9GUp9c4mHwInLQNdtRo/vsQQa40i7Mn1Q0gQtgpXiXASYdM6Ox6SXEsq67i7aGQgPdnHR81si0ouChEW2pOwKDO6GmcNdPo+mmXhxWoVcKY+8JBjnWHURNsZ5nSEKoFeMFRjwCU9RlpO5krOo6B9MRtx7u+mWKv0FdODtJqupEFT0c6zgTHsUUZvc+aPWJQboVxT5qjU9EEmPSXTEuTL9pQ83jOtJJHEWWyrpepwovD7rdi4ypgqXwHA0uoMeDrk8xxRWecYLovsOQmInulROReDMzRzhny1k+Q8E5x0UKO6nbaahxQZ8IXWYRJY8LMyhqCj/i/fZNSi6MMfA+utA4d8ad/9aKEgzxmD0fi3XVpT1iltLYDArP9O9RNAYR4YK8TcnkExcqGKkxxpyZkj4RvqQnJdP6XKRuqeyP3gl2hr/CGTAcwCYw07iB/wP1hdBFXYDVNBiPzZHG/GyksYTIIczNd82nRUM8B118ijnoHS62/WJDMNKtnUOtK28cokYcQvsdmmV7IV3Flsj9cAjU5f5Dev1CJB4D/6D8AY1bRA5OwCPLyQZqnEfQ8VzP6oIL8BKqi2ZY6Cl63CbqMkjVsOu58z4YaY95PEwk3yCLwUPZG4Uxk223XsOydepf8lgDbwdcFI31W+/wQudgLKNGuGAurndvbz2xIWukbjGQFo+MbPxRVTE84L0ZeRRUPLjIgA3U6YrOzYvJTsrmEETEe2jfwVFQz0RUI2ukNdN5GJsdkK4MokHQnfoyspi7Ul0RnIfJzWw6lZEeD9OQWejKPagYDrMXFopJPELSAg9XwDhTlnJbutUJF8uYrbNjPToY82Po9yr0x4Eh4+9QihGt0cbDkBdQb6FwJ23R3/3PgJdxy3ebW5mAv/hbID23zerOkWLESDSzM6I2ihlZu9fdrdEgd9KjTHet9EdAchMAAP//POdtRwAAAAZJREFUAwD0oNkxZzrJkgAAAABJRU5ErkJggg==>

[image22]: <data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAAYCAYAAAAlBadpAAABaklEQVR4AeSTPUsDQRCG169C1EoEBRUECz8QOwttrPwFggiihY3WVoofhY2VqL/AwkpEtBDBQvELQRvtLFQUG5WAWBkSQvK8FzbsHXdJIE0gYZ6dzMy9O5vZXLUp4VO+4kZ+1SiMQy/UgKyBpT3q2H0U7+AL5qETFuEU+uEAeoLiOpLL8AjH0AITsAnTsA7adAD/7Iol3CG5BpOwAf/g2gPBNTxBzBXPkpiDVTiEMIuTjMEtxK24m0CiF/wepCHKkhTuwVjxFEEb7MMn5LMFipfgie11qNuFkgX4o67unriJoAu+4Q2KNntsCRIswemS8pkGOmwzEmuCPzaRxzdTGwINFWe8Y//y7Qo6YBDCrIrkDJxArpE6Exv9ObTjEkEruFZPsAIaqO/+rfiD4hjUgoa2i1enbfwZ3MAWaANc1qxY0TvLCOilOMLrSnQivVXnxD4hsXHFivWANpFYvJJMQagFxaEPRSUrUZwBAAD//5uC8N4AAAAGSURBVAMAxL9EMUSEISkAAAAASUVORK5CYII=>

[image23]: <data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAAYCAYAAABKtPtEAAAD0ElEQVR4AeyXWaiNURTHjzFjSMYQCRkeREhmiiiRB28yFYpkCOWdeBFSvCgvkhR5kMgQGTKkZIiUqQgZIjPh9zv3ns937zfcM7jnKG7//1l7Xmuvvfba322Y+cf//jvgLw6AltjWANYr0iJA5YvQPgmWG51QuBE2g0n4I/alOWAgmjfDbbAjzAerGPQzDz5iTBeYhAl03IWfYBKKsS+yVpID9O4CRreBKpqFzAdbGNQanoHPYG/oWjm2oL4BvoffYBwa0zgKnoZJcL1C7XOOuvewaBBZSQ4YwKA+cA70RFXWnnI+MFr6MfAWfA7D8ET30nAbfoZxUK9OuBfXWd1WjH3aP5P572CgO84Bemohg/bDg/A4HAanwnzg5jsz8BL8AEUjfjx9RBaP+TUKEBEY/kbQ90hPVUOx9vViutQuilWIc4Bh25Puo9AT24o0CpYhvRKIVIyu7j1XLRVuarEF6JrHkHFoTuMQWMNI6mEUal9bJptvxiN16hOkUeqhZGo7QO8a9p78KwYKN3KWwghYVxT4dDnO+28SY0rGTRlRN6zAh9CoQkQwmJbX0DGICAq1rykreH19UdZS/gLnwtVQx0Qc4Mmb9Dx9xmRhqG6nZBSsQKZFgc+X8/WwTvvK+I9wDLwD68JEBpyC6kJEUKh96jcxr2GlF3AfnA/XwewB144AT/9ErhOZw0kKl+FwmPZdMIh+7/8mZDfoCUxGXoQvYRra0dkXXoVJKNY+776MXK2wAxxg+Br+tQ14S4O5wBBcTrkVjIPzbQ8r8jQv0BhkXspxGErjA5jkqFLsM6+Ye66xfg2EHTCbHkPfUKEYgX1ubCw9uURHMYBO8f32/t8MWjMZc8jOUD2uqGONlKTk6Jxi7XNtbb7PItqG+I2cA7rTNBIegEkwCnbQ6YLmApMb1QDee5/A2u+/Jy+DgTGFrrR1gLlESbEGSrHP99/kep0V30Dr5gUPLEiCM+iYBq9A3+gkOpEhGU9rnIUQc/ffKMm9/6Hu1KJJUt0m3LiBpdinY81Lflk2YHHziFGZ1WUEmLmX0tEE6uk0uhjDMkaBc4yCJTR4bQ4jxXp+rO9GmgQRqfCrTwf4asQNLNU+n9QjLLwSGuE+hYcoZ6ED/FztT81NFcLpzDGx7EIa/uG51n37fYboTkUPen/ApGeyVPu00bd/CjrmQfORiZliJrgC2UqFfnxWz6PbrzREvcAN++5nwz6swQgI18td9gr5dJo3yq07q6/SDvC7/imWeE8R5UelHeDz51emIVr+3aOx0g7wnyL/9cWUyqDSDqjMrkNafwEAAP//hB4HgwAAAAZJREFUAwAFkdwxAT7DsgAAAABJRU5ErkJggg==>

[image24]: <data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACsAAAAXCAYAAACS5bYWAAACs0lEQVR4AeyWS4jNURzHZ7zCKK+UR7JgQWw8V6LkuUCxEWFBWJGQV5Q3ZSFioaQUsvBINrJggyTlLXnkEUrMaqZpZprH5/NvTt25d+7539s0t7k1t+/n/s7/nPO/5/v/ncf/9qooo0+P2a6arLLN7CgycgAuwiGYAKXWAAZcDXo4S5wPvSFRyOwsrq7AIzgPM+AT7IBKKIUGM8hVqIJT8B/uwz2wrUKzPs0+Kq7DE3gF6+A5HIZpUAqtZZAauAFfwLGPExfDFkjMDqEwFc7AFFA+1R0KA2EuxDSMRiF0KKdxNC1pMzSTPhreSFQtfN2FOlgAVWb2HwWNPSX+haCmtkLftpgvDKfhEoyDbHnvfirXQJpu0+E9vIGgZgqa7kOs1GwjhW2wCP6AstEntfMzKyK4tt2QbopMwxrdy31m5jTRQQl5ZcIm0/oAgiZScHZfEGs0S8zRdGqWgBl7TEzTSzrshmC4WKPcmiM31WZqTYYnQ7JmuW4nOx2j5hZsBzNPSFUwfJmeF6DQjNI1R65vjbrWl9P6HXLMmhGPjdc0boJaKEbv6PwW5sFNSJt6unSoFdQuBc/ZD8REmctAo+eo9Sl2Ec3MJOJCKETe71Hzk87LwN/KXMNUFaSV9PJEMKPfKA8CN2j/YNa0b6XyI5yEcBLMoWxnQlTBqKeJm8kM7+QOl0Mxhn05mdVV3FsNaixf1tdrVqPrqTgCvrHM7A/KcoKoAUJeafQorb9Bo2Hqnb5iDDuL1/gNz1SPL8cXN7gvixbNjqSDR49vsjGUfZJAPdeaIOTVbFp+gS+VYJTLRBr2WNzAVT+IaQ+N42EEhPGNQ7n2/E02mGerU2WGs/HPzVc6x/SQRo+WbKNUJ/rM90FogJic3ezxw7X/GRKzsR/oVm0ug25lKGamx2wsO51pK6vMtgIAAP//rdDgJgAAAAZJREFUAwBN0oEv2FiegwAAAABJRU5ErkJggg==>
```

# File: docs\dev_docs\investigations\slope_detection_feasibility.md
```markdown
### Is Slope Detection Feasible?
**Yes.** In fact, it is arguably the most sophisticated and physically accurate way to estimate grip loss when direct tire data is unavailable.

In real-world automotive engineering, this concept is known as **$\mu$-estimation** (friction estimation). Modern ABS and Traction Control systems often use the relationship between steering angle (input) and vehicle yaw/acceleration (output) to determine if the tires are saturating, exactly because they cannot put sensors inside the tire rubber to measure grip directly.

By implementing this in `lmuFFB`, you are essentially building a "Virtual Sensor."

### Is it the "Best" We Can Do?
Given the specific constraint—**that the game hides `mTireLoad`, `mLateralForce`, and `mGripFract` for DLC cars**—Slope Detection is likely the **best possible solution**.

Here is the comparison against the alternatives:

#### 1. The "Static Threshold" Approach (The Old Standard)
*   **How it works:** You set a fixed value (e.g., "Optimal Slip Angle = 0.12 rad"). If the calculated slip exceeds this, cut the FFB.
*   **Why Slope Detection is better:**
    *   **Rain/Weather:** In rain, the optimal slip angle drops significantly. A static threshold set for dry weather will feel completely numb (no understeer cue) until you are already sliding off the track. Slope detection sees that G-force has stopped building and cuts FFB *automatically*, regardless of the surface.
    *   **Car Differences:** A Formula car has a very sharp peak; a GT3 car has a broad peak. Slope detection adapts to the curve shape naturally.

#### 2. The "Kinematic Model" Approach
*   **How it works:** You try to calculate what the car *should* be doing based on wheelbase, mass, and steering angle, and compare it to reality.
*   **Why Slope Detection is better:**
    *   **Missing Data:** To build a good kinematic model, you need the car's wheelbase, center of gravity height, and roll stiffness. If the game hides tire data, it likely hides (or obfuscates) these geometry parameters too. Guessing them introduces massive errors.
    *   Slope detection is "Model-Free." It doesn't care how long the car is; it only cares that *Steering More* $\neq$ *Turning More*.

### The "Achilles' Heel" of Slope Detection
While it is the best *theoretical* approach, it is the hardest to implement *practically* because of two fundamental problems (which we addressed in the Implementation Plan):

1.  **The "Steady State" Blind Spot:**
    *   Slope is a derivative ($\frac{dG}{dt} / \frac{d\alpha}{dt}$).
    *   In a long, constant-radius corner (like Parabolica at Monza), you hold the wheel still.
    *   $\frac{d\alpha}{dt}$ becomes 0.
    *   Mathematically, the slope becomes undefined (0/0) or zero.
    *   **Result:** Without the "Hold/Decay" logic we just designed, the FFB would suddenly feel heavy (full grip) in the middle of a slide because you stopped moving your hands.

2.  **Noise Sensitivity:**
    *   Differentiating a signal amplifies noise. If the telemetry jitters by 1%, the derivative might jitter by 50%.
    *   This requires the robust smoothing and "Projected Slope" math we discussed.

### Conclusion
You are on the right path. Since you cannot access the "Truth" (the game's internal grip value), you are observing the "Consequence" (the car's trajectory vs. steering input).

If you can successfully tune the **Smoothing** (to kill noise) and the **Hold Timer** (to handle steady corners), this system will provide a better, more dynamic driving experience than any static setting ever could. It is the "Holy Grail" of generic FFB.

## Challenges

Slope detection is notoriously difficult to implement in real-time control systems because you are trying to perform **differentiation on a noisy signal**. In engineering terms, this is often considered a "forbidden operation" unless strictly controlled, because differentiation amplifies high-frequency noise.

Here is a breakdown of why it is so hard, why the previous implementations were indeed too "naive" (mathematically speaking), and why the specific nature of the game engine matters.

### 1. The "0 divided by 0" Paradox (The Steady-State Problem)
This is the single biggest reason previous revisions failed.

*   **The Naive Assumption:** "If the car is understeering, the slope ($\frac{dG}{d\alpha}$) will be near zero."
*   **The Reality:**
    1.  You enter a corner. You turn the wheel. $\alpha$ changes, $G$ changes. You calculate a slope. It works.
    2.  **You reach the apex and hold the wheel steady.**
    3.  Now, the change in steering ($\Delta \alpha$) is **zero**.
    4.  The change in G-force ($\Delta G$) is **zero**.
    5.  Your formula tries to calculate $\frac{0}{0}$.
    6.  Previous codes handled this by saying "If input is zero, assume grip is fine."
    7.  **Result:** The moment you stop turning the wheel—even if you are plowing off the track in massive understeer—the FFB suddenly returns to full strength because the *rate of change* stopped.

**Why it failed:** The previous code treated slope as an **instantaneous property**. It lacked **Object Permanence** (Memory). It didn't "remember" that you entered the steady state via a slide. The "Hold Timer" in the new plan fixes this.

### 2. The "Noise Amplification" Trap
*   **The Naive Assumption:** The telemetry data represents the smooth motion of the car.
*   **The Reality:** The rFactor 2 / LMU physics engine runs at 400Hz and simulates tire carcass vibration, suspension jitter, and road texture.
*   **The Math:**
    *   Signal: $S(t)$
    *   Noise: $N(t)$ (High frequency)
    *   Derivative: $\frac{d}{dt}(S + N) = \frac{dS}{dt} + \frac{dN}{dt}$
    *   Because the noise changes very fast, $\frac{dN}{dt}$ is **huge**.
*   **Result:** A tiny bump in the road (1mm suspension travel) creates a massive spike in the derivative calculation, which the code interprets as a sudden change in grip. This causes the "Singularities" (values of +/- 20.0) seen in your McLaren report.

**Why it failed:** Previous revisions used Savitzky-Golay filters *after* the noise was already in the buffer. The new plan adds **Pre-Smoothing** (Low Pass Filter) to kill the noise *before* it gets differentiated.

### 3. The "Projected Slope" vs. "Division"
*   **The Naive Assumption:** Slope = $\frac{Rise}{Run}$ ($\frac{dG}{d\alpha}$).
*   **The Reality:** When driving straight or making micro-corrections, the "Run" ($d\alpha$) is tiny (e.g., 0.0001).
*   **The Math:** Dividing by 0.0001 multiplies the numerator by 10,000.
*   **Result:** Even microscopic noise in Lateral G gets multiplied by 10,000, causing the FFB to bang wildly between min and max values.

**Why it failed:** Division is mathematically unstable for this application. The new plan uses **Projected Slope** (Least Squares approach):
$$Slope = \frac{dG \cdot d\alpha}{d\alpha^2 + \epsilon}$$
This formula mathematically *cannot* explode, even if inputs are zero.

### 4. Specifics of the Game Engine (LMU / rFactor 2)
You asked if we need more info on the game behavior. The rFactor 2 physics engine (which LMU uses) is unique:
*   **Tire Relaxation Length:** When you turn the wheel, the tire doesn't generate force instantly. The rubber has to flex first. This creates a **Phase Lag** between Slip Angle and Lateral G.
*   **The Consequence:** If you simply compare $\alpha(t)$ with $G(t)$, they are out of sync. $G$ might still be rising while $\alpha$ has stopped.
*   **Impact on Code:** This phase lag looks like "Negative Slope" (instability) to a naive algorithm. The **Savitzky-Golay window** (which you already have) helps align these, but the **Hold Timer** is the ultimate fix because it waits for the physics to settle.

### Summary
The previous implementations weren't "wrong," they were just **idealized**. They assumed a clean mathematical world.

The revisions failed because they tried to patch the issues (adding thresholds, clamps) rather than changing the fundamental mathematical approach.
1.  **Division** must be replaced by **Projection**.
2.  **Instantaneous Logic** must be replaced by **Stateful Logic (Memory)**.

The proposed plan implements exactly these two paradigm shifts.
```

# File: src\AsyncLogger.h
```cpp
#ifndef ASYNCLOGGER_H
#define ASYNCLOGGER_H

#include <vector>
#include <string>
#include <fstream>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <atomic>
#include <chrono>
#include <iomanip>
#include <sstream>
#include <algorithm> // For std::max
#include <filesystem>

// Forward declaration
struct TelemInfoV01;
class FFBEngine;

// Log frame structure - captures one physics tick
struct LogFrame {
    double timestamp;
    double delta_time;
    
    // Driver Inputs
    float steering;
    float throttle;
    float brake;
    
    // Vehicle State
    float speed;             // m/s
    float lat_accel;         // m/s²
    float long_accel;        // m/s²
    float yaw_rate;          // rad/s
    
    // Front Axle - Raw Telemetry
    float slip_angle_fl;
    float slip_angle_fr;
    float slip_ratio_fl;
    float slip_ratio_fr;
    float grip_fl;
    float grip_fr;
    float load_fl;
    float load_fr;
    
    // Front Axle - Calculated
    float calc_slip_angle_front;
    float calc_grip_front;
    
    // Slope Detection Specific
    float dG_dt;             // Derivative of lateral G
    float dAlpha_dt;         // Derivative of slip angle
    float slope_current;     // dG/dAlpha ratio
    float slope_raw_unclamped; // NEW v0.7.38
    float slope_numerator;     // NEW v0.7.38
    float slope_denominator;   // NEW v0.7.38
    float hold_timer;          // NEW v0.7.38
    float input_slip_smoothed; // NEW v0.7.38
    float slope_smoothed;    // Smoothed grip output
    float confidence;        // Confidence factor (v0.7.3)
    float surface_type_fl;   // NEW v0.7.39
    float surface_type_fr;   // NEW v0.7.39
    float slope_torque;      // NEW v0.7.40
    float slew_limited_g;    // NEW v0.7.40
    
    // Rear Axle
    float calc_grip_rear;
    float grip_delta;        // Front - Rear
    
    // FFB Output
    float ffb_total;         // Normalized output
    float ffb_base;          // Base steering shaft force
    float ffb_sop;           // Seat of Pants force
    float ffb_grip_factor;   // Applied grip modulation
    float speed_gate;        // Speed gate factor
    float load_peak_ref;     // NEW: Dynamic normalization reference
    bool clipping;           // Output clipping flag
    
    // User Markers
    bool marker;             // User-triggered marker
};

// Session metadata for header
struct SessionInfo {
    std::string driver_name;
    std::string vehicle_name;
    std::string track_name;
    std::string app_version;
    
    // Key settings snapshot
    float gain;
    float understeer_effect;
    float sop_effect;
    bool slope_enabled;
    float slope_sensitivity;
    float slope_threshold;
    float slope_alpha_threshold;
    float slope_decay_rate;
};

class AsyncLogger {
public:
    static AsyncLogger& Get() {
        static AsyncLogger instance;
        return instance;
    }

    // Start logging - called from GUI
    void Start(const SessionInfo& info, const std::string& base_path = "") {
        std::lock_guard<std::mutex> lock(m_mutex);
        if (m_running) return;

        m_buffer_active.reserve(BUFFER_THRESHOLD * 2);
        m_buffer_writing.reserve(BUFFER_THRESHOLD * 2);
        m_frame_count = 0;
        m_pending_marker = false;
        m_decimation_counter = 0;

        // Generate filename
        auto now = std::chrono::system_clock::now();
        auto in_time_t = std::chrono::system_clock::to_time_t(now);
        
        // Use localtime_s for thread safety (MSVC)
        std::tm time_info;
        #ifdef _WIN32
            localtime_s(&time_info, &in_time_t);
        #else
            localtime_r(&in_time_t, &time_info);
        #endif
        
        std::stringstream ss;
        ss << std::put_time(&time_info, "%Y-%m-%d_%H-%M-%S");
        std::string timestamp_str = ss.str();
        
        std::string car = SanitizeFilename(info.vehicle_name);
        std::string track = SanitizeFilename(info.track_name);
        
        std::string path_prefix = base_path;
        if (!path_prefix.empty()) {
            // Ensure directory exists
            try {
                std::filesystem::create_directories(path_prefix);
            } catch (...) {
                // Ignore, let file open fail if necessary
            }
            
            if (path_prefix.back() != '/' && path_prefix.back() != '\\') {
                 path_prefix += "/";
            }
        }

        m_filename = path_prefix + "lmuffb_log_" + timestamp_str + "_" + car + "_" + track + ".csv";

        // Open file
        m_file.open(m_filename);
        if (m_file.is_open()) {
            WriteHeader(info);
            m_running = true;
            m_worker = std::thread(&AsyncLogger::WorkerThread, this);
        }
    }
    
    // Stop logging and flush
    void Stop() {
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (!m_running) return;
            m_running = false;
        }
        m_cv.notify_one();
        if (m_worker.joinable()) {
            m_worker.join();
        }
        if (m_file.is_open()) {
            m_file.close();
        }
        m_buffer_active.clear();
        m_buffer_writing.clear();
    }
    
    // Log a frame - called from FFB thread (must be fast!)
    void Log(const LogFrame& frame) {
        if (!m_running) return;
        
        // Decimation: 400Hz -> 100Hz
        if (++m_decimation_counter < DECIMATION_FACTOR && !frame.marker && !m_pending_marker) {
            return;
        }
        m_decimation_counter = 0;

        LogFrame f = frame;
        if (m_pending_marker) {
            f.marker = true;
            m_pending_marker = false;
        }

        bool should_notify = false;
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (!m_running) return; 
            m_buffer_active.push_back(f);
            should_notify = (m_buffer_active.size() >= BUFFER_THRESHOLD);
        }
        
        m_frame_count++;
        
        if (should_notify) {
             m_cv.notify_one();
        }
    }
    
    // Trigger a user marker
    void SetMarker() { m_pending_marker = true; }
    
    // Status getters
    bool IsLogging() const { return m_running; }
    size_t GetFrameCount() const { return m_frame_count; }
    std::string GetFilename() const { return m_filename; }
    size_t GetFileSizeBytes() const { return m_file_size_bytes; }

private:
    AsyncLogger() : m_running(false), m_pending_marker(false), m_frame_count(0), m_decimation_counter(0), 
                    m_file_size_bytes(0), m_last_flush_time(std::chrono::steady_clock::now()) {}
    ~AsyncLogger() { Stop(); }
    
    // No copy
    AsyncLogger(const AsyncLogger&) = delete;
    AsyncLogger& operator=(const AsyncLogger&) = delete;
    
    void WorkerThread() {
        while (true) {
            std::unique_lock<std::mutex> lock(m_mutex);
            m_cv.wait(lock, [this] { return !m_running || !m_buffer_active.empty(); });
            
            // Swap buffers
            if (!m_buffer_active.empty()) {
                std::swap(m_buffer_active, m_buffer_writing);
            }
            
            // If stopped and empty, exit
            if (!m_running && m_buffer_writing.empty()) {
                 break;
            }
            
            lock.unlock();
            
            // Write buffer to disk
            for (const auto& frame : m_buffer_writing) {
                WriteFrame(frame);
            }
            m_buffer_writing.clear();
            
            // Periodic flush to minimize data loss on crash
            auto now = std::chrono::steady_clock::now();
            auto elapsed = std::chrono::duration_cast<std::chrono::seconds>(now - m_last_flush_time).count();
            if (elapsed >= FLUSH_INTERVAL_SECONDS) {
                m_file.flush();
                m_last_flush_time = now;
            }
            
            if (!m_running) break;
        }
    }

    void WriteHeader(const SessionInfo& info) {
        m_file << "# LMUFFB Telemetry Log v1.0\n";
        m_file << "# App Version: " << info.app_version << "\n";
        m_file << "# ========================\n";
        m_file << "# Session Info\n";
        m_file << "# ========================\n";
        m_file << "# Driver: " << info.driver_name << "\n";
        m_file << "# Vehicle: " << info.vehicle_name << "\n";
        m_file << "# Track: " << info.track_name << "\n";
        m_file << "# ========================\n";
        m_file << "# FFB Settings\n";
        m_file << "# ========================\n";
        m_file << "# Gain: " << info.gain << "\n";
        m_file << "# Understeer Effect: " << info.understeer_effect << "\n";
        m_file << "# SoP Effect: " << info.sop_effect << "\n";
        m_file << "# Slope Detection: " << (info.slope_enabled ? "Enabled" : "Disabled") << "\n";
        m_file << "# Slope Sensitivity: " << info.slope_sensitivity << "\n";
        m_file << "# Slope Threshold: " << info.slope_threshold << "\n";
        m_file << "# Slope Alpha Threshold: " << info.slope_alpha_threshold << "\n";
        m_file << "# Slope Decay Rate: " << info.slope_decay_rate << "\n";
        m_file << "# ========================\n";
        
        // CSV Header
        m_file << "Time,DeltaTime,Speed,LatAccel,LongAccel,YawRate,Steering,Throttle,Brake,"
               << "SlipAngleFL,SlipAngleFR,SlipRatioFL,SlipRatioFR,GripFL,GripFR,LoadFL,LoadFR,"
               << "CalcSlipAngle,CalcGripFront,CalcGripRear,GripDelta,"
               << "dG_dt,dAlpha_dt,SlopeCurrent,SlopeRaw,SlopeNum,SlopeDenom,HoldTimer,InputSlipSmooth,SlopeSmoothed,Confidence,"
               << "SurfaceFL,SurfaceFR,SlopeTorque,SlewLimitedG,"
               << "FFBTotal,FFBBase,FFBSoP,GripFactor,SpeedGate,LoadPeakRef,Clipping,Marker\n";
    }

    void WriteFrame(const LogFrame& frame) {
        m_file << std::fixed << std::setprecision(4)
               << frame.timestamp << "," << frame.delta_time << "," 
               << frame.speed << "," << frame.lat_accel << "," << frame.long_accel << "," << frame.yaw_rate << ","
               << frame.steering << "," << frame.throttle << "," << frame.brake << ","
               
               << frame.slip_angle_fl << "," << frame.slip_angle_fr << "," 
               << frame.slip_ratio_fl << "," << frame.slip_ratio_fr << ","
               << frame.grip_fl << "," << frame.grip_fr << ","
               << frame.load_fl << "," << frame.load_fr << ","
               
               << frame.calc_slip_angle_front << "," << frame.calc_grip_front << "," << frame.calc_grip_rear << "," << frame.grip_delta << ","
               
               << frame.dG_dt << "," << frame.dAlpha_dt << "," << frame.slope_current << ","
               << frame.slope_raw_unclamped << "," << frame.slope_numerator << "," << frame.slope_denominator << ","
               << frame.hold_timer << "," << frame.input_slip_smoothed << ","
               << frame.slope_smoothed << "," << frame.confidence << ","
               << frame.surface_type_fl << "," << frame.surface_type_fr << ","
               << frame.slope_torque << "," << frame.slew_limited_g << ","
               
               << frame.ffb_total << "," << frame.ffb_base << "," << frame.ffb_sop << "," 
               << frame.ffb_grip_factor << "," << frame.speed_gate << "," << frame.load_peak_ref << ","
               << (frame.clipping ? 1 : 0) << "," << (frame.marker ? 1 : 0) << "\n";
        
        // Track file size for monitoring
        m_file_size_bytes += 200; // Approximate bytes per line
    }

    std::string SanitizeFilename(const std::string& input) {
        std::string out = input;
        // Replace invalid Windows filename characters
        std::replace(out.begin(), out.end(), ' ', '_');
        std::replace(out.begin(), out.end(), '/', '_');
        std::replace(out.begin(), out.end(), '\\', '_');
        std::replace(out.begin(), out.end(), ':', '_');
        std::replace(out.begin(), out.end(), '*', '_');
        std::replace(out.begin(), out.end(), '?', '_');
        std::replace(out.begin(), out.end(), '"', '_');
        std::replace(out.begin(), out.end(), '<', '_');
        std::replace(out.begin(), out.end(), '>', '_');
        std::replace(out.begin(), out.end(), '|', '_');
        return out;
    }
    
    std::ofstream m_file;
    std::string m_filename;
    std::thread m_worker;
    
    std::vector<LogFrame> m_buffer_active;
    std::vector<LogFrame> m_buffer_writing;
    
    std::mutex m_mutex;
    std::condition_variable m_cv;
    std::atomic<bool> m_running;
    std::atomic<bool> m_pending_marker;
    std::atomic<size_t> m_frame_count;
    
    int m_decimation_counter;
    std::atomic<size_t> m_file_size_bytes;
    std::chrono::steady_clock::time_point m_last_flush_time;
    
    static const int DECIMATION_FACTOR = 4; // 400Hz -> 100Hz
    static const size_t BUFFER_THRESHOLD = 200; // ~0.5s of data
    static const int FLUSH_INTERVAL_SECONDS = 5; // Flush every 5 seconds
};

#endif // ASYNCLOGGER_H

```

# File: src\Config.cpp
```cpp
﻿#include "Config.h"
#include "Version.h"
#include <fstream>
#include <sstream>
#include <iostream>
#include <algorithm>

bool Config::m_always_on_top = true;
std::string Config::m_last_device_guid = "";
std::string Config::m_last_preset_name = "Default";
std::string Config::m_config_path = "config.ini";
bool Config::m_auto_start_logging = false;
std::string Config::m_log_path = "logs/";

// Window Geometry Defaults (v0.5.5)
int Config::win_pos_x = 100;
int Config::win_pos_y = 100;
int Config::win_w_small = 500;   // Narrow (Config Only)
int Config::win_h_small = 800;
int Config::win_w_large = 1400;  // Wide (Config + Graphs)
int Config::win_h_large = 800;
bool Config::show_graphs = false;

std::vector<Preset> Config::presets;

void Config::ParsePresetLine(const std::string& line, Preset& current_preset, std::string& current_preset_version, bool& needs_save) {
    std::istringstream is_line(line);
    std::string key;
    if (std::getline(is_line, key, '=')) {
        std::string value;
        if (std::getline(is_line, value)) {
            try {
                // Map keys to struct members
                if (key == "app_version") current_preset_version = value;
                else if (key == "gain") current_preset.gain = std::stof(value);
                else if (key == "understeer") {
                    float val = std::stof(value);
                    if (val > 2.0f) {
                        float old_val = val;
                        val = val / 100.0f; // Migrating 0-200 range to 0-2
                        std::cout << "[Preset] Migrated legacy understeer: " << old_val
                                    << " -> " << val << std::endl;
                        needs_save = true;
                    }
                    current_preset.understeer = (std::min)(2.0f, (std::max)(0.0f, val));
                }
                else if (key == "sop") current_preset.sop = (std::min)(2.0f, std::stof(value));
                else if (key == "sop_scale") current_preset.sop_scale = std::stof(value);
                else if (key == "sop_smoothing_factor") current_preset.sop_smoothing = std::stof(value);
                else if (key == "min_force") current_preset.min_force = std::stof(value);
                else if (key == "oversteer_boost") current_preset.oversteer_boost = std::stof(value);
                else if (key == "dynamic_weight_gain") current_preset.dynamic_weight_gain = std::stof(value);
                else if (key == "dynamic_weight_smoothing") current_preset.dynamic_weight_smoothing = std::stof(value);
                else if (key == "grip_smoothing_steady") current_preset.grip_smoothing_steady = std::stof(value);
                else if (key == "grip_smoothing_fast") current_preset.grip_smoothing_fast = std::stof(value);
                else if (key == "grip_smoothing_sensitivity") current_preset.grip_smoothing_sensitivity = std::stof(value);
                else if (key == "lockup_enabled") current_preset.lockup_enabled = std::stoi(value);
                else if (key == "lockup_gain") current_preset.lockup_gain = (std::min)(3.0f, std::stof(value));
                else if (key == "lockup_start_pct") current_preset.lockup_start_pct = std::stof(value);
                else if (key == "lockup_full_pct") current_preset.lockup_full_pct = std::stof(value);
                else if (key == "lockup_rear_boost") current_preset.lockup_rear_boost = std::stof(value);
                else if (key == "lockup_gamma") current_preset.lockup_gamma = std::stof(value);
                else if (key == "lockup_prediction_sens") current_preset.lockup_prediction_sens = std::stof(value);
                else if (key == "lockup_bump_reject") current_preset.lockup_bump_reject = std::stof(value);
                else if (key == "brake_load_cap") current_preset.brake_load_cap = (std::min)(10.0f, std::stof(value));
                else if (key == "texture_load_cap") current_preset.texture_load_cap = std::stof(value); // NEW v0.6.25
                else if (key == "max_load_factor") current_preset.texture_load_cap = std::stof(value); // Legacy Backward Compatibility
                else if (key == "abs_pulse_enabled") current_preset.abs_pulse_enabled = std::stoi(value);
                else if (key == "abs_gain") current_preset.abs_gain = std::stof(value);
                else if (key == "spin_enabled") current_preset.spin_enabled = std::stoi(value);
                else if (key == "spin_gain") current_preset.spin_gain = (std::min)(2.0f, std::stof(value));
                else if (key == "slide_enabled") current_preset.slide_enabled = std::stoi(value);
                else if (key == "slide_gain") current_preset.slide_gain = (std::min)(2.0f, std::stof(value));
                else if (key == "slide_freq") current_preset.slide_freq = std::stof(value);
                else if (key == "road_enabled") current_preset.road_enabled = std::stoi(value);
                else if (key == "road_gain") current_preset.road_gain = (std::min)(2.0f, std::stof(value));
                else if (key == "invert_force") current_preset.invert_force = std::stoi(value);
                else if (key == "max_torque_ref") current_preset.max_torque_ref = std::stof(value);
                else if (key == "abs_freq") current_preset.abs_freq = std::stof(value);
                else if (key == "lockup_freq_scale") current_preset.lockup_freq_scale = std::stof(value);
                else if (key == "spin_freq_scale") current_preset.spin_freq_scale = std::stof(value);
                else if (key == "bottoming_method") current_preset.bottoming_method = std::stoi(value);
                else if (key == "scrub_drag_gain") current_preset.scrub_drag_gain = (std::min)(1.0f, std::stof(value));
                else if (key == "rear_align_effect") current_preset.rear_align_effect = (std::min)(2.0f, std::stof(value));
                else if (key == "sop_yaw_gain") current_preset.sop_yaw_gain = (std::min)(2.0f, std::stof(value));
                else if (key == "steering_shaft_gain") current_preset.steering_shaft_gain = std::stof(value);
                else if (key == "slip_angle_smoothing") current_preset.slip_smoothing = std::stof(value);
                else if (key == "base_force_mode") current_preset.base_force_mode = std::stoi(value);
                else if (key == "torque_source") current_preset.torque_source = std::stoi(value);
                else if (key == "gyro_gain") current_preset.gyro_gain = (std::min)(1.0f, std::stof(value));
                else if (key == "flatspot_suppression") current_preset.flatspot_suppression = std::stoi(value);
                else if (key == "notch_q") current_preset.notch_q = std::stof(value);
                else if (key == "flatspot_strength") current_preset.flatspot_strength = std::stof(value);
                else if (key == "static_notch_enabled") current_preset.static_notch_enabled = std::stoi(value);
                else if (key == "static_notch_freq") current_preset.static_notch_freq = std::stof(value);
                else if (key == "static_notch_width") current_preset.static_notch_width = std::stof(value);
                else if (key == "yaw_kick_threshold") current_preset.yaw_kick_threshold = std::stof(value);
                else if (key == "optimal_slip_angle") current_preset.optimal_slip_angle = std::stof(value);
                else if (key == "optimal_slip_ratio") current_preset.optimal_slip_ratio = std::stof(value);
                else if (key == "slope_detection_enabled") current_preset.slope_detection_enabled = (value == "1");
                else if (key == "slope_sg_window") current_preset.slope_sg_window = std::stoi(value);
                else if (key == "slope_sensitivity") current_preset.slope_sensitivity = std::stof(value);
                else if (key == "slope_negative_threshold") current_preset.slope_min_threshold = std::stof(value);
                else if (key == "slope_smoothing_tau") current_preset.slope_smoothing_tau = std::stof(value);
                else if (key == "slope_min_threshold") current_preset.slope_min_threshold = std::stof(value);
                else if (key == "slope_max_threshold") current_preset.slope_max_threshold = std::stof(value);
                else if (key == "slope_alpha_threshold") current_preset.slope_alpha_threshold = std::stof(value);
                else if (key == "slope_decay_rate") current_preset.slope_decay_rate = std::stof(value);
                else if (key == "slope_confidence_enabled") current_preset.slope_confidence_enabled = (value == "1");
                else if (key == "steering_shaft_smoothing") current_preset.steering_shaft_smoothing = std::stof(value);
                else if (key == "gyro_smoothing_factor") current_preset.gyro_smoothing = std::stof(value);
                else if (key == "yaw_accel_smoothing") current_preset.yaw_smoothing = std::stof(value);
                else if (key == "chassis_inertia_smoothing") current_preset.chassis_smoothing = std::stof(value);
                else if (key == "speed_gate_lower") current_preset.speed_gate_lower = std::stof(value); // NEW v0.6.25
                else if (key == "speed_gate_upper") current_preset.speed_gate_upper = std::stof(value); // NEW v0.6.25
                else if (key == "road_fallback_scale") current_preset.road_fallback_scale = std::stof(value); // NEW v0.6.25
                else if (key == "understeer_affects_sop") current_preset.understeer_affects_sop = std::stoi(value); // NEW v0.6.25
                else if (key == "slope_g_slew_limit") current_preset.slope_g_slew_limit = std::stof(value); // NEW v0.7.40
                else if (key == "slope_use_torque") current_preset.slope_use_torque = (value == "1"); // NEW v0.7.40
                else if (key == "slope_torque_sensitivity") current_preset.slope_torque_sensitivity = std::stof(value); // NEW v0.7.40
                else if (key == "slope_confidence_max_rate") current_preset.slope_confidence_max_rate = std::stof(value); // NEW v0.7.42
            } catch (...) {}
        }
    }
}

void Config::LoadPresets() {
    presets.clear();
    
    // 1. Default - Uses Preset struct defaults from Config.h (Single Source of Truth)
    presets.push_back(Preset("Default", true));
    
    // 2. T300 (Custom optimized)
    {
        Preset p("T300", true);
        p.invert_force = true;
        p.gain = 1.0f;
        p.max_torque_ref = 100.1f;
        p.min_force = 0.01f;
        p.steering_shaft_gain = 1.0f;
        p.steering_shaft_smoothing = 0.0f;
        p.understeer = 0.5f;
        p.base_force_mode = 0;
        p.flatspot_suppression = false;
        p.notch_q = 2.0f;
        p.flatspot_strength = 1.0f;
        p.static_notch_enabled = false;
        p.static_notch_freq = 11.0f;
        p.static_notch_width = 2.0f;
        p.oversteer_boost = 2.40336f;
        p.sop = 0.425003f;
        p.rear_align_effect = 0.966383f;
        p.sop_yaw_gain = 0.386555f;
        p.yaw_kick_threshold = 1.68f;
        p.yaw_smoothing = 0.005f;
        p.gyro_gain = 0.0336134f;
        p.gyro_smoothing = 0.0f;
        p.sop_smoothing = 1.0f;
        p.sop_scale = 1.0f;
        p.understeer_affects_sop = false;
        p.slip_smoothing = 0.0f;
        p.chassis_smoothing = 0.0f;
        p.optimal_slip_angle = 0.10f;   // CHANGED from 0.06f
        p.optimal_slip_ratio = 0.12f;
        p.lockup_enabled = true;
        p.lockup_gain = 2.0f;
        p.brake_load_cap = 10.0f;
        p.lockup_freq_scale = 1.02f;
        p.lockup_gamma = 0.1f;
        p.lockup_start_pct = 1.0f;
        p.lockup_full_pct = 5.0f;
        p.lockup_prediction_sens = 10.0f;
        p.lockup_bump_reject = 0.1f;
        p.lockup_rear_boost = 10.0f;
        p.abs_pulse_enabled = true;
        p.abs_gain = 2.0f;
        p.abs_freq = 20.0f;
        p.texture_load_cap = 1.96f;
        p.slide_enabled = true;
        p.slide_gain = 0.235294f;
        p.slide_freq = 1.0f;
        p.road_enabled = true;
        p.road_gain = 2.0f;
        p.road_fallback_scale = 0.05f;
        p.spin_enabled = true;
        p.spin_gain = 0.5f;
        p.spin_freq_scale = 1.0f;
        p.scrub_drag_gain = 0.0462185f;
        p.bottoming_method = 0;
        p.speed_gate_lower = 0.0f;
        p.speed_gate_upper = 0.277778f;
        presets.push_back(p);
    }
    
    // 3. GT3 DD 15 Nm (Simagic Alpha)
    {
        Preset p("GT3 DD 15 Nm (Simagic Alpha)", true);
        p.gain = 1.0f;
        p.max_torque_ref = 100.0f;
        p.min_force = 0.0f;
        p.steering_shaft_gain = 1.0f;
        p.steering_shaft_smoothing = 0.0f;
        p.understeer = 1.0f;
        p.base_force_mode = 0;
        p.flatspot_suppression = false;
        p.notch_q = 2.0f;
        p.flatspot_strength = 1.0f;
        p.static_notch_enabled = false;
        p.static_notch_freq = 11.0f;
        p.static_notch_width = 2.0f;
        p.oversteer_boost = 2.52101f;
        p.sop = 1.666f;
        p.rear_align_effect = 0.666f;
        p.sop_yaw_gain = 0.333f;
        p.yaw_kick_threshold = 0.0f;
        p.yaw_smoothing = 0.001f;
        p.gyro_gain = 0.0f;
        p.gyro_smoothing = 0.0f;
        p.sop_smoothing = 0.99f;
        p.sop_scale = 1.98f;
        p.understeer_affects_sop = false;
        p.slip_smoothing = 0.002f;
        p.chassis_smoothing = 0.012f;
        p.optimal_slip_angle = 0.1f;
        p.optimal_slip_ratio = 0.12f;
        p.lockup_enabled = true;
        p.lockup_gain = 0.37479f;
        p.brake_load_cap = 2.0f;
        p.lockup_freq_scale = 1.0f;
        p.lockup_gamma = 1.0f;
        p.lockup_start_pct = 1.0f;
        p.lockup_full_pct = 7.5f;
        p.lockup_prediction_sens = 10.0f;
        p.lockup_bump_reject = 0.1f;
        p.lockup_rear_boost = 1.0f;
        p.abs_pulse_enabled = false;
        p.abs_gain = 2.1f;
        p.abs_freq = 25.5f;
        p.texture_load_cap = 1.5f;
        p.slide_enabled = false;
        p.slide_gain = 0.226562f;
        p.slide_freq = 1.47f;
        p.road_enabled = true;
        p.road_gain = 0.0f;
        p.road_fallback_scale = 0.05f;
        p.spin_enabled = true;
        p.spin_gain = 0.462185f;
        p.spin_freq_scale = 1.8f;
        p.scrub_drag_gain = 0.333f;
        p.bottoming_method = 1;
        p.speed_gate_lower = 1.0f;
        p.speed_gate_upper = 5.0f;
        presets.push_back(p);
    }
    
    // 4. LMPx/HY DD 15 Nm (Simagic Alpha)
    {
        Preset p("LMPx/HY DD 15 Nm (Simagic Alpha)", true);
        p.gain = 1.0f;
        p.max_torque_ref = 100.0f;
        p.min_force = 0.0f;
        p.steering_shaft_gain = 1.0f;
        p.steering_shaft_smoothing = 0.0f;
        p.understeer = 1.0f;
        p.base_force_mode = 0;
        p.flatspot_suppression = false;
        p.notch_q = 2.0f;
        p.flatspot_strength = 1.0f;
        p.static_notch_enabled = false;
        p.static_notch_freq = 11.0f;
        p.static_notch_width = 2.0f;
        p.oversteer_boost = 2.52101f;
        p.sop = 1.666f;
        p.rear_align_effect = 0.666f;
        p.sop_yaw_gain = 0.333f;
        p.yaw_kick_threshold = 0.0f;
        p.yaw_smoothing = 0.003f;
        p.gyro_gain = 0.0f;
        p.gyro_smoothing = 0.003f;
        p.sop_smoothing = 0.97f;
        p.sop_scale = 1.59f;
        p.understeer_affects_sop = false;
        p.slip_smoothing = 0.003f;
        p.chassis_smoothing = 0.019f;
        p.optimal_slip_angle = 0.12f;
        p.optimal_slip_ratio = 0.12f;
        p.lockup_enabled = true;
        p.lockup_gain = 0.37479f;
        p.brake_load_cap = 2.0f;
        p.lockup_freq_scale = 1.0f;
        p.lockup_gamma = 1.0f;
        p.lockup_start_pct = 1.0f;
        p.lockup_full_pct = 7.5f;
        p.lockup_prediction_sens = 10.0f;
        p.lockup_bump_reject = 0.1f;
        p.lockup_rear_boost = 1.0f;
        p.abs_pulse_enabled = false;
        p.abs_gain = 2.1f;
        p.abs_freq = 25.5f;
        p.texture_load_cap = 1.5f;
        p.slide_enabled = false;
        p.slide_gain = 0.226562f;
        p.slide_freq = 1.47f;
        p.road_enabled = true;
        p.road_gain = 0.0f;
        p.road_fallback_scale = 0.05f;
        p.spin_enabled = true;
        p.spin_gain = 0.462185f;
        p.spin_freq_scale = 1.8f;
        p.scrub_drag_gain = 0.333f;
        p.bottoming_method = 1;
        p.speed_gate_lower = 1.0f;
        p.speed_gate_upper = 5.0f;
        presets.push_back(p);
    }
    
    // 5. GM DD 21 Nm (Moza R21 Ultra)
    {
        Preset p("GM DD 21 Nm (Moza R21 Ultra)", true);
        p.gain = 1.454f;
        p.max_torque_ref = 100.1f;
        p.min_force = 0.0f;
        p.steering_shaft_gain = 1.989f;
        p.steering_shaft_smoothing = 0.0f;
        p.understeer = 0.638f;
        p.base_force_mode = 0;
        p.flatspot_suppression = true;
        p.notch_q = 0.57f;
        p.flatspot_strength = 1.0f;
        p.static_notch_enabled = false;
        p.static_notch_freq = 11.0f;
        p.static_notch_width = 2.0f;
        p.oversteer_boost = 0.0f;
        p.sop = 0.0f;
        p.rear_align_effect = 0.29f;
        p.sop_yaw_gain = 0.0f;
        p.yaw_kick_threshold = 0.0f;
        p.yaw_smoothing = 0.015f;
        p.gyro_gain = 0.0f;
        p.gyro_smoothing = 0.0f;
        p.sop_smoothing = 0.0f;
        p.sop_scale = 0.89f;
        p.understeer_affects_sop = false;
        p.slip_smoothing = 0.002f;
        p.chassis_smoothing = 0.0f;
        p.optimal_slip_angle = 0.1f;
        p.optimal_slip_ratio = 0.12f;
        p.lockup_enabled = true;
        p.lockup_gain = 0.977f;
        p.brake_load_cap = 81.0f;
        p.lockup_freq_scale = 1.0f;
        p.lockup_gamma = 1.0f;
        p.lockup_start_pct = 1.0f;
        p.lockup_full_pct = 7.5f;
        p.lockup_prediction_sens = 10.0f;
        p.lockup_bump_reject = 0.1f;
        p.lockup_rear_boost = 1.0f;
        p.abs_pulse_enabled = false;
        p.abs_gain = 2.1f;
        p.abs_freq = 25.5f;
        p.texture_load_cap = 1.5f;
        p.slide_enabled = false;
        p.slide_gain = 0.0f;
        p.slide_freq = 1.47f;
        p.road_enabled = true;
        p.road_gain = 0.0f;
        p.road_fallback_scale = 0.05f;
        p.spin_enabled = true;
        p.spin_gain = 0.462185f;
        p.spin_freq_scale = 1.8f;
        p.scrub_drag_gain = 0.333f;
        p.bottoming_method = 1;
        p.speed_gate_lower = 1.0f;
        p.speed_gate_upper = 5.0f;
        presets.push_back(p);
    }
    
    // 6. GM + Yaw Kick DD 21 Nm (Moza R21 Ultra)
    {
        // Copy GM preset and add yaw kick
        Preset p("GM + Yaw Kick DD 21 Nm (Moza R21 Ultra)", true);
        p.gain = 1.454f;
        p.max_torque_ref = 100.1f;
        p.min_force = 0.0f;
        p.steering_shaft_gain = 1.989f;
        p.steering_shaft_smoothing = 0.0f;
        p.understeer = 0.638f;
        p.base_force_mode = 0;
        p.flatspot_suppression = true;
        p.notch_q = 0.57f;
        p.flatspot_strength = 1.0f;
        p.static_notch_enabled = false;
        p.static_notch_freq = 11.0f;
        p.static_notch_width = 2.0f;
        p.oversteer_boost = 0.0f;
        p.sop = 0.0f;
        p.rear_align_effect = 0.29f;
        p.sop_yaw_gain = 0.333f;  // ONLY DIFFERENCE: Added yaw kick
        p.yaw_kick_threshold = 0.0f;
        p.yaw_smoothing = 0.003f;
        p.gyro_gain = 0.0f;
        p.gyro_smoothing = 0.0f;
        p.sop_smoothing = 0.0f;
        p.sop_scale = 0.89f;
        p.understeer_affects_sop = false;
        p.slip_smoothing = 0.002f;
        p.chassis_smoothing = 0.0f;
        p.optimal_slip_angle = 0.1f;
        p.optimal_slip_ratio = 0.12f;
        p.lockup_enabled = true;
        p.lockup_gain = 0.977f;
        p.brake_load_cap = 81.0f;
        p.lockup_freq_scale = 1.0f;
        p.lockup_gamma = 1.0f;
        p.lockup_start_pct = 1.0f;
        p.lockup_full_pct = 7.5f;
        p.lockup_prediction_sens = 10.0f;
        p.lockup_bump_reject = 0.1f;
        p.lockup_rear_boost = 1.0f;
        p.abs_pulse_enabled = false;
        p.abs_gain = 2.1f;
        p.abs_freq = 25.5f;
        p.texture_load_cap = 1.5f;
        p.slide_enabled = false;
        p.slide_gain = 0.0f;
        p.slide_freq = 1.47f;
        p.road_enabled = true;
        p.road_gain = 0.0f;
        p.road_fallback_scale = 0.05f;
        p.spin_enabled = true;
        p.spin_gain = 0.462185f;
        p.spin_freq_scale = 1.8f;
        p.scrub_drag_gain = 0.333f;
        p.bottoming_method = 1;
        p.speed_gate_lower = 1.0f;
        p.speed_gate_upper = 5.0f;
        presets.push_back(p);
    }
    
    // 8. Test: Game Base FFB Only
    presets.push_back(Preset("Test: Game Base FFB Only", true)
        .SetUndersteer(0.0f)
        .SetSoP(0.0f)
        .SetSoPScale(1.0f)
        .SetSmoothing(0.85f)
        .SetSlipSmoothing(0.015f)
        .SetSlide(false, 0.0f)
        .SetRearAlign(0.0f)
    );

    // 9. Test: SoP Only
    presets.push_back(Preset("Test: SoP Only", true)
        .SetUndersteer(0.0f)
        .SetSoP(0.08f)
        .SetSoPScale(1.0f)
        .SetSmoothing(0.85f)
        .SetSlipSmoothing(0.015f)
        .SetSlide(false, 0.0f)
        .SetRearAlign(0.0f)
        .SetSoPYaw(0.0f)
        .SetBaseMode(2) // Muted
    );

    // 10. Test: Understeer Only (Updated v0.6.31 for proper effect isolation)
    presets.push_back(Preset("Test: Understeer Only", true)
        // PRIMARY EFFECT
        .SetUndersteer(0.61f)
        
        // DISABLE ALL OTHER EFFECTS
        .SetSoP(0.0f)
        .SetSoPScale(1.0f)
        .SetOversteer(0.0f)          // Disable oversteer boost
        .SetRearAlign(0.0f)
        .SetSoPYaw(0.0f)             // Disable yaw kick
        .SetGyro(0.0f)               // Disable gyro damping
        
        // DISABLE ALL TEXTURES
        .SetSlide(false, 0.0f)
        .SetRoad(false, 0.0f)        // Disable road texture
        .SetSpin(false, 0.0f)        // Disable spin
        .SetLockup(false, 0.0f)      // Disable lockup vibration
        .SetAdvancedBraking(0.5f, 20.0f, 0.1f, false, 0.0f)  // Disable ABS pulse
        .SetScrub(0.0f)
        
        // SMOOTHING
        .SetSmoothing(0.85f)         // SoP smoothing (doesn't affect test since SoP=0)
        .SetSlipSmoothing(0.015f)    // Slip angle smoothing (important for grip calculation)
        
        // PHYSICS PARAMETERS (Explicit for clarity and future-proofing)
        .SetOptimalSlip(0.10f, 0.12f)  // Explicit optimal slip thresholds
        .SetBaseMode(0)                 // Native physics mode (required for understeer)
        .SetSpeedGate(0.0f, 0.0f)      // Disable speed gate (0 = no gating)
    );

    // 11. Test: Yaw Kick Only
    presets.push_back(Preset("Test: Yaw Kick Only", true)
        // PRIMARY EFFECT
        .SetSoPYaw(0.386555f)        // Yaw kick at T300 level
        .SetYawKickThreshold(1.68f)  // T300 threshold
        .SetYawSmoothing(0.005f)     // T300 smoothing
        
        // DISABLE ALL OTHER EFFECTS
        .SetUndersteer(0.0f)
        .SetSoP(0.0f)
        .SetSoPScale(1.0f)
        .SetOversteer(0.0f)
        .SetRearAlign(0.0f)
        .SetGyro(0.0f)
        
        // DISABLE ALL TEXTURES
        .SetSlide(false, 0.0f)
        .SetRoad(false, 0.0f)
        .SetSpin(false, 0.0f)
        .SetLockup(false, 0.0f)
        .SetAdvancedBraking(0.5f, 20.0f, 0.1f, false, 0.0f)
        .SetScrub(0.0f)
        
        // SMOOTHING
        .SetSmoothing(0.85f)
        .SetSlipSmoothing(0.015f)
        
        // BASE MODE
        .SetBaseMode(2)  // Muted: Feel only the yaw kick impulse
    );

    // 12. Test: Textures Only
    presets.push_back(Preset("Test: Textures Only", true)
        .SetUndersteer(0.0f)
        .SetSoP(0.0f)
        .SetSoPScale(0.0f)
        .SetSmoothing(0.85f)
        .SetSlipSmoothing(0.015f)
        .SetLockup(true, 1.0f)
        .SetSpin(true, 1.0f)
        .SetSlide(true, 0.39f)
        .SetRoad(true, 1.0f)
        .SetRearAlign(0.0f)
        .SetBaseMode(2) // Muted
    );

    // 13. Test: Rear Align Torque Only
    presets.push_back(Preset("Test: Rear Align Torque Only", true)
        .SetGain(1.0f)
        .SetUndersteer(0.0f)
        .SetSoP(0.0f)
        .SetSmoothing(0.85f)
        .SetSlipSmoothing(0.015f)
        .SetSlide(false, 0.0f)
        .SetRearAlign(0.90f)
        .SetSoPYaw(0.0f)
    );

    // 14. Test: SoP Base Only
    presets.push_back(Preset("Test: SoP Base Only", true)
        .SetGain(1.0f)
        .SetUndersteer(0.0f)
        .SetSoP(0.08f)
        .SetSmoothing(0.85f)
        .SetSlipSmoothing(0.015f)
        .SetSlide(false, 0.0f)
        .SetRearAlign(0.0f)
        .SetSoPYaw(0.0f)
        .SetBaseMode(2) // Muted
    );

    // 15. Test: Slide Texture Only
    presets.push_back(Preset("Test: Slide Texture Only", true)
        .SetGain(1.0f)
        .SetUndersteer(0.0f)
        .SetSoP(0.0f)
        .SetSmoothing(0.85f)
        .SetSlipSmoothing(0.015f)
        .SetSlide(true, 0.39f, 1.0f)
        .SetRearAlign(0.0f)
        .SetBaseMode(2) // Muted
    );

    // 16. Test: No Effects
    presets.push_back(Preset("Test: No Effects", true)
        .SetGain(1.0f)
        .SetUndersteer(0.0f)
        .SetSoP(0.0f)
        .SetSmoothing(0.85f)
        .SetSlipSmoothing(0.015f)
        .SetSlide(false, 0.0f)
        .SetRearAlign(0.0f)
        .SetBaseMode(2) // Muted
    );

    // --- NEW GUIDE PRESETS (v0.4.24) ---

    // 17. Guide: Understeer (Front Grip Loss)
    presets.push_back(Preset("Guide: Understeer (Front Grip)", true)
        .SetGain(1.0f)
        .SetUndersteer(0.61f)
        .SetSoP(0.0f)
        .SetOversteer(0.0f)
        .SetRearAlign(0.0f)
        .SetSoPYaw(0.0f)
        .SetGyro(0.0f)
        .SetLockup(false, 0.0f)
        .SetSpin(false, 0.0f)
        .SetSlide(false, 0.0f)
        .SetRoad(false, 0.0f)
        .SetScrub(0.0f)
        .SetSmoothing(0.85f)
        .SetSlipSmoothing(0.015f)
        .SetBaseMode(0) // Native Physics needed to feel the drop
    );

    // 18. Guide: Oversteer (Rear Grip Loss)
    presets.push_back(Preset("Guide: Oversteer (Rear Grip)", true)
        .SetGain(1.0f)
        .SetUndersteer(0.0f)
        .SetSoP(0.08f)
        .SetSoPScale(1.0f)
        .SetRearAlign(0.90f)
        .SetOversteer(0.65f)
        .SetSoPYaw(0.0f)
        .SetGyro(0.0f)
        .SetLockup(false, 0.0f)
        .SetSpin(false, 0.0f)
        .SetSlide(false, 0.0f)
        .SetRoad(false, 0.0f)
        .SetScrub(0.0f)
        .SetSmoothing(0.85f)
        .SetSlipSmoothing(0.015f)
        .SetBaseMode(0) // Native Physics + Boost
    );

    // 19. Guide: Slide Texture (Scrubbing)
    presets.push_back(Preset("Guide: Slide Texture (Scrub)", true)
        .SetGain(1.0f)
        .SetUndersteer(0.0f)
        .SetSoP(0.0f)
        .SetOversteer(0.0f)
        .SetRearAlign(0.0f)
        .SetSlide(true, 0.39f, 1.0f) // Gain 0.39, Freq 1.0 (Rumble)
        .SetScrub(1.0f)
        .SetLockup(false, 0.0f)
        .SetSpin(false, 0.0f)
        .SetRoad(false, 0.0f)
        .SetSmoothing(0.85f)
        .SetSlipSmoothing(0.015f)
        .SetBaseMode(2) // Muted for clear texture feel
    );

    // 20. Guide: Braking Lockup
    presets.push_back(Preset("Guide: Braking Lockup", true)
        .SetGain(1.0f)
        .SetUndersteer(0.0f)
        .SetSoP(0.0f)
        .SetOversteer(0.0f)
        .SetRearAlign(0.0f)
        .SetLockup(true, 1.0f)
        .SetSpin(false, 0.0f)
        .SetSlide(false, 0.0f)
        .SetRoad(false, 0.0f)
        .SetScrub(0.0f)
        .SetSmoothing(0.85f)
        .SetSlipSmoothing(0.015f)
        .SetBaseMode(2) // Muted
    );

    // 21. Guide: Traction Loss (Wheel Spin)
    presets.push_back(Preset("Guide: Traction Loss (Spin)", true)
        .SetGain(1.0f)
        .SetUndersteer(0.0f)
        .SetSoP(0.0f)
        .SetOversteer(0.0f)
        .SetRearAlign(0.0f)
        .SetSpin(true, 1.0f)
        .SetLockup(false, 0.0f)
        .SetSlide(false, 0.0f)
        .SetRoad(false, 0.0f)
        .SetScrub(0.0f)
        .SetSmoothing(0.85f)
        .SetSlipSmoothing(0.015f)
        .SetBaseMode(2) // Muted
    );

     // 22. Guide: SoP Yaw (Kick)
    presets.push_back(Preset("Guide: SoP Yaw (Kick)", true)
        .SetGain(1.0f)
        .SetUndersteer(0.0f)
        .SetSoP(0.0f)
        .SetOversteer(0.0f)
        .SetRearAlign(0.0f)
        .SetSoPYaw(5.0f) // Standard T300 level
        .SetGyro(0.0f)
        .SetLockup(false, 0.0f)
        .SetSpin(false, 0.0f)
        .SetSlide(false, 0.0f)
        .SetRoad(false, 0.0f)
        .SetScrub(0.0f)
        .SetSmoothing(0.85f)
        .SetSlipSmoothing(0.015f)
        .SetBaseMode(2) // Muted: Feel only the rotation impulse
    );

    // 23. Guide: Gyroscopic Damping
    presets.push_back(Preset("Guide: Gyroscopic Damping", true)
        .SetGain(1.0f)
        .SetUndersteer(0.0f)
        .SetSoP(0.0f)
        .SetOversteer(0.0f)
        .SetRearAlign(0.0f)
        .SetSoPYaw(0.0f)
        .SetGyro(1.0f) // Max damping
        .SetLockup(false, 0.0f)
        .SetSpin(false, 0.0f)
        .SetSlide(false, 0.0f)
        .SetRoad(false, 0.0f)
        .SetScrub(0.0f)
        .SetSmoothing(0.85f)
        .SetSlipSmoothing(0.015f)
        .SetBaseMode(2) // Muted: Feel only the resistance to movement
    );

    // --- Parse User Presets from config.ini ---
    // (Keep the existing parsing logic below, it works fine for file I/O)
    std::ifstream file(m_config_path);
    if (!file.is_open()) return;

    std::string line;
    bool in_presets = false;
    bool needs_save = false;
    
    std::string current_preset_name = "";
    Preset current_preset; // Uses default constructor with default values
    std::string current_preset_version = "";
    bool preset_pending = false;

    while (std::getline(file, line)) {
        // Strip whitespace
        line.erase(0, line.find_first_not_of(" \t\r\n"));
        line.erase(line.find_last_not_of(" \t\r\n") + 1);
        
        if (line.empty() || line[0] == ';') continue;

        if (line[0] == '[') {
            if (preset_pending && !current_preset_name.empty()) {
                current_preset.name = current_preset_name;
                current_preset.is_builtin = false; // User preset
                
                // MIGRATION: If version is missing or old, update it
                if (current_preset_version.empty()) {
                    current_preset.app_version = LMUFFB_VERSION;
                    needs_save = true;
                    std::cout << "[Config] Migrated legacy preset '" << current_preset_name << "' to version " << LMUFFB_VERSION << std::endl;
                } else {
                    current_preset.app_version = current_preset_version;
                }
                
                current_preset.Validate(); // v0.7.15: Validate before adding
                presets.push_back(current_preset);
                preset_pending = false;
            }
            
            if (line == "[Presets]") {
                in_presets = true;
            } else if (line.rfind("[Preset:", 0) == 0) { 
                in_presets = false; 
                size_t end_pos = line.find(']');
                if (end_pos != std::string::npos) {
                    current_preset_name = line.substr(8, end_pos - 8);
                    current_preset = Preset(current_preset_name, false); // Reset to defaults, not builtin
                    preset_pending = true;
                    current_preset_version = "";
                }
            } else {
                in_presets = false;
            }
            continue;
        }

        if (preset_pending) {
            ParsePresetLine(line, current_preset, current_preset_version, needs_save);
        }
    }
    
    if (preset_pending && !current_preset_name.empty()) {
        current_preset.name = current_preset_name;
        current_preset.is_builtin = false;
        
        // MIGRATION: If version is missing or old, update it
        if (current_preset_version.empty()) {
            current_preset.app_version = LMUFFB_VERSION;
            needs_save = true;
            std::cout << "[Config] Migrated legacy preset '" << current_preset_name << "' to version " << LMUFFB_VERSION << std::endl;
        } else {
            current_preset.app_version = current_preset_version;
        }
        
        current_preset.Validate(); // v0.7.15: Validate before adding
        presets.push_back(current_preset);
    }

    // Auto-save if migration occurred
    if (needs_save) {
        FFBEngine temp_engine; // Just to satisfy the Save signature
        // We might want a version of Save that doesn't overwrite current engine settings
        // but for now, the plan says "call Config::SaveManualPresetsOnly() (or similar)".
        // Looking at Save(), it saves everything. 
        // If we just loaded presets, we haven't applied them to any engine yet.
        // But Config::Save takes an engine.
        // Actually, if we just want to update the presets on disk, we should call Save.
        Save(temp_engine);
    }
}

void Config::ApplyPreset(int index, FFBEngine& engine) {
    if (index >= 0 && index < presets.size()) {
        presets[index].Apply(engine);
        m_last_preset_name = presets[index].name;
        std::cout << "[Config] Applied preset: " << presets[index].name << std::endl;
        Save(engine); // Integrated Auto-Save (v0.6.27)
    }
}

void Config::WritePresetFields(std::ofstream& file, const Preset& p) {
    file << "app_version=" << p.app_version << "\n";
    file << "invert_force=" << (p.invert_force ? "1" : "0") << "\n";
    file << "gain=" << p.gain << "\n";
    file << "max_torque_ref=" << p.max_torque_ref << "\n";
    file << "min_force=" << p.min_force << "\n";

    file << "steering_shaft_gain=" << p.steering_shaft_gain << "\n";
    file << "steering_shaft_smoothing=" << p.steering_shaft_smoothing << "\n";
    file << "understeer=" << p.understeer << "\n";
    file << "base_force_mode=" << p.base_force_mode << "\n";
    file << "torque_source=" << p.torque_source << "\n";
    file << "flatspot_suppression=" << p.flatspot_suppression << "\n";
    file << "notch_q=" << p.notch_q << "\n";
    file << "flatspot_strength=" << p.flatspot_strength << "\n";
    file << "static_notch_enabled=" << p.static_notch_enabled << "\n";
    file << "static_notch_freq=" << p.static_notch_freq << "\n";
    file << "static_notch_width=" << p.static_notch_width << "\n";

    file << "oversteer_boost=" << p.oversteer_boost << "\n";
    file << "dynamic_weight_gain=" << p.dynamic_weight_gain << "\n";
    file << "dynamic_weight_smoothing=" << p.dynamic_weight_smoothing << "\n";
    file << "grip_smoothing_steady=" << p.grip_smoothing_steady << "\n";
    file << "grip_smoothing_fast=" << p.grip_smoothing_fast << "\n";
    file << "grip_smoothing_sensitivity=" << p.grip_smoothing_sensitivity << "\n";
    file << "sop=" << p.sop << "\n";
    file << "rear_align_effect=" << p.rear_align_effect << "\n";
    file << "sop_yaw_gain=" << p.sop_yaw_gain << "\n";
    file << "yaw_kick_threshold=" << p.yaw_kick_threshold << "\n";
    file << "yaw_accel_smoothing=" << p.yaw_smoothing << "\n";
    file << "gyro_gain=" << p.gyro_gain << "\n";
    file << "gyro_smoothing_factor=" << p.gyro_smoothing << "\n";
    file << "sop_smoothing_factor=" << p.sop_smoothing << "\n";
    file << "sop_scale=" << p.sop_scale << "\n";
    file << "understeer_affects_sop=" << p.understeer_affects_sop << "\n";
    file << "slope_detection_enabled=" << p.slope_detection_enabled << "\n";
    file << "slope_sg_window=" << p.slope_sg_window << "\n";
    file << "slope_sensitivity=" << p.slope_sensitivity << "\n";

    file << "slope_smoothing_tau=" << p.slope_smoothing_tau << "\n";
    file << "slope_min_threshold=" << p.slope_min_threshold << "\n";
    file << "slope_max_threshold=" << p.slope_max_threshold << "\n";
    file << "slope_alpha_threshold=" << p.slope_alpha_threshold << "\n";
    file << "slope_decay_rate=" << p.slope_decay_rate << "\n";
    file << "slope_confidence_enabled=" << p.slope_confidence_enabled << "\n";
    file << "slope_g_slew_limit=" << p.slope_g_slew_limit << "\n";
    file << "slope_use_torque=" << (p.slope_use_torque ? "1" : "0") << "\n";
    file << "slope_torque_sensitivity=" << p.slope_torque_sensitivity << "\n";
    file << "slope_confidence_max_rate=" << p.slope_confidence_max_rate << "\n";

    file << "slip_angle_smoothing=" << p.slip_smoothing << "\n";
    file << "chassis_inertia_smoothing=" << p.chassis_smoothing << "\n";
    file << "optimal_slip_angle=" << p.optimal_slip_angle << "\n";
    file << "optimal_slip_ratio=" << p.optimal_slip_ratio << "\n";

    file << "lockup_enabled=" << (p.lockup_enabled ? "1" : "0") << "\n";
    file << "lockup_gain=" << p.lockup_gain << "\n";
    file << "brake_load_cap=" << p.brake_load_cap << "\n";
    file << "lockup_freq_scale=" << p.lockup_freq_scale << "\n";
    file << "lockup_gamma=" << p.lockup_gamma << "\n";
    file << "lockup_start_pct=" << p.lockup_start_pct << "\n";
    file << "lockup_full_pct=" << p.lockup_full_pct << "\n";
    file << "lockup_prediction_sens=" << p.lockup_prediction_sens << "\n";
    file << "lockup_bump_reject=" << p.lockup_bump_reject << "\n";
    file << "lockup_rear_boost=" << p.lockup_rear_boost << "\n";
    file << "abs_pulse_enabled=" << (p.abs_pulse_enabled ? "1" : "0") << "\n";
    file << "abs_gain=" << p.abs_gain << "\n";
    file << "abs_freq=" << p.abs_freq << "\n";

    file << "texture_load_cap=" << p.texture_load_cap << "\n";
    file << "slide_enabled=" << (p.slide_enabled ? "1" : "0") << "\n";
    file << "slide_gain=" << p.slide_gain << "\n";
    file << "slide_freq=" << p.slide_freq << "\n";
    file << "road_enabled=" << (p.road_enabled ? "1" : "0") << "\n";
    file << "road_gain=" << p.road_gain << "\n";
    file << "road_fallback_scale=" << p.road_fallback_scale << "\n";
    file << "spin_enabled=" << (p.spin_enabled ? "1" : "0") << "\n";
    file << "spin_gain=" << p.spin_gain << "\n";
    file << "spin_freq_scale=" << p.spin_freq_scale << "\n";
    file << "scrub_drag_gain=" << p.scrub_drag_gain << "\n";
    file << "bottoming_method=" << p.bottoming_method << "\n";

    file << "speed_gate_lower=" << p.speed_gate_lower << "\n";
    file << "speed_gate_upper=" << p.speed_gate_upper << "\n";
}

void Config::ExportPreset(int index, const std::string& filename) {
    if (index < 0 || index >= presets.size()) return;

    const Preset& p = presets[index];
    std::ofstream file(filename);
    if (file.is_open()) {
        file << "[Preset:" << p.name << "]\n";
        WritePresetFields(file, p);
        file.close();
        std::cout << "[Config] Exported preset '" << p.name << "' to " << filename << std::endl;
    } else {
        std::cerr << "[Config] Failed to export preset to " << filename << std::endl;
    }
}

bool Config::ImportPreset(const std::string& filename, const FFBEngine& engine) {
    std::ifstream file(filename);
    if (!file.is_open()) return false;

    std::string line;
    std::string current_preset_name = "";
    Preset current_preset;
    std::string current_preset_version = "";
    bool preset_pending = false;
    bool imported = false;

    while (std::getline(file, line)) {
        // Strip whitespace
        line.erase(0, line.find_first_not_of(" \t\r\n"));
        line.erase(line.find_last_not_of(" \t\r\n") + 1);

        if (line.empty() || line[0] == ';') continue;

        if (line[0] == '[') {
            if (line.rfind("[Preset:", 0) == 0) {
                size_t end_pos = line.find(']');
                if (end_pos != std::string::npos) {
                    current_preset_name = line.substr(8, end_pos - 8);
                    current_preset = Preset(current_preset_name, false);
                    preset_pending = true;
                    current_preset_version = "";
                }
            }
            continue;
        }

        if (preset_pending) {
            bool dummy_needs_save = false;
            ParsePresetLine(line, current_preset, current_preset_version, dummy_needs_save);
        }
    }

    if (preset_pending && !current_preset_name.empty()) {
        current_preset.name = current_preset_name;
        current_preset.is_builtin = false;
        current_preset.app_version = current_preset_version.empty() ? LMUFFB_VERSION : current_preset_version;

        // Handle name collision
        std::string base_name = current_preset.name;
        int counter = 1;
        bool exists = true;
        while (exists) {
            exists = false;
            for (const auto& p : presets) {
                if (p.name == current_preset.name) {
                    current_preset.name = base_name + " (" + std::to_string(counter++) + ")";
                    exists = true;
                    break;
                }
            }
        }

        current_preset.Validate(); // v0.7.15: Validate before adding
        presets.push_back(current_preset);
        imported = true;
    }

    if (imported) {
        Save(engine);
        std::cout << "[Config] Imported preset '" << current_preset.name << "' from " << filename << std::endl;
        return true;
    }

    return false;
}

void Config::AddUserPreset(const std::string& name, const FFBEngine& engine) {
    // Check if name exists and overwrite, or add new
    bool found = false;
    for (auto& p : presets) {
        if (p.name == name && !p.is_builtin) {
            p.UpdateFromEngine(engine);
            found = true;
            break;
        }
    }
    
    if (!found) {
        Preset p(name, false);
        p.UpdateFromEngine(engine);
        presets.push_back(p);
    }
    
    m_last_preset_name = name;

    // Save immediately to persist
    Save(engine);
}

void Config::DeletePreset(int index, const FFBEngine& engine) {
    if (index < 0 || index >= (int)presets.size()) return;
    if (presets[index].is_builtin) return; // Cannot delete builtin presets

    std::string name = presets[index].name;
    presets.erase(presets.begin() + index);
    std::cout << "[Config] Deleted preset: " << name << std::endl;

    // If the deleted preset was the last used one, reset it
    if (m_last_preset_name == name) {
        m_last_preset_name = "Default";
    }

    Save(engine);
}

void Config::DuplicatePreset(int index, const FFBEngine& engine) {
    if (index < 0 || index >= (int)presets.size()) return;

    Preset p = presets[index];
    p.name = p.name + " (Copy)";
    p.is_builtin = false;
    p.app_version = LMUFFB_VERSION;

    // Ensure unique name
    std::string base_name = p.name;
    int counter = 1;
    bool exists = true;
    while (exists) {
        exists = false;
        for (const auto& existing : presets) {
            if (existing.name == p.name) {
                p.name = base_name + " " + std::to_string(counter++);
                exists = true;
                break;
            }
        }
    }

    presets.push_back(p);
    m_last_preset_name = p.name;
    std::cout << "[Config] Duplicated preset to: " << p.name << std::endl;
    Save(engine);
}

bool Config::IsEngineDirtyRelativeToPreset(int index, const FFBEngine& engine) {
    if (index < 0 || index >= (int)presets.size()) return false;

    Preset current_state;
    current_state.UpdateFromEngine(engine);

    return !presets[index].Equals(current_state);
}

void Config::Save(const FFBEngine& engine, const std::string& filename) {
    std::string final_path = filename.empty() ? m_config_path : filename;
    std::ofstream file(final_path);
    if (file.is_open()) {
        file << "; --- System & Window ---\n";
        // Config Version Tracking: The ini_version field serves dual purposes:
        // 1. Records the app version that last saved this config
        // 2. Acts as an implicit config format version for migration logic
        // NOTE: Currently migration is threshold-based (e.g., understeer > 2.0 = legacy).
        //       For more complex migrations, consider adding explicit config_format_version field.
        file << "ini_version=" << LMUFFB_VERSION << "\n";
        file << "always_on_top=" << m_always_on_top << "\n";
        file << "last_device_guid=" << m_last_device_guid << "\n";
        file << "last_preset_name=" << m_last_preset_name << "\n";
        file << "win_pos_x=" << win_pos_x << "\n";
        file << "win_pos_y=" << win_pos_y << "\n";
        file << "win_w_small=" << win_w_small << "\n";
        file << "win_h_small=" << win_h_small << "\n";
        file << "win_w_large=" << win_w_large << "\n";
        file << "win_h_large=" << win_h_large << "\n";
        file << "show_graphs=" << show_graphs << "\n";
        file << "auto_start_logging=" << m_auto_start_logging << "\n";
        file << "log_path=" << m_log_path << "\n";

        file << "\n; --- General FFB ---\n";
        file << "invert_force=" << engine.m_invert_force << "\n";
        file << "gain=" << engine.m_gain << "\n";
        file << "max_torque_ref=" << engine.m_max_torque_ref << "\n";
        file << "min_force=" << engine.m_min_force << "\n";

        file << "\n; --- Front Axle (Understeer) ---\n";
        file << "steering_shaft_gain=" << engine.m_steering_shaft_gain << "\n";
        file << "steering_shaft_smoothing=" << engine.m_steering_shaft_smoothing << "\n";
        file << "understeer=" << engine.m_understeer_effect << "\n";
        file << "base_force_mode=" << engine.m_base_force_mode << "\n";
        file << "torque_source=" << engine.m_torque_source << "\n";
        file << "flatspot_suppression=" << engine.m_flatspot_suppression << "\n";
        file << "notch_q=" << engine.m_notch_q << "\n";
        file << "flatspot_strength=" << engine.m_flatspot_strength << "\n";
        file << "static_notch_enabled=" << engine.m_static_notch_enabled << "\n";
        file << "static_notch_freq=" << engine.m_static_notch_freq << "\n";
        file << "static_notch_width=" << engine.m_static_notch_width << "\n";

        file << "\n; --- Rear Axle (Oversteer) ---\n";
        file << "oversteer_boost=" << engine.m_oversteer_boost << "\n";
        file << "dynamic_weight_gain=" << engine.m_dynamic_weight_gain << "\n";
        file << "dynamic_weight_smoothing=" << engine.m_dynamic_weight_smoothing << "\n";
        file << "grip_smoothing_steady=" << engine.m_grip_smoothing_steady << "\n";
        file << "grip_smoothing_fast=" << engine.m_grip_smoothing_fast << "\n";
        file << "grip_smoothing_sensitivity=" << engine.m_grip_smoothing_sensitivity << "\n";
        file << "sop=" << engine.m_sop_effect << "\n";
        file << "rear_align_effect=" << engine.m_rear_align_effect << "\n";
        file << "sop_yaw_gain=" << engine.m_sop_yaw_gain << "\n";
        file << "yaw_kick_threshold=" << engine.m_yaw_kick_threshold << "\n";
        file << "yaw_accel_smoothing=" << engine.m_yaw_accel_smoothing << "\n";
        file << "gyro_gain=" << engine.m_gyro_gain << "\n";
        file << "gyro_smoothing_factor=" << engine.m_gyro_smoothing << "\n";
        file << "sop_smoothing_factor=" << engine.m_sop_smoothing_factor << "\n";
        file << "sop_scale=" << engine.m_sop_scale << "\n";
        file << "understeer_affects_sop=" << engine.m_understeer_affects_sop << "\n";

        file << "\n; --- Physics (Grip & Slip Angle) ---\n";
        file << "slip_angle_smoothing=" << engine.m_slip_angle_smoothing << "\n";
        file << "chassis_inertia_smoothing=" << engine.m_chassis_inertia_smoothing << "\n";
        file << "optimal_slip_angle=" << engine.m_optimal_slip_angle << "\n";
        file << "optimal_slip_ratio=" << engine.m_optimal_slip_ratio << "\n";
        file << "slope_detection_enabled=" << engine.m_slope_detection_enabled << "\n";
        file << "slope_sg_window=" << engine.m_slope_sg_window << "\n";
        file << "slope_sensitivity=" << engine.m_slope_sensitivity << "\n";

        file << "slope_smoothing_tau=" << engine.m_slope_smoothing_tau << "\n";
        file << "slope_min_threshold=" << engine.m_slope_min_threshold << "\n";
        file << "slope_max_threshold=" << engine.m_slope_max_threshold << "\n";
        file << "slope_alpha_threshold=" << engine.m_slope_alpha_threshold << "\n";
        file << "slope_decay_rate=" << engine.m_slope_decay_rate << "\n";
        file << "slope_confidence_enabled=" << engine.m_slope_confidence_enabled << "\n";
        file << "slope_g_slew_limit=" << engine.m_slope_g_slew_limit << "\n";
        file << "slope_use_torque=" << (engine.m_slope_use_torque ? "1" : "0") << "\n";
        file << "slope_torque_sensitivity=" << engine.m_slope_torque_sensitivity << "\n";
        file << "slope_confidence_max_rate=" << engine.m_slope_confidence_max_rate << "\n";

        file << "\n; --- Braking & Lockup ---\n";
        file << "lockup_enabled=" << engine.m_lockup_enabled << "\n";
        file << "lockup_gain=" << engine.m_lockup_gain << "\n";
        file << "brake_load_cap=" << engine.m_brake_load_cap << "\n";
        file << "lockup_freq_scale=" << engine.m_lockup_freq_scale << "\n";
        file << "lockup_gamma=" << engine.m_lockup_gamma << "\n";
        file << "lockup_start_pct=" << engine.m_lockup_start_pct << "\n";
        file << "lockup_full_pct=" << engine.m_lockup_full_pct << "\n";
        file << "lockup_prediction_sens=" << engine.m_lockup_prediction_sens << "\n";
        file << "lockup_bump_reject=" << engine.m_lockup_bump_reject << "\n";
        file << "lockup_rear_boost=" << engine.m_lockup_rear_boost << "\n";
        file << "abs_pulse_enabled=" << engine.m_abs_pulse_enabled << "\n";
        file << "abs_gain=" << engine.m_abs_gain << "\n";
        file << "abs_freq=" << engine.m_abs_freq_hz << "\n";

        file << "\n; --- Tactile Textures ---\n";
        file << "texture_load_cap=" << engine.m_texture_load_cap << "\n";
        file << "slide_enabled=" << engine.m_slide_texture_enabled << "\n";
        file << "slide_gain=" << engine.m_slide_texture_gain << "\n";
        file << "slide_freq=" << engine.m_slide_freq_scale << "\n";
        file << "road_enabled=" << engine.m_road_texture_enabled << "\n";
        file << "road_gain=" << engine.m_road_texture_gain << "\n";
        file << "road_fallback_scale=" << engine.m_road_fallback_scale << "\n";
        file << "spin_enabled=" << engine.m_spin_enabled << "\n";
        file << "spin_gain=" << engine.m_spin_gain << "\n";
        file << "spin_freq_scale=" << engine.m_spin_freq_scale << "\n";
        file << "scrub_drag_gain=" << engine.m_scrub_drag_gain << "\n";
        file << "bottoming_method=" << engine.m_bottoming_method << "\n";

        file << "\n; --- Advanced Settings ---\n";
        file << "speed_gate_lower=" << engine.m_speed_gate_lower << "\n";
        file << "speed_gate_upper=" << engine.m_speed_gate_upper << "\n";

        file << "\n[Presets]\n";
        for (const auto& p : presets) {
            if (!p.is_builtin) {
                file << "[Preset:" << p.name << "]\n";
                WritePresetFields(file, p);
                file << "\n";
            }
        }
        
        file.close();

    } else {
        std::cerr << "[Config] Failed to save to " << final_path << std::endl;
    }
}

void Config::Load(FFBEngine& engine, const std::string& filename) {
    std::string final_path = filename.empty() ? m_config_path : filename;
    std::ifstream file(final_path);
    if (!file.is_open()) {
        std::cout << "[Config] No config found, using defaults." << std::endl;
        return;
    }

    std::string line;
    while (std::getline(file, line)) {
        // Strip whitespace and check for section headers
        line.erase(0, line.find_first_not_of(" \t\r\n"));
        if (line.empty() || line[0] == ';') continue;
        if (line[0] == '[') break; // Top-level settings end here (e.g. [Presets])

        std::istringstream is_line(line);
        std::string key;
        if (std::getline(is_line, key, '=')) {
            std::string value;
            if (std::getline(is_line, value)) {
                try {
                    if (key == "ini_version") {
                        // Config Version Tracking: This field records the app version that last saved the config.
                        // It serves as an implicit config format version for migration decisions.
                        // Current approach: Threshold-based detection (e.g., understeer > 2.0 = legacy format).
                        // Future improvement: Add explicit config_format_version field if migrations become
                        // more complex (e.g., structural changes, removed fields, renamed keys).
                        std::string config_version = value;
                        std::cout << "[Config] Loading config version: " << config_version << std::endl;
                    }
                    else if (key == "always_on_top") m_always_on_top = std::stoi(value);
                    else if (key == "last_device_guid") m_last_device_guid = value;
                    else if (key == "last_preset_name") m_last_preset_name = value;
                    // Window Geometry (v0.5.5)
                    else if (key == "win_pos_x") win_pos_x = std::stoi(value);
                    else if (key == "win_pos_y") win_pos_y = std::stoi(value);
                    else if (key == "win_w_small") win_w_small = std::stoi(value);
                    else if (key == "win_h_small") win_h_small = std::stoi(value);
                    else if (key == "win_w_large") win_w_large = std::stoi(value);
                    else if (key == "win_h_large") win_h_large = std::stoi(value);
                    else if (key == "show_graphs") show_graphs = std::stoi(value);
                    else if (key == "auto_start_logging") m_auto_start_logging = std::stoi(value);
                    else if (key == "log_path") m_log_path = value;
                    else if (key == "gain") engine.m_gain = std::stof(value);
                    else if (key == "sop_smoothing_factor") engine.m_sop_smoothing_factor = std::stof(value);
                    else if (key == "sop_scale") engine.m_sop_scale = std::stof(value);
                    else if (key == "slip_angle_smoothing") engine.m_slip_angle_smoothing = std::stof(value);
                    else if (key == "texture_load_cap") engine.m_texture_load_cap = std::stof(value);
                    else if (key == "max_load_factor") engine.m_texture_load_cap = std::stof(value); // Legacy Backward Compatibility
                    else if (key == "brake_load_cap") engine.m_brake_load_cap = std::stof(value);
                    else if (key == "smoothing") engine.m_sop_smoothing_factor = std::stof(value); // Legacy support
                    else if (key == "understeer") engine.m_understeer_effect = std::stof(value);
                    else if (key == "base_force_mode") engine.m_base_force_mode = std::stoi(value);
                    else if (key == "torque_source") engine.m_torque_source = std::stoi(value);
                    else if (key == "sop") engine.m_sop_effect = std::stof(value);
                    else if (key == "min_force") engine.m_min_force = std::stof(value);
                    else if (key == "oversteer_boost") engine.m_oversteer_boost = std::stof(value);
                    else if (key == "dynamic_weight_gain") engine.m_dynamic_weight_gain = std::stof(value);
                    else if (key == "dynamic_weight_smoothing") engine.m_dynamic_weight_smoothing = std::stof(value);
                    else if (key == "grip_smoothing_steady") engine.m_grip_smoothing_steady = std::stof(value);
                    else if (key == "grip_smoothing_fast") engine.m_grip_smoothing_fast = std::stof(value);
                    else if (key == "grip_smoothing_sensitivity") engine.m_grip_smoothing_sensitivity = std::stof(value);
                    // v0.4.50: SAFETY CLAMPING for Generator Effects (Gain Compensation Migration)
                    // Legacy configs may have high gains (e.g., 5.0) to compensate for lack of auto-scaling.
                    // With new decoupling, these would cause 25x force explosions. Clamp to safe maximums.
                    else if (key == "lockup_enabled") engine.m_lockup_enabled = std::stoi(value);
                    else if (key == "lockup_gain") engine.m_lockup_gain = std::stof(value);
                    else if (key == "lockup_start_pct") engine.m_lockup_start_pct = std::stof(value);
                    else if (key == "lockup_full_pct") engine.m_lockup_full_pct = std::stof(value);
                    else if (key == "lockup_rear_boost") engine.m_lockup_rear_boost = std::stof(value);
                    else if (key == "lockup_gamma") engine.m_lockup_gamma = std::stof(value);
                    else if (key == "lockup_prediction_sens") engine.m_lockup_prediction_sens = std::stof(value);
                    else if (key == "lockup_bump_reject") engine.m_lockup_bump_reject = std::stof(value);
                    else if (key == "abs_pulse_enabled") engine.m_abs_pulse_enabled = std::stoi(value);
                    else if (key == "abs_gain") engine.m_abs_gain = std::stof(value);
                    else if (key == "spin_enabled") engine.m_spin_enabled = std::stoi(value);
                    else if (key == "spin_gain") engine.m_spin_gain = std::stof(value);
                    else if (key == "slide_enabled") engine.m_slide_texture_enabled = std::stoi(value);
                    else if (key == "slide_gain") engine.m_slide_texture_gain = std::stof(value);
                    else if (key == "slide_freq") engine.m_slide_freq_scale = std::stof(value);
                    else if (key == "road_enabled") engine.m_road_texture_enabled = std::stoi(value);
                    else if (key == "road_gain") engine.m_road_texture_gain = std::stof(value);
                    else if (key == "invert_force") engine.m_invert_force = std::stoi(value);
                    else if (key == "max_torque_ref") engine.m_max_torque_ref = std::stof(value);
                    else if (key == "abs_freq") engine.m_abs_freq_hz = std::stof(value);
                    else if (key == "lockup_freq_scale") engine.m_lockup_freq_scale = std::stof(value);
                    else if (key == "spin_freq_scale") engine.m_spin_freq_scale = std::stof(value);
                    else if (key == "bottoming_method") engine.m_bottoming_method = std::stoi(value);
                    else if (key == "scrub_drag_gain") engine.m_scrub_drag_gain = (std::min)(1.0f, std::stof(value));
                    else if (key == "rear_align_effect") engine.m_rear_align_effect = std::stof(value);
                    else if (key == "sop_yaw_gain") engine.m_sop_yaw_gain = std::stof(value);
                    else if (key == "steering_shaft_gain") engine.m_steering_shaft_gain = std::stof(value);
                    else if (key == "base_force_mode") engine.m_base_force_mode = std::stoi(value);
                    else if (key == "gyro_gain") engine.m_gyro_gain = (std::min)(1.0f, std::stof(value));
                    else if (key == "flatspot_suppression") engine.m_flatspot_suppression = std::stoi(value);
                    else if (key == "notch_q") engine.m_notch_q = std::stof(value);
                    else if (key == "flatspot_strength") engine.m_flatspot_strength = std::stof(value);
                    else if (key == "static_notch_enabled") engine.m_static_notch_enabled = std::stoi(value);
                    else if (key == "static_notch_freq") engine.m_static_notch_freq = std::stof(value);
                    else if (key == "static_notch_width") engine.m_static_notch_width = std::stof(value);
                    else if (key == "yaw_kick_threshold") engine.m_yaw_kick_threshold = std::stof(value);
                    else if (key == "optimal_slip_angle") engine.m_optimal_slip_angle = std::stof(value);
                    else if (key == "optimal_slip_ratio") engine.m_optimal_slip_ratio = std::stof(value);
                    else if (key == "slope_detection_enabled") engine.m_slope_detection_enabled = (value == "1");
                    else if (key == "slope_sg_window") engine.m_slope_sg_window = std::stoi(value);
                    else if (key == "slope_sensitivity") engine.m_slope_sensitivity = std::stof(value);
                    else if (key == "slope_negative_threshold") engine.m_slope_min_threshold = std::stof(value);
                    else if (key == "slope_smoothing_tau") engine.m_slope_smoothing_tau = std::stof(value);
                    else if (key == "slope_min_threshold") engine.m_slope_min_threshold = std::stof(value);
                    else if (key == "slope_max_threshold") engine.m_slope_max_threshold = std::stof(value);
                    else if (key == "slope_alpha_threshold") engine.m_slope_alpha_threshold = std::stof(value);
                    else if (key == "slope_decay_rate") engine.m_slope_decay_rate = std::stof(value);
                    else if (key == "slope_confidence_enabled") engine.m_slope_confidence_enabled = (value == "1");
                    else if (key == "steering_shaft_smoothing") engine.m_steering_shaft_smoothing = std::stof(value);
                    else if (key == "gyro_smoothing_factor") engine.m_gyro_smoothing = std::stof(value);
                    else if (key == "yaw_accel_smoothing") engine.m_yaw_accel_smoothing = std::stof(value);
                    else if (key == "chassis_inertia_smoothing") engine.m_chassis_inertia_smoothing = std::stof(value);
                    else if (key == "speed_gate_lower") engine.m_speed_gate_lower = std::stof(value); // NEW v0.6.25
                    else if (key == "speed_gate_upper") engine.m_speed_gate_upper = std::stof(value); // NEW v0.6.25
                    else if (key == "road_fallback_scale") engine.m_road_fallback_scale = std::stof(value); // NEW v0.6.25
                    else if (key == "understeer_affects_sop") engine.m_understeer_affects_sop = std::stoi(value); // NEW v0.6.25
                    else if (key == "slope_g_slew_limit") engine.m_slope_g_slew_limit = std::stof(value); // NEW v0.7.40
                    else if (key == "slope_use_torque") engine.m_slope_use_torque = (value == "1"); // NEW v0.7.40
                    else if (key == "slope_torque_sensitivity") engine.m_slope_torque_sensitivity = std::stof(value); // NEW v0.7.40
                    else if (key == "slope_confidence_max_rate") engine.m_slope_confidence_max_rate = std::stof(value); // NEW v0.7.42
                } catch (...) {
                    std::cerr << "[Config] Error parsing line: " << line << std::endl;
                }
            }
        }
    }
    
    // v0.7.16: Comprehensive Safety Validation & Clamping
    // These checks ensure that even if config.ini is manually edited with invalid values,
    // the engine remains stable and doesn't crash or produce NaN.

    engine.m_gain = (std::max)(0.0f, engine.m_gain);
    engine.m_max_torque_ref = (std::max)(1.0f, engine.m_max_torque_ref);
    engine.m_min_force = (std::max)(0.0f, engine.m_min_force);
    engine.m_sop_scale = (std::max)(0.01f, engine.m_sop_scale);
    engine.m_slip_angle_smoothing = (std::max)(0.0001f, engine.m_slip_angle_smoothing);
    engine.m_notch_q = (std::max)(0.1f, engine.m_notch_q);
    engine.m_static_notch_width = (std::max)(0.1f, engine.m_static_notch_width);
    engine.m_speed_gate_upper = (std::max)(0.1f, engine.m_speed_gate_upper);

    engine.m_torque_source = (std::max)(0, (std::min)(1, engine.m_torque_source));

    if (engine.m_optimal_slip_angle < 0.01f) {
        std::cerr << "[Config] Invalid optimal_slip_angle (" << engine.m_optimal_slip_angle 
                  << "), resetting to default 0.10" << std::endl;
        engine.m_optimal_slip_angle = 0.10f;
    }
    if (engine.m_optimal_slip_ratio < 0.01f) {
        std::cerr << "[Config] Invalid optimal_slip_ratio (" << engine.m_optimal_slip_ratio 
                  << "), resetting to default 0.12" << std::endl;
        engine.m_optimal_slip_ratio = 0.12f;
    }
    
    // Slope Detection Validation
    if (engine.m_slope_sg_window < 5) engine.m_slope_sg_window = 5;
    if (engine.m_slope_sg_window > 41) engine.m_slope_sg_window = 41;
    if (engine.m_slope_sg_window % 2 == 0) engine.m_slope_sg_window++; // Must be odd
    if (engine.m_slope_sensitivity < 0.1f) engine.m_slope_sensitivity = 0.1f;
    if (engine.m_slope_sensitivity > 10.0f) engine.m_slope_sensitivity = 10.0f;
    if (engine.m_slope_smoothing_tau < 0.001f) engine.m_slope_smoothing_tau = 0.04f;
    
    if (engine.m_slope_alpha_threshold < 0.001f || engine.m_slope_alpha_threshold > 0.1f) {
        std::cerr << "[Config] Invalid slope_alpha_threshold (" << engine.m_slope_alpha_threshold 
                  << "), resetting to 0.02f" << std::endl;
        engine.m_slope_alpha_threshold = 0.02f;
    }
    if (engine.m_slope_decay_rate < 0.1f || engine.m_slope_decay_rate > 20.0f) {
        std::cerr << "[Config] Invalid slope_decay_rate (" << engine.m_slope_decay_rate 
                  << "), resetting to 5.0f" << std::endl;
        engine.m_slope_decay_rate = 5.0f;
    }

    // Advanced Slope Validation (v0.7.40)
    engine.m_slope_g_slew_limit = (std::max)(1.0f, (std::min)(1000.0f, engine.m_slope_g_slew_limit));
    engine.m_slope_torque_sensitivity = (std::max)(0.01f, (std::min)(10.0f, engine.m_slope_torque_sensitivity));
    engine.m_slope_confidence_max_rate = (std::max)(engine.m_slope_alpha_threshold + 0.01f, (std::min)(1.0f, engine.m_slope_confidence_max_rate));

    // Migration: v0.7.x sensitivity â†’ v0.7.11 thresholds
    // If loading old config with sensitivity but at default thresholds
    if (engine.m_slope_min_threshold == -0.3f && 
        engine.m_slope_max_threshold == -2.0f &&
        engine.m_slope_sensitivity != 0.5f) {
        
        // Old formula: factor = 1 - (excess * 0.1 * sens)
        // At factor=0.2 (floor): excess * 0.1 * sens = 0.8
        // excess = 0.8 / (0.1 * sens) = 8 / sens
        // max = min - excess = -0.3 - (8/sens)
        double sens = (double)engine.m_slope_sensitivity;
        if (sens > 0.01) {
            engine.m_slope_max_threshold = (float)(engine.m_slope_min_threshold - (8.0 / sens));
            std::cout << "[Config] Migrated slope_sensitivity " << sens 
                      << " to max_threshold " << engine.m_slope_max_threshold << std::endl;
        }
    }

    // Validation: max should be more negative than min
    if (engine.m_slope_max_threshold > engine.m_slope_min_threshold) {
        std::swap(engine.m_slope_min_threshold, engine.m_slope_max_threshold);
        std::cout << "[Config] Swapped slope thresholds (min should be > max)" << std::endl;
    }
    
    // v0.6.20: Safety Validation - Clamp Advanced Braking Parameters to Valid Ranges
    if (engine.m_lockup_gamma < 0.1f || engine.m_lockup_gamma > 4.0f) {
        std::cerr << "[Config] Invalid lockup_gamma (" << engine.m_lockup_gamma 
                  << "), clamping to range [0.1, 4.0]" << std::endl;
        engine.m_lockup_gamma = (std::max)(0.1f, (std::min)(4.0f, engine.m_lockup_gamma));
    }
    if (engine.m_lockup_prediction_sens < 10.0f || engine.m_lockup_prediction_sens > 100.0f) {
        std::cerr << "[Config] Invalid lockup_prediction_sens (" << engine.m_lockup_prediction_sens 
                  << "), clamping to range [10.0, 100.0]" << std::endl;
        engine.m_lockup_prediction_sens = (std::max)(10.0f, (std::min)(100.0f, engine.m_lockup_prediction_sens));
    }
    if (engine.m_lockup_bump_reject < 0.1f || engine.m_lockup_bump_reject > 5.0f) {
        std::cerr << "[Config] Invalid lockup_bump_reject (" << engine.m_lockup_bump_reject 
                  << "), clamping to range [0.1, 5.0]" << std::endl;
        engine.m_lockup_bump_reject = (std::max)(0.1f, (std::min)(5.0f, engine.m_lockup_bump_reject));
    }
    if (engine.m_abs_gain < 0.0f || engine.m_abs_gain > 10.0f) {
        std::cerr << "[Config] Invalid abs_gain (" << engine.m_abs_gain 
                  << "), clamping to range [0.0, 10.0]" << std::endl;
        engine.m_abs_gain = (std::max)(0.0f, (std::min)(10.0f, engine.m_abs_gain));
    }
    // Legacy Migration: Convert 0-200 range to 0-2.0 range
    if (engine.m_understeer_effect > 2.0f) {
        float old_val = engine.m_understeer_effect;
        engine.m_understeer_effect = engine.m_understeer_effect / 100.0f;
        std::cout << "[Config] Migrated legacy understeer_effect: " << old_val 
                  << " -> " << engine.m_understeer_effect << std::endl;
    }
    // Clamp to new valid range [0.0, 2.0]
    if (engine.m_understeer_effect < 0.0f || engine.m_understeer_effect > 2.0f) {
        engine.m_understeer_effect = (std::max)(0.0f, (std::min)(2.0f, engine.m_understeer_effect));
    }
    if (engine.m_steering_shaft_gain < 0.0f || engine.m_steering_shaft_gain > 2.0f) {
        engine.m_steering_shaft_gain = (std::max)(0.0f, (std::min)(2.0f, engine.m_steering_shaft_gain));
    }
    if (engine.m_lockup_gain < 0.0f || engine.m_lockup_gain > 3.0f) {
        engine.m_lockup_gain = (std::max)(0.0f, (std::min)(3.0f, engine.m_lockup_gain));
    }
    if (engine.m_brake_load_cap < 1.0f || engine.m_brake_load_cap > 10.0f) {
        engine.m_brake_load_cap = (std::max)(1.0f, (std::min)(10.0f, engine.m_brake_load_cap));
    }
    if (engine.m_lockup_rear_boost < 1.0f || engine.m_lockup_rear_boost > 10.0f) {
        engine.m_lockup_rear_boost = (std::max)(1.0f, (std::min)(10.0f, engine.m_lockup_rear_boost));
    }
    if (engine.m_oversteer_boost < 0.0f || engine.m_oversteer_boost > 4.0f) {
        engine.m_oversteer_boost = (std::max)(0.0f, (std::min)(4.0f, engine.m_oversteer_boost));
    }
    if (engine.m_sop_yaw_gain < 0.0f || engine.m_sop_yaw_gain > 1.0f) {
         engine.m_sop_yaw_gain = (std::max)(0.0f, (std::min)(1.0f, engine.m_sop_yaw_gain));
    }
    if (engine.m_slide_texture_gain < 0.0f || engine.m_slide_texture_gain > 2.0f) {
        engine.m_slide_texture_gain = (std::max)(0.0f, (std::min)(2.0f, engine.m_slide_texture_gain));
    }
    if (engine.m_road_texture_gain < 0.0f || engine.m_road_texture_gain > 2.0f) {
        engine.m_road_texture_gain = (std::max)(0.0f, (std::min)(2.0f, engine.m_road_texture_gain));
    }
    if (engine.m_spin_gain < 0.0f || engine.m_spin_gain > 2.0f) {
        engine.m_spin_gain = (std::max)(0.0f, (std::min)(2.0f, engine.m_spin_gain));
    }
    if (engine.m_rear_align_effect < 0.0f || engine.m_rear_align_effect > 2.0f) {
        engine.m_rear_align_effect = (std::max)(0.0f, (std::min)(2.0f, engine.m_rear_align_effect));
    }
    if (engine.m_sop_effect < 0.0f || engine.m_sop_effect > 2.0f) {
        engine.m_sop_effect = (std::max)(0.0f, (std::min)(2.0f, engine.m_sop_effect));
    }
    std::cout << "[Config] Loaded from " << filename << std::endl;
}










```

# File: src\Config.h
```cpp
﻿#ifndef CONFIG_H
#define CONFIG_H

#include "FFBEngine.h"
#include <string>
#include <vector>
#include <chrono>
#include "Version.h"

struct Preset {
    std::string name;
    bool is_builtin = false;
    std::string app_version = LMUFFB_VERSION; // NEW: Track if this is hardcoded or user-created
    
    // 1. SINGLE SOURCE OF TRUTH: Default Preset Values
    // These defaults are used by:
    // - FFBEngine constructor (via ApplyDefaultsToEngine)
    // - "Default" preset in LoadPresets()
    // - "Reset Defaults" button in GUI
    // - Test presets that don't explicitly set these values
    //
    // âš ï¸ IMPORTANT: When changing these defaults, you MUST also update:
    // 1. SetAdvancedBraking() default parameters below (abs_f, lockup_f)
    // 2. test_ffb_engine.cpp: expected_abs_freq and expected_lockup_freq_scale
    // 3. Any test presets in Config.cpp that rely on these defaults
    //
    // Current defaults match: GT3 DD 15 Nm (Simagic Alpha) - v0.6.35
   float gain = 1.0f;
    float understeer = 1.0f;  // New scale: 0.0-2.0, where 1.0 = proportional
    float sop = 1.666f;
    float sop_scale = 1.0f;
    float sop_smoothing = 1.0f;
    float slip_smoothing = 0.002f;
    float min_force = 0.0f;
    float oversteer_boost = 2.52101f;
    float dynamic_weight_gain = 0.0f; // NEW v0.7.46
    float dynamic_weight_smoothing = 0.15f; // v0.7.47
    float grip_smoothing_steady = 0.05f;    // v0.7.47
    float grip_smoothing_fast = 0.005f;     // v0.7.47
    float grip_smoothing_sensitivity = 0.1f; // v0.7.47
    
    bool lockup_enabled = true;
    float lockup_gain = 0.37479f;
    float lockup_start_pct = 1.0f;  // New v0.5.11
    float lockup_full_pct = 5.0f;  // New v0.5.11
    float lockup_rear_boost = 10.0f; // New v0.5.11
    float lockup_gamma = 0.1f;           // New v0.6.0
    float lockup_prediction_sens = 10.0f; // New v0.6.0
    float lockup_bump_reject = 0.1f;     // New v0.6.0
    float brake_load_cap = 2.0f;    // New v0.5.11
    float texture_load_cap = 1.5f;  // NEW v0.6.25
    
    bool abs_pulse_enabled = false;       // New v0.6.0
    float abs_gain = 2.0f;               // New v0.6.0
    float abs_freq = 25.5f;              // New v0.6.20
    
    bool spin_enabled = true;
    float spin_gain = 0.5f;
    float spin_freq_scale = 1.0f;        // New v0.6.20
    
    bool slide_enabled = false;
    float slide_gain = 0.226562f;
    float slide_freq = 1.0f;
    
    bool road_enabled = true;
    float road_gain = 0.0f;
    
    bool invert_force = true;
    float max_torque_ref = 100.0f; // T300 Calibrated
    
    float lockup_freq_scale = 1.02f;      // New v0.6.20
    int bottoming_method = 0;
    float scrub_drag_gain = 0.0f;
    
    float rear_align_effect = 0.666f;
    float sop_yaw_gain = 0.333f;
    float gyro_gain = 0.0f;
    
    float steering_shaft_gain = 1.0f;
    int base_force_mode = 0; // 0=Native
    int torque_source = 0;   // 0=Shaft, 1=Direct
    
    // NEW: Grip & Smoothing (v0.5.7)
    float optimal_slip_angle = 0.1f;
    float optimal_slip_ratio = 0.12f;
    float steering_shaft_smoothing = 0.0f;
    
    // NEW: Advanced Smoothing (v0.5.8)
    float gyro_smoothing = 0.0f;
    float yaw_smoothing = 0.001f;
    float chassis_smoothing = 0.0f;

    // v0.4.41: Signal Filtering
    bool flatspot_suppression = false;
    float notch_q = 2.0f;
    float flatspot_strength = 1.0f;
    
    bool static_notch_enabled = false;
    float static_notch_freq = 11.0f;
    float static_notch_width = 2.0f; // New v0.6.10
    float yaw_kick_threshold = 0.0f; // New v0.6.10

    // v0.6.23 New Settings with HIGHER DEFAULTS
    float speed_gate_lower = 1.0f; // 3.6 km/h
    float speed_gate_upper = 5.0f; // 18.0 km/h (Fixes idle shake)
    
    // Reserved for future implementation (v0.6.23+)
    float road_fallback_scale = 0.05f;      // Planned: Road texture fallback scaling
    bool understeer_affects_sop = false;     // Planned: Understeer modulation of SoP

    // ===== SLOPE DETECTION (v0.7.0 â†’ v0.7.1 defaults) =====
    bool slope_detection_enabled = false;
    int slope_sg_window = 15;
    float slope_sensitivity = 0.5f;          // Reduced from 1.0 (less aggressive)

    float slope_smoothing_tau = 0.04f;       // Changed from 0.02 (smoother transitions)

    // v0.7.3: Slope detection stability fixes
    float slope_alpha_threshold = 0.02f;
    float slope_decay_rate = 5.0f;
    bool slope_confidence_enabled = true;

    // v0.7.11: Min/Max Threshold System
    float slope_min_threshold = -0.3f;
    float slope_max_threshold = -2.0f;

    // NEW v0.7.40: Advanced Slope Settings
    float slope_g_slew_limit = 50.0f;
    bool slope_use_torque = true;
    float slope_torque_sensitivity = 0.5f;
    float slope_confidence_max_rate = 0.10f;

    // 2. Constructors
    Preset(std::string n, bool builtin = false) : name(n), is_builtin(builtin), app_version(LMUFFB_VERSION) {}
    Preset() : name("Unnamed"), is_builtin(false), app_version(LMUFFB_VERSION) {} // Default constructor for file loading

    // 3. Fluent Setters (The "Python Dictionary" feel)
    Preset& SetGain(float v) { gain = v; return *this; }
    Preset& SetUndersteer(float v) { understeer = v; return *this; }
    Preset& SetSoP(float v) { sop = v; return *this; }
    Preset& SetSoPScale(float v) { sop_scale = v; return *this; }
    Preset& SetSmoothing(float v) { sop_smoothing = v; return *this; }
    Preset& SetMinForce(float v) { min_force = v; return *this; }
    Preset& SetOversteer(float v) { oversteer_boost = v; return *this; }
    Preset& SetDynamicWeight(float v) { dynamic_weight_gain = v; return *this; }
    Preset& SetDynamicWeightSmoothing(float v) { dynamic_weight_smoothing = v; return *this; }
    Preset& SetGripSmoothing(float steady, float fast, float sens) {
        grip_smoothing_steady = steady;
        grip_smoothing_fast = fast;
        grip_smoothing_sensitivity = sens;
        return *this;
    }
    Preset& SetSlipSmoothing(float v) { slip_smoothing = v; return *this; }
    
    Preset& SetLockup(bool enabled, float g, float start = 5.0f, float full = 15.0f, float boost = 1.5f) { 
        lockup_enabled = enabled; 
        lockup_gain = g; 
        lockup_start_pct = start;
        lockup_full_pct = full;
        lockup_rear_boost = boost;
        return *this; 
    }
    Preset& SetBrakeCap(float v) { brake_load_cap = v; return *this; }
    Preset& SetSpin(bool enabled, float g, float scale = 1.0f) { 
        spin_enabled = enabled; 
        spin_gain = g; 
        spin_freq_scale = scale;
        return *this; 
    }
    Preset& SetSlide(bool enabled, float g, float f = 1.0f) { 
        slide_enabled = enabled; 
        slide_gain = g; 
        slide_freq = f; 
        return *this; 
    }
    Preset& SetRoad(bool enabled, float g) { road_enabled = enabled; road_gain = g; return *this; }
    
    Preset& SetInvert(bool v) { invert_force = v; return *this; }
    Preset& SetMaxTorque(float v) { max_torque_ref = v; return *this; }
    
    Preset& SetBottoming(int method) { bottoming_method = method; return *this; }
    Preset& SetScrub(float v) { scrub_drag_gain = v; return *this; }
    Preset& SetRearAlign(float v) { rear_align_effect = v; return *this; }
    Preset& SetSoPYaw(float v) { sop_yaw_gain = v; return *this; }
    Preset& SetGyro(float v) { gyro_gain = v; return *this; }
    
    Preset& SetShaftGain(float v) { steering_shaft_gain = v; return *this; }
    Preset& SetBaseMode(int v) { base_force_mode = v; return *this; }
    Preset& SetTorqueSource(int v) { torque_source = v; return *this; }
    Preset& SetFlatspot(bool enabled, float strength = 1.0f, float q = 2.0f) { 
        flatspot_suppression = enabled; 
        flatspot_strength = strength;
        notch_q = q; 
        return *this; 
    }
    
    Preset& SetStaticNotch(bool enabled, float freq, float width = 2.0f) {
        static_notch_enabled = enabled;
        static_notch_freq = freq;
        static_notch_width = width;
        return *this;
    }
    Preset& SetYawKickThreshold(float v) { yaw_kick_threshold = v; return *this; }
    Preset& SetSpeedGate(float lower, float upper) { speed_gate_lower = lower; speed_gate_upper = upper; return *this; }

    Preset& SetOptimalSlip(float angle, float ratio) {
        optimal_slip_angle = angle;
        optimal_slip_ratio = ratio;
        return *this;
    }
    Preset& SetShaftSmoothing(float v) { steering_shaft_smoothing = v; return *this; }
    
    Preset& SetGyroSmoothing(float v) { gyro_smoothing = v; return *this; }
    Preset& SetYawSmoothing(float v) { yaw_smoothing = v; return *this; }
    Preset& SetChassisSmoothing(float v) { chassis_smoothing = v; return *this; }
    
    Preset& SetSlopeDetection(bool enabled, int window = 15, float min_thresh = -0.3f, float max_thresh = -2.0f, float tau = 0.04f) {
        slope_detection_enabled = enabled;
        slope_sg_window = window;
        slope_min_threshold = min_thresh;
        slope_max_threshold = max_thresh;
        slope_smoothing_tau = tau;
        return *this;
    }

    Preset& SetSlopeStability(float alpha_thresh = 0.02f, float decay = 5.0f, bool conf = true) {
        slope_alpha_threshold = alpha_thresh;
        slope_decay_rate = decay;
        slope_confidence_enabled = conf;
        return *this;
    }

    Preset& SetSlopeAdvanced(float slew = 50.0f, bool use_torque = true, float torque_sens = 0.5f) {
        slope_g_slew_limit = slew;
        slope_use_torque = use_torque;
        slope_torque_sensitivity = torque_sens;
        return *this;
    }

    // Advanced Braking (v0.6.0)
    // âš ï¸ IMPORTANT: Default parameters (abs_f, lockup_f) must match Config.h defaults!
    // When changing Config.h defaults, update these values to match.
    // Current: abs_f=25.5, lockup_f=1.02 (GT3 DD 15 Nm defaults - v0.6.35)
    Preset& SetAdvancedBraking(float gamma, float sens, float bump, bool abs, float abs_g, float abs_f = 25.5f, float lockup_f = 1.02f) {
        lockup_gamma = gamma;
        lockup_prediction_sens = sens;
        lockup_bump_reject = bump;
        abs_pulse_enabled = abs;
        abs_gain = abs_g;
        abs_freq = abs_f;
        lockup_freq_scale = lockup_f;
        return *this;
    }

    // 4. Static method to apply defaults to FFBEngine (Single Source of Truth)
    // This is called by FFBEngine constructor to initialize with T300 defaults
    static void ApplyDefaultsToEngine(FFBEngine& engine) {
        Preset defaults; // Uses default member initializers (T300 values)
        defaults.Apply(engine);
    }

    // Apply this preset to an engine instance
    // v0.7.16: Added comprehensive safety clamping to prevent crashes/NaN from invalid config values
    void Apply(FFBEngine& engine) const {
        engine.m_gain = (std::max)(0.0f, gain);
        engine.m_understeer_effect = (std::max)(0.0f, (std::min)(2.0f, understeer));
        engine.m_sop_effect = (std::max)(0.0f, (std::min)(2.0f, sop));
        engine.m_sop_scale = (std::max)(0.01f, sop_scale);
        engine.m_sop_smoothing_factor = (std::max)(0.0f, (std::min)(1.0f, sop_smoothing));
        engine.m_slip_angle_smoothing = (std::max)(0.0001f, slip_smoothing);
        engine.m_min_force = (std::max)(0.0f, min_force);
        engine.m_oversteer_boost = (std::max)(0.0f, oversteer_boost);
        engine.m_dynamic_weight_gain = (std::max)(0.0f, (std::min)(2.0f, dynamic_weight_gain));
        engine.m_dynamic_weight_smoothing = (std::max)(0.0f, dynamic_weight_smoothing);
        engine.m_grip_smoothing_steady = (std::max)(0.0f, grip_smoothing_steady);
        engine.m_grip_smoothing_fast = (std::max)(0.0f, grip_smoothing_fast);
        engine.m_grip_smoothing_sensitivity = (std::max)(0.001f, grip_smoothing_sensitivity);

        engine.m_lockup_enabled = lockup_enabled;
        engine.m_lockup_gain = (std::max)(0.0f, lockup_gain);
        engine.m_lockup_start_pct = (std::max)(0.1f, lockup_start_pct);
        engine.m_lockup_full_pct = (std::max)(0.2f, lockup_full_pct);
        engine.m_lockup_rear_boost = (std::max)(0.0f, lockup_rear_boost);
        engine.m_lockup_gamma = (std::max)(0.1f, lockup_gamma); // Critical: prevent pow(0, negative) crash
        engine.m_lockup_prediction_sens = (std::max)(1.0f, lockup_prediction_sens);
        engine.m_lockup_bump_reject = (std::max)(0.01f, lockup_bump_reject);
        engine.m_brake_load_cap = (std::max)(1.0f, brake_load_cap);
        engine.m_texture_load_cap = (std::max)(1.0f, texture_load_cap);

        engine.m_abs_pulse_enabled = abs_pulse_enabled;
        engine.m_abs_gain = (std::max)(0.0f, abs_gain);

        engine.m_spin_enabled = spin_enabled;
        engine.m_spin_gain = (std::max)(0.0f, spin_gain);
        engine.m_slide_texture_enabled = slide_enabled;
        engine.m_slide_texture_gain = (std::max)(0.0f, slide_gain);
        engine.m_slide_freq_scale = (std::max)(0.1f, slide_freq);
        engine.m_road_texture_enabled = road_enabled;
        engine.m_road_texture_gain = (std::max)(0.0f, road_gain);
        engine.m_invert_force = invert_force;
        engine.m_max_torque_ref = (std::max)(1.0f, max_torque_ref); // Critical for normalization division
        engine.m_abs_freq_hz = (std::max)(1.0f, abs_freq);
        engine.m_lockup_freq_scale = (std::max)(0.1f, lockup_freq_scale);
        engine.m_spin_freq_scale = (std::max)(0.1f, spin_freq_scale);
        engine.m_bottoming_method = bottoming_method;
        engine.m_scrub_drag_gain = (std::max)(0.0f, scrub_drag_gain);
        engine.m_rear_align_effect = (std::max)(0.0f, rear_align_effect);
        engine.m_sop_yaw_gain = (std::max)(0.0f, sop_yaw_gain);
        engine.m_gyro_gain = (std::max)(0.0f, gyro_gain);
        engine.m_steering_shaft_gain = (std::max)(0.0f, steering_shaft_gain);
        engine.m_base_force_mode = base_force_mode;
        engine.m_torque_source = torque_source;
        engine.m_flatspot_suppression = flatspot_suppression;
        engine.m_notch_q = (std::max)(0.1f, notch_q); // Critical for biquad division
        engine.m_flatspot_strength = (std::max)(0.0f, (std::min)(1.0f, flatspot_strength));
        engine.m_static_notch_enabled = static_notch_enabled;
        engine.m_static_notch_freq = (std::max)(1.0f, static_notch_freq);
        engine.m_static_notch_width = (std::max)(0.1f, static_notch_width);
        engine.m_yaw_kick_threshold = (std::max)(0.0f, yaw_kick_threshold);
        engine.m_speed_gate_lower = (std::max)(0.0f, speed_gate_lower);
        engine.m_speed_gate_upper = (std::max)(0.1f, speed_gate_upper);
        
        // NEW: Grip & Smoothing (v0.5.7/v0.5.8)
        engine.m_optimal_slip_angle = (std::max)(0.01f, optimal_slip_angle); // Critical for grip division
        engine.m_optimal_slip_ratio = (std::max)(0.01f, optimal_slip_ratio); // Critical for grip division
        engine.m_steering_shaft_smoothing = (std::max)(0.0f, steering_shaft_smoothing);
        engine.m_gyro_smoothing = (std::max)(0.0f, gyro_smoothing);
        engine.m_yaw_accel_smoothing = (std::max)(0.0f, yaw_smoothing);
        engine.m_chassis_inertia_smoothing = (std::max)(0.0f, chassis_smoothing);
        engine.m_road_fallback_scale = (std::max)(0.0f, road_fallback_scale);
        engine.m_understeer_affects_sop = understeer_affects_sop;
        
        // Slope Detection (v0.7.0)
        engine.m_slope_detection_enabled = slope_detection_enabled;
        engine.m_slope_sg_window = (std::max)(5, (std::min)(41, slope_sg_window));
        if (engine.m_slope_sg_window % 2 == 0) engine.m_slope_sg_window++; // Must be odd for SG
        engine.m_slope_sensitivity = (std::max)(0.1f, slope_sensitivity);

        engine.m_slope_smoothing_tau = (std::max)(0.001f, slope_smoothing_tau);

        // v0.7.3: Slope stability fixes
        engine.m_slope_alpha_threshold = (std::max)(0.001f, slope_alpha_threshold); // Critical for slope division
        engine.m_slope_decay_rate = (std::max)(0.1f, slope_decay_rate);
        engine.m_slope_confidence_enabled = slope_confidence_enabled;
        engine.m_slope_confidence_max_rate = (std::max)(engine.m_slope_alpha_threshold + 0.01f, slope_confidence_max_rate);

        // v0.7.11: Min/Max thresholds
        engine.m_slope_min_threshold = slope_min_threshold;
        engine.m_slope_max_threshold = slope_max_threshold;

        // NEW v0.7.40: Advanced Slope Settings
        engine.m_slope_g_slew_limit = (std::max)(1.0f, slope_g_slew_limit);
        engine.m_slope_use_torque = slope_use_torque;
        engine.m_slope_torque_sensitivity = (std::max)(0.01f, slope_torque_sensitivity);
    }

    // NEW: Ensure values are within safe ranges (v0.7.16)
    void Validate() {
        gain = (std::max)(0.0f, gain);
        understeer = (std::max)(0.0f, (std::min)(2.0f, understeer));
        sop = (std::max)(0.0f, (std::min)(2.0f, sop));
        sop_scale = (std::max)(0.01f, sop_scale);
        sop_smoothing = (std::max)(0.0f, (std::min)(1.0f, sop_smoothing));
        slip_smoothing = (std::max)(0.0001f, slip_smoothing);
        min_force = (std::max)(0.0f, min_force);
        oversteer_boost = (std::max)(0.0f, oversteer_boost);
        dynamic_weight_gain = (std::max)(0.0f, (std::min)(2.0f, dynamic_weight_gain));
        dynamic_weight_smoothing = (std::max)(0.0f, dynamic_weight_smoothing);
        grip_smoothing_steady = (std::max)(0.0f, grip_smoothing_steady);
        grip_smoothing_fast = (std::max)(0.0f, grip_smoothing_fast);
        grip_smoothing_sensitivity = (std::max)(0.001f, grip_smoothing_sensitivity);
        lockup_gain = (std::max)(0.0f, lockup_gain);
        lockup_start_pct = (std::max)(0.1f, lockup_start_pct);
        lockup_full_pct = (std::max)(0.2f, lockup_full_pct);
        lockup_rear_boost = (std::max)(0.0f, lockup_rear_boost);
        lockup_gamma = (std::max)(0.1f, lockup_gamma);
        lockup_prediction_sens = (std::max)(1.0f, lockup_prediction_sens);
        lockup_bump_reject = (std::max)(0.01f, lockup_bump_reject);
        brake_load_cap = (std::max)(1.0f, brake_load_cap);
        texture_load_cap = (std::max)(1.0f, texture_load_cap);
        abs_gain = (std::max)(0.0f, abs_gain);
        spin_gain = (std::max)(0.0f, spin_gain);
        slide_gain = (std::max)(0.0f, slide_gain);
        slide_freq = (std::max)(0.1f, slide_freq);
        road_gain = (std::max)(0.0f, road_gain);
        max_torque_ref = (std::max)(1.0f, max_torque_ref);
        abs_freq = (std::max)(1.0f, abs_freq);
        lockup_freq_scale = (std::max)(0.1f, lockup_freq_scale);
        spin_freq_scale = (std::max)(0.1f, spin_freq_scale);
        scrub_drag_gain = (std::max)(0.0f, scrub_drag_gain);
        rear_align_effect = (std::max)(0.0f, rear_align_effect);
        sop_yaw_gain = (std::max)(0.0f, sop_yaw_gain);
        gyro_gain = (std::max)(0.0f, gyro_gain);
        steering_shaft_gain = (std::max)(0.0f, steering_shaft_gain);
        torque_source = (std::max)(0, (std::min)(1, torque_source));
        notch_q = (std::max)(0.1f, notch_q);
        flatspot_strength = (std::max)(0.0f, (std::min)(1.0f, flatspot_strength));
        static_notch_freq = (std::max)(1.0f, static_notch_freq);
        static_notch_width = (std::max)(0.1f, static_notch_width);
        speed_gate_upper = (std::max)(0.1f, speed_gate_upper);
        optimal_slip_angle = (std::max)(0.01f, optimal_slip_angle);
        optimal_slip_ratio = (std::max)(0.01f, optimal_slip_ratio);
        steering_shaft_smoothing = (std::max)(0.0f, steering_shaft_smoothing);
        gyro_smoothing = (std::max)(0.0f, gyro_smoothing);
        yaw_smoothing = (std::max)(0.0f, yaw_smoothing);
        chassis_smoothing = (std::max)(0.0f, chassis_smoothing);
        road_fallback_scale = (std::max)(0.0f, road_fallback_scale);
        slope_sg_window = (std::max)(5, (std::min)(41, slope_sg_window));
        if (slope_sg_window % 2 == 0) slope_sg_window++;
        slope_sensitivity = (std::max)(0.1f, slope_sensitivity);
        slope_smoothing_tau = (std::max)(0.001f, slope_smoothing_tau);
        slope_alpha_threshold = (std::max)(0.001f, slope_alpha_threshold);
        slope_decay_rate = (std::max)(0.1f, slope_decay_rate);
        slope_g_slew_limit = (std::max)(1.0f, slope_g_slew_limit);
        slope_torque_sensitivity = (std::max)(0.01f, slope_torque_sensitivity);
        slope_confidence_max_rate = (std::max)(slope_alpha_threshold + 0.01f, slope_confidence_max_rate);
    }

    // NEW: Capture current engine state into this preset
    void UpdateFromEngine(const FFBEngine& engine) {
        gain = engine.m_gain;
        understeer = engine.m_understeer_effect;
        sop = engine.m_sop_effect;
        sop_scale = engine.m_sop_scale;
        sop_smoothing = engine.m_sop_smoothing_factor;
        slip_smoothing = engine.m_slip_angle_smoothing;
        min_force = engine.m_min_force;
        oversteer_boost = engine.m_oversteer_boost;
        dynamic_weight_gain = engine.m_dynamic_weight_gain;
        dynamic_weight_smoothing = engine.m_dynamic_weight_smoothing;
        grip_smoothing_steady = engine.m_grip_smoothing_steady;
        grip_smoothing_fast = engine.m_grip_smoothing_fast;
        grip_smoothing_sensitivity = engine.m_grip_smoothing_sensitivity;
        lockup_enabled = engine.m_lockup_enabled;
        lockup_gain = engine.m_lockup_gain;
        lockup_start_pct = engine.m_lockup_start_pct;
        lockup_full_pct = engine.m_lockup_full_pct;
        lockup_rear_boost = engine.m_lockup_rear_boost;
        lockup_gamma = engine.m_lockup_gamma;
        lockup_prediction_sens = engine.m_lockup_prediction_sens;
        lockup_bump_reject = engine.m_lockup_bump_reject;
        brake_load_cap = engine.m_brake_load_cap;
        texture_load_cap = engine.m_texture_load_cap;  // NEW v0.6.25
        abs_pulse_enabled = engine.m_abs_pulse_enabled;
        abs_gain = engine.m_abs_gain;
        
        spin_enabled = engine.m_spin_enabled;
        spin_gain = engine.m_spin_gain;
        slide_enabled = engine.m_slide_texture_enabled;
        slide_gain = engine.m_slide_texture_gain;
        slide_freq = engine.m_slide_freq_scale;
        road_enabled = engine.m_road_texture_enabled;
        road_gain = engine.m_road_texture_gain;
        invert_force = engine.m_invert_force;
        max_torque_ref = engine.m_max_torque_ref;
        abs_freq = engine.m_abs_freq_hz;
        lockup_freq_scale = engine.m_lockup_freq_scale;
        spin_freq_scale = engine.m_spin_freq_scale;
        bottoming_method = engine.m_bottoming_method;
        scrub_drag_gain = engine.m_scrub_drag_gain;
        rear_align_effect = engine.m_rear_align_effect;
        sop_yaw_gain = engine.m_sop_yaw_gain;
        gyro_gain = engine.m_gyro_gain;
        steering_shaft_gain = engine.m_steering_shaft_gain;
        base_force_mode = engine.m_base_force_mode;
        torque_source = engine.m_torque_source;
        flatspot_suppression = engine.m_flatspot_suppression;
        notch_q = engine.m_notch_q;
        flatspot_strength = engine.m_flatspot_strength;
        static_notch_enabled = engine.m_static_notch_enabled;
        static_notch_freq = engine.m_static_notch_freq;
        static_notch_width = engine.m_static_notch_width;
        yaw_kick_threshold = engine.m_yaw_kick_threshold;
        speed_gate_lower = engine.m_speed_gate_lower;
        speed_gate_upper = engine.m_speed_gate_upper;

        // NEW: Grip & Smoothing (v0.5.7/v0.5.8)
        optimal_slip_angle = engine.m_optimal_slip_angle;
        optimal_slip_ratio = engine.m_optimal_slip_ratio;
        steering_shaft_smoothing = engine.m_steering_shaft_smoothing;
        gyro_smoothing = engine.m_gyro_smoothing;
        yaw_smoothing = engine.m_yaw_accel_smoothing;
        chassis_smoothing = engine.m_chassis_inertia_smoothing;
        road_fallback_scale = engine.m_road_fallback_scale;
        understeer_affects_sop = engine.m_understeer_affects_sop;

        // Slope Detection (v0.7.0)
        slope_detection_enabled = engine.m_slope_detection_enabled;
        slope_sg_window = engine.m_slope_sg_window;
        slope_sensitivity = engine.m_slope_sensitivity;

        slope_smoothing_tau = engine.m_slope_smoothing_tau;

        // v0.7.3: Slope stability fixes
        slope_alpha_threshold = engine.m_slope_alpha_threshold;
        slope_decay_rate = engine.m_slope_decay_rate;
        slope_confidence_enabled = engine.m_slope_confidence_enabled;
        slope_confidence_max_rate = engine.m_slope_confidence_max_rate;

        // v0.7.11: Min/Max thresholds
        slope_min_threshold = engine.m_slope_min_threshold;
        slope_max_threshold = engine.m_slope_max_threshold;

        // NEW v0.7.40: Advanced Slope Settings
        slope_g_slew_limit = engine.m_slope_g_slew_limit;
        slope_use_torque = engine.m_slope_use_torque;
        slope_torque_sensitivity = engine.m_slope_torque_sensitivity;
        app_version = LMUFFB_VERSION;
    }

    bool Equals(const Preset& p) const {
        const float eps = 0.0001f;
        auto is_near = [](float a, float b, float epsilon) { return std::abs(a - b) < epsilon; };

        if (!is_near(gain, p.gain, eps)) return false;
        if (!is_near(understeer, p.understeer, eps)) return false;
        if (!is_near(sop, p.sop, eps)) return false;
        if (!is_near(sop_scale, p.sop_scale, eps)) return false;
        if (!is_near(sop_smoothing, p.sop_smoothing, eps)) return false;
        if (!is_near(slip_smoothing, p.slip_smoothing, eps)) return false;
        if (!is_near(min_force, p.min_force, eps)) return false;
        if (!is_near(oversteer_boost, p.oversteer_boost, eps)) return false;
        if (!is_near(dynamic_weight_gain, p.dynamic_weight_gain, eps)) return false;
        if (!is_near(dynamic_weight_smoothing, p.dynamic_weight_smoothing, eps)) return false;
        if (!is_near(grip_smoothing_steady, p.grip_smoothing_steady, eps)) return false;
        if (!is_near(grip_smoothing_fast, p.grip_smoothing_fast, eps)) return false;
        if (!is_near(grip_smoothing_sensitivity, p.grip_smoothing_sensitivity, eps)) return false;

        if (lockup_enabled != p.lockup_enabled) return false;
        if (!is_near(lockup_gain, p.lockup_gain, eps)) return false;
        if (!is_near(lockup_start_pct, p.lockup_start_pct, eps)) return false;
        if (!is_near(lockup_full_pct, p.lockup_full_pct, eps)) return false;
        if (!is_near(lockup_rear_boost, p.lockup_rear_boost, eps)) return false;
        if (!is_near(lockup_gamma, p.lockup_gamma, eps)) return false;
        if (!is_near(lockup_prediction_sens, p.lockup_prediction_sens, eps)) return false;
        if (!is_near(lockup_bump_reject, p.lockup_bump_reject, eps)) return false;
        if (!is_near(brake_load_cap, p.brake_load_cap, eps)) return false;
        if (!is_near(texture_load_cap, p.texture_load_cap, eps)) return false;

        if (abs_pulse_enabled != p.abs_pulse_enabled) return false;
        if (!is_near(abs_gain, p.abs_gain, eps)) return false;
        if (!is_near(abs_freq, p.abs_freq, eps)) return false;

        if (spin_enabled != p.spin_enabled) return false;
        if (!is_near(spin_gain, p.spin_gain, eps)) return false;
        if (!is_near(spin_freq_scale, p.spin_freq_scale, eps)) return false;

        if (slide_enabled != p.slide_enabled) return false;
        if (!is_near(slide_gain, p.slide_gain, eps)) return false;
        if (!is_near(slide_freq, p.slide_freq, eps)) return false;

        if (road_enabled != p.road_enabled) return false;
        if (!is_near(road_gain, p.road_gain, eps)) return false;

        if (invert_force != p.invert_force) return false;
        if (!is_near(max_torque_ref, p.max_torque_ref, eps)) return false;
        if (!is_near(lockup_freq_scale, p.lockup_freq_scale, eps)) return false;
        if (bottoming_method != p.bottoming_method) return false;
        if (!is_near(scrub_drag_gain, p.scrub_drag_gain, eps)) return false;
        if (!is_near(rear_align_effect, p.rear_align_effect, eps)) return false;
        if (!is_near(sop_yaw_gain, p.sop_yaw_gain, eps)) return false;
        if (!is_near(gyro_gain, p.gyro_gain, eps)) return false;
        if (!is_near(steering_shaft_gain, p.steering_shaft_gain, eps)) return false;
        if (base_force_mode != p.base_force_mode) return false;
        if (torque_source != p.torque_source) return false;

        if (!is_near(optimal_slip_angle, p.optimal_slip_angle, eps)) return false;
        if (!is_near(optimal_slip_ratio, p.optimal_slip_ratio, eps)) return false;
        if (!is_near(steering_shaft_smoothing, p.steering_shaft_smoothing, eps)) return false;
        if (!is_near(gyro_smoothing, p.gyro_smoothing, eps)) return false;
        if (!is_near(yaw_smoothing, p.yaw_smoothing, eps)) return false;
        if (!is_near(chassis_smoothing, p.chassis_smoothing, eps)) return false;

        if (flatspot_suppression != p.flatspot_suppression) return false;
        if (!is_near(notch_q, p.notch_q, eps)) return false;
        if (!is_near(flatspot_strength, p.flatspot_strength, eps)) return false;

        if (static_notch_enabled != p.static_notch_enabled) return false;
        if (!is_near(static_notch_freq, p.static_notch_freq, eps)) return false;
        if (!is_near(static_notch_width, p.static_notch_width, eps)) return false;
        if (!is_near(yaw_kick_threshold, p.yaw_kick_threshold, eps)) return false;

        if (!is_near(speed_gate_lower, p.speed_gate_lower, eps)) return false;
        if (!is_near(speed_gate_upper, p.speed_gate_upper, eps)) return false;

        if (!is_near(road_fallback_scale, p.road_fallback_scale, eps)) return false;
        if (understeer_affects_sop != p.understeer_affects_sop) return false;

        if (slope_detection_enabled != p.slope_detection_enabled) return false;
        if (slope_sg_window != p.slope_sg_window) return false;
        if (!is_near(slope_sensitivity, p.slope_sensitivity, eps)) return false;

        if (!is_near(slope_smoothing_tau, p.slope_smoothing_tau, eps)) return false;
        if (!is_near(slope_alpha_threshold, p.slope_alpha_threshold, eps)) return false;
        if (!is_near(slope_decay_rate, p.slope_decay_rate, eps)) return false;
        if (slope_confidence_enabled != p.slope_confidence_enabled) return false;
        if (!is_near(slope_min_threshold, p.slope_min_threshold, eps)) return false;
        if (!is_near(slope_max_threshold, p.slope_max_threshold, eps)) return false;

        if (!is_near(slope_g_slew_limit, p.slope_g_slew_limit, eps)) return false;
        if (slope_use_torque != p.slope_use_torque) return false;
        if (!is_near(slope_torque_sensitivity, p.slope_torque_sensitivity, eps)) return false;
        if (!is_near(slope_confidence_max_rate, p.slope_confidence_max_rate, eps)) return false;

        return true;
    }
};

class Config {
public:
    static std::string m_config_path; // Default: "config.ini"
    static void Save(const FFBEngine& engine, const std::string& filename = "");
    static void Load(FFBEngine& engine, const std::string& filename = "");
    
    // Preset Management
    static std::vector<Preset> presets;
    static std::string m_last_preset_name; // NEW (v0.7.14)
    static void LoadPresets(); // Populates presets vector
    static void ApplyPreset(int index, FFBEngine& engine);
    
    // NEW: Add a user preset
    static void AddUserPreset(const std::string& name, const FFBEngine& engine);

    // NEW: Delete and Duplicate (v0.7.14)
    static void DeletePreset(int index, const FFBEngine& engine);
    static void DuplicatePreset(int index, const FFBEngine& engine);
    static bool IsEngineDirtyRelativeToPreset(int index, const FFBEngine& engine);

    // NEW: Import/Export (v0.7.12)
    static void ExportPreset(int index, const std::string& filename);
    static bool ImportPreset(const std::string& filename, const FFBEngine& engine);

    // NEW: Persist selected device
    static std::string m_last_device_guid;

    // Global App Settings (not part of FFB Physics)
    static bool m_always_on_top;      // NEW: Keep window on top
    static bool m_auto_start_logging; // NEW: Auto-start logging
    static std::string m_log_path;    // NEW: Path to save logs

    // Window Geometry Persistence (v0.5.5)
    static int win_pos_x, win_pos_y;
    static int win_w_small, win_h_small; // Dimensions for Config Only
    static int win_w_large, win_h_large; // Dimensions for Config + Graphs
    static bool show_graphs;             // Remember if graphs were open

private:
    // Helper for parsing preset lines (v0.7.12)
    static void ParsePresetLine(const std::string& line, Preset& p, std::string& version, bool& needs_save);
    // Helper for writing preset fields (v0.7.12)
    static void WritePresetFields(std::ofstream& file, const Preset& p);
};




#endif






```

# File: src\DirectInputFFB.cpp
```cpp
#include "DirectInputFFB.h"

// Standard Library Headers
#include <iostream>
#include <cmath>
#include <cstdio> // For sscanf, sprintf
#include <algorithm> // For std::max, std::min

// Platform-Specific Headers
#ifdef _WIN32
#include <windows.h>
#include <psapi.h>
#include <dinput.h>
#include <iomanip> // For std::hex
#include <string>
#endif

// Constants
namespace {
    constexpr uint32_t DIAGNOSTIC_LOG_INTERVAL_MS = 1000; // Rate limit diagnostic logging to 1 second
    constexpr uint32_t RECOVERY_COOLDOWN_MS = 2000;       // Wait 2 seconds between recovery attempts
}

// Keep existing implementations
DirectInputFFB& DirectInputFFB::Get() {
    static DirectInputFFB instance;
    return instance;
}

DirectInputFFB::DirectInputFFB() {}

// NEW: Helper to get foreground window title for diagnostics - REMOVED for Security/Privacy
std::string DirectInputFFB::GetActiveWindowTitle() {
    return "Window Tracking Disabled";
}

// NEW: Helper Implementations for GUID
std::string DirectInputFFB::GuidToString(const GUID& guid) {
    char buf[64];
#ifdef _WIN32
    sprintf_s(buf, "{%08lX-%04hX-%04hX-%02hhX%02hhX-%02hhX%02hhX%02hhX%02hhX%02hhX%02hhX}",
        guid.Data1, guid.Data2, guid.Data3,
        guid.Data4[0], guid.Data4[1], guid.Data4[2], guid.Data4[3],
        guid.Data4[4], guid.Data4[5], guid.Data4[6], guid.Data4[7]);
#else
    snprintf(buf, sizeof(buf), "{%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}",
        (unsigned int)guid.Data1, (unsigned int)guid.Data2, (unsigned int)guid.Data3,
        (unsigned int)guid.Data4[0], (unsigned int)guid.Data4[1], (unsigned int)guid.Data4[2], (unsigned int)guid.Data4[3],
        (unsigned int)guid.Data4[4], (unsigned int)guid.Data4[5], (unsigned int)guid.Data4[6], (unsigned int)guid.Data4[7]);
#endif
    return std::string(buf);
}

GUID DirectInputFFB::StringToGuid(const std::string& str) {
    GUID guid = { 0 };
    if (str.empty()) return guid;
    unsigned long p0;
    unsigned short p1, p2;
    unsigned int p3, p4, p5, p6, p7, p8, p9, p10;
#ifdef _WIN32
    int n = sscanf_s(str.c_str(), "{%08lX-%04hX-%04hX-%02X%02X-%02X%02X%02X%02X%02X%02X}",
        &p0, &p1, &p2, &p3, &p4, &p5, &p6, &p7, &p8, &p9, &p10);
#else
    int n = sscanf(str.c_str(), "{%08lX-%04hX-%04hX-%02X%02X-%02X%02X%02X%02X%02X%02X}",
        &p0, &p1, &p2, &p3, &p4, &p5, &p6, &p7, &p8, &p9, &p10);
#endif
    if (n == 11) {
        guid.Data1 = p0;
        guid.Data2 = (unsigned short)p1;
        guid.Data3 = (unsigned short)p2;
        guid.Data4[0] = (unsigned char)p3; guid.Data4[1] = (unsigned char)p4;
        guid.Data4[2] = (unsigned char)p5; guid.Data4[3] = (unsigned char)p6;
        guid.Data4[4] = (unsigned char)p7; guid.Data4[5] = (unsigned char)p8;
        guid.Data4[6] = (unsigned char)p9; guid.Data4[7] = (unsigned char)p10;
    }
    return guid;
}



#ifdef _WIN32
/**
 * @brief Returns the description for a DirectInput return code.
 * 
 * Parsed from: unlinked: learn_microsoft_com/en-us/previous-versions/windows/desktop/ee416869(v=vs.85)#constants
 * 
 * @param hr The HRESULT returned by a DirectInput method.
 * @return const char* The description of the error or status code.
 */
const char* GetDirectInputErrorString(HRESULT hr) {
    switch (hr) {
        // Success Codes
        case S_OK: // Also DI_OK
            return "The operation completed successfully (S_OK).";
        case S_FALSE: // Also DI_BUFFEROVERFLOW, DI_NOEFFECT, DI_NOTATTACHED, DI_PROPNOEFFECT
            return "Operation technically succeeded but had no effect or hit a warning (S_FALSE). The device buffer overflowed and some input was lost. This value is equal to DI_BUFFEROVERFLOW, DI_NOEFFECT, DI_NOTATTACHED, DI_PROPNOEFFECT.";
        case DI_DOWNLOADSKIPPED:
            return "The parameters of the effect were successfully updated, but the effect could not be downloaded because the associated device was not acquired in exclusive mode.";
        case DI_EFFECTRESTARTED:
            return "The effect was stopped, the parameters were updated, and the effect was restarted.";
        case DI_POLLEDDEVICE:
            return "The device is a polled device.. As a result, device buffering does not collect any data and event notifications is not signaled until the IDirectInputDevice8 Interface method is called.";
        case DI_SETTINGSNOTSAVED:
            return "The action map was applied to the device, but the settings could not be saved.";
        case DI_TRUNCATED:
            return "The parameters of the effect were successfully updated, but some of them were beyond the capabilities of the device and were truncated to the nearest supported value.";
        case DI_TRUNCATEDANDRESTARTED:
            return "Equal to DI_EFFECTRESTARTED | DI_TRUNCATED.";
        case DI_WRITEPROTECT:
            return "A SUCCESS code indicating that settings cannot be modified.";

        // Error Codes
        case DIERR_ACQUIRED:
            return "The operation cannot be performed while the device is acquired.";
        case DIERR_ALREADYINITIALIZED:
            return "This object is already initialized.";
        case DIERR_BADDRIVERVER:
            return "The object could not be created due to an incompatible driver version or mismatched or incomplete driver components.";
        case DIERR_BETADIRECTINPUTVERSION:
            return "The application was written for an unsupported prerelease version of DirectInput.";
        case DIERR_DEVICEFULL:
            return "The device is full.";
        case DIERR_DEVICENOTREG: // Equal to REGDB_E_CLASSNOTREG
            return "The device or device instance is not registered with DirectInput.";
        case DIERR_EFFECTPLAYING:
            return "The parameters were updated in memory but were not downloaded to the device because the device does not support updating an effect while it is still playing.";
        case DIERR_GENERIC: // Equal to E_FAIL
            return "An undetermined error occurred inside the DirectInput subsystem.";
        case DIERR_HANDLEEXISTS: // Equal to E_ACCESSDENIED
            return "Access denied or handle already exists. Another application may have exclusive access.";
        case DIERR_HASEFFECTS:
            return "The device cannot be reinitialized because effects are attached to it.";
        case DIERR_INCOMPLETEEFFECT:
            return "The effect could not be downloaded because essential information is missing. For example, no axes have been associated with the effect, or no type-specific information has been supplied.";
        case DIERR_INPUTLOST:
            return "Access to the input device has been lost. It must be reacquired.";
        case DIERR_INVALIDPARAM: // Equal to E_INVALIDARG
            return "An invalid parameter was passed to the returning function, or the object was not in a state that permitted the function to be called.";
        case DIERR_MAPFILEFAIL:
            return "An error has occurred either reading the vendor-supplied action-mapping file for the device or reading or writing the user configuration mapping file for the device.";
        case DIERR_MOREDATA:
            return "Not all the requested information fit into the buffer.";
        case DIERR_NOAGGREGATION:
            return "This object does not support aggregation.";
        case DIERR_NOINTERFACE: // Equal to E_NOINTERFACE
            return "The object does not support the specified interface.";
        case DIERR_NOTACQUIRED:
            return "The operation cannot be performed unless the device is acquired.";
        case DIERR_NOTBUFFERED:
            return "The device is not buffered. Set the DIPROP_BUFFERSIZE property to enable buffering.";
        case DIERR_NOTDOWNLOADED:
            return "The effect is not downloaded.";
        case DIERR_NOTEXCLUSIVEACQUIRED:
            return "The operation cannot be performed unless the device is acquired in DISCL_EXCLUSIVE mode.";
        case DIERR_NOTFOUND:
            return "The requested object does not exist (DIERR_NOTFOUND).";
        // case DIERR_OBJECTNOTFOUND: // Duplicate of DIERR_NOTFOUND
        //    return "The requested object does not exist.";
        case DIERR_OLDDIRECTINPUTVERSION:
            return "The application requires a newer version of DirectInput.";
        // case DIERR_OTHERAPPHASPRIO: // Duplicate of DIERR_HANDLEEXISTS (E_ACCESSDENIED)
        //    return "Another application has a higher priority level, preventing this call from succeeding.";
        case DIERR_OUTOFMEMORY: // Equal to E_OUTOFMEMORY
            return "The DirectInput subsystem could not allocate sufficient memory to complete the call.";
        // case DIERR_READONLY: // Duplicate of DIERR_HANDLEEXISTS (E_ACCESSDENIED)
        //    return "The specified property cannot be changed.";
        case DIERR_REPORTFULL:
            return "More information was requested to be sent than can be sent to the device.";
        case DIERR_UNPLUGGED:
            return "The operation could not be completed because the device is not plugged in.";
        case DIERR_UNSUPPORTED: // Equal to E_NOTIMPL
            return "The function called is not supported at this time.";
        case E_HANDLE:
            return "The HWND parameter is not a valid top-level window that belongs to the process.";
        case E_PENDING:
            return "Data is not yet available.";
        case E_POINTER:
            return "An invalid pointer, usually NULL, was passed as a parameter.";
        
        default:
            return "Unknown DirectInput Error";
    }
}
#endif

DirectInputFFB::~DirectInputFFB() {
    Shutdown();
}

bool DirectInputFFB::Initialize(HWND hwnd) {
    m_hwnd = hwnd;
#ifdef _WIN32
    if (FAILED(DirectInput8Create(GetModuleHandle(NULL), DIRECTINPUT_VERSION, IID_IDirectInput8, (void**)&m_pDI, NULL))) {
        std::cerr << "[DI] Failed to create DirectInput8 interface." << std::endl;
        return false;
    }
    std::cout << "[DI] Initialized." << std::endl;
    return true;
#else
    std::cout << "[DI] Mock Initialized (Non-Windows)." << std::endl;
    return true;
#endif
}

void DirectInputFFB::Shutdown() {
    ReleaseDevice(); // Reuse logic
#ifdef _WIN32
    if (m_pDI) {
        ((IDirectInput8*)m_pDI)->Release();
        m_pDI = nullptr;
    }
#endif
}

#ifdef _WIN32
BOOL CALLBACK EnumJoysticksCallback(const DIDEVICEINSTANCE* pdidInstance, VOID* pContext) {
    auto* devices = (std::vector<DeviceInfo>*)pContext;
    DeviceInfo info;
    info.guid = pdidInstance->guidInstance;
    char name[260];
    WideCharToMultiByte(CP_ACP, 0, pdidInstance->tszProductName, -1, name, 260, NULL, NULL);
    info.name = std::string(name);
    devices->push_back(info);
    return DIENUM_CONTINUE;
}
#endif

std::vector<DeviceInfo> DirectInputFFB::EnumerateDevices() {
    std::vector<DeviceInfo> devices;
#ifdef _WIN32
    if (!m_pDI) return devices;
    ((IDirectInput8*)m_pDI)->EnumDevices(DI8DEVCLASS_GAMECTRL, EnumJoysticksCallback, &devices, DIEDFL_ATTACHEDONLY | DIEDFL_FORCEFEEDBACK);
#else
    DeviceInfo d1; d1.name = "Simucube 2 Pro (Mock)";
    DeviceInfo d2; d2.name = "Logitech G29 (Mock)";
    devices.push_back(d1);
    devices.push_back(d2);
#endif
    return devices;
}

void DirectInputFFB::ReleaseDevice() {
#ifdef _WIN32
    if (m_pEffect) {
        ((IDirectInputEffect*)m_pEffect)->Stop();
        ((IDirectInputEffect*)m_pEffect)->Unload();
        ((IDirectInputEffect*)m_pEffect)->Release();
        m_pEffect = nullptr;
    }
    if (m_pDevice) {
        ((IDirectInputDevice8*)m_pDevice)->Unacquire();
        ((IDirectInputDevice8*)m_pDevice)->Release();
        m_pDevice = nullptr;
    }
#endif
    m_active = false;
    m_isExclusive = false;
    m_deviceName = "None";
#ifdef _WIN32
    std::cout << "[DI] Device released by user." << std::endl;
#endif
}

bool DirectInputFFB::SelectDevice(const GUID& guid) {
#ifdef _WIN32
    if (!m_pDI) return false;

    // Cleanup old using new method
    ReleaseDevice();

    std::cout << "[DI] Attempting to create device..." << std::endl;
    if (FAILED(((IDirectInput8*)m_pDI)->CreateDevice(guid, (IDirectInputDevice8**)&m_pDevice, NULL))) {
        std::cerr << "[DI] Failed to create device." << std::endl;
        return false;
    }

    std::cout << "[DI] Setting Data Format..." << std::endl;
    if (FAILED(((IDirectInputDevice8*)m_pDevice)->SetDataFormat(&c_dfDIJoystick))) {
        std::cerr << "[DI] Failed to set data format." << std::endl;
        return false;
    }

    // Reset state
    m_isExclusive = false;

    // Attempt 1: Exclusive/Background (Best for FFB)
    std::cout << "[DI] Attempting to set Cooperative Level (Exclusive | Background)..." << std::endl;
    HRESULT hr = ((IDirectInputDevice8*)m_pDevice)->SetCooperativeLevel(m_hwnd, DISCL_EXCLUSIVE | DISCL_BACKGROUND);
    
    if (SUCCEEDED(hr)) {
        m_isExclusive = true;
        std::cout << "[DI] Cooperative Level set to EXCLUSIVE." << std::endl;
    } else {
        // Fallback: Non-Exclusive
        std::cerr << "[DI] Exclusive mode failed (Error: " << std::hex << hr << std::dec << "). Retrying in Non-Exclusive mode..." << std::endl;
        hr = ((IDirectInputDevice8*)m_pDevice)->SetCooperativeLevel(m_hwnd, DISCL_NONEXCLUSIVE | DISCL_BACKGROUND);
        
        if (SUCCEEDED(hr)) {
            m_isExclusive = false;
            std::cout << "[DI] Cooperative Level set to NON-EXCLUSIVE." << std::endl;
        }
    }
    
    if (FAILED(hr)) {
        std::cerr << "[DI] Failed to set cooperative level (Non-Exclusive failed too)." << std::endl;
        return false;
    }

    std::cout << "[DI] Acquiring device..." << std::endl;
    if (FAILED(((IDirectInputDevice8*)m_pDevice)->Acquire())) {
        std::cerr << "[DI] Failed to acquire device." << std::endl;
        // Don't return false yet, might just need focus/retry
    } else {
        std::cout << "[DI] Device Acquired in " << (m_isExclusive ? "EXCLUSIVE" : "NON-EXCLUSIVE") << " mode." << std::endl;
    }

    // Create Effect
    if (CreateEffect()) {
       m_active = true;
        std::cout << "[DI] SUCCESS: Physical Device fully initialized and FFB Effect created." << std::endl;
 
        return true;
    }
    return false;
#else
    m_active = true;
    m_isExclusive = true; // Default to true in mock to verify UI logic
    m_deviceName = "Mock Device Selected";
    return true;
#endif
}

bool DirectInputFFB::CreateEffect() {
#ifdef _WIN32
    if (!m_pDevice) return false;

    DWORD rgdwAxes[1] = { DIJOFS_X };
    LONG rglDirection[1] = { 0 };
    DICONSTANTFORCE cf;
    cf.lMagnitude = 0;

    DIEFFECT eff;
    ZeroMemory(&eff, sizeof(eff));
    eff.dwSize = sizeof(DIEFFECT);
    eff.dwFlags = DIEFF_CARTESIAN | DIEFF_OBJECTOFFSETS;
    eff.dwDuration = INFINITE;
    eff.dwSamplePeriod = 0;
    eff.dwGain = DI_FFNOMINALMAX;
    eff.dwTriggerButton = DIEB_NOTRIGGER;
    eff.dwTriggerRepeatInterval = 0;
    eff.cAxes = 1;
    eff.rgdwAxes = rgdwAxes;
    eff.rglDirection = rglDirection;
    eff.lpEnvelope = NULL;
    eff.cbTypeSpecificParams = sizeof(DICONSTANTFORCE);
    eff.lpvTypeSpecificParams = &cf;
    eff.dwStartDelay = 0;

    if (FAILED(((IDirectInputDevice8*)m_pDevice)->CreateEffect(GUID_ConstantForce, &eff, (IDirectInputEffect**)&m_pEffect, NULL))) {
        std::cerr << "[DI] Failed to create Constant Force effect." << std::endl;
        return false;
    }
    
    // Start immediately
    ((IDirectInputEffect*)m_pEffect)->Start(1, 0);
    return true;
#else
    return true;
#endif
}

bool DirectInputFFB::UpdateForce(double normalizedForce) {
    if (!m_active) return false;

    // Sanity Check: If 0.0, stop effect to prevent residual hum
    if (std::abs(normalizedForce) < 0.00001) normalizedForce = 0.0;

    // Clamp
    normalizedForce = (std::max)(-1.0, (std::min)(1.0, normalizedForce));

    // Scale to -10000..10000
    long magnitude = static_cast<long>(normalizedForce * 10000.0);

    // Optimization: Don't call driver if value hasn't changed
    if (magnitude == m_last_force) return false;
    m_last_force = magnitude;

#ifdef _WIN32
    if (m_pEffect) {
        DICONSTANTFORCE cf;
        cf.lMagnitude = magnitude;
        
        DIEFFECT eff;
        ZeroMemory(&eff, sizeof(eff));
        eff.dwSize = sizeof(DIEFFECT);
        eff.cbTypeSpecificParams = sizeof(DICONSTANTFORCE);
        eff.lpvTypeSpecificParams = &cf;
        
        // Try to update parameters
        HRESULT hr = ((IDirectInputEffect*)m_pEffect)->SetParameters(&eff, DIEP_TYPESPECIFICPARAMS);
        
        // --- DIAGNOSTIC & RECOVERY LOGIC ---
        if (FAILED(hr)) {
            // 1. Identify the Error
            std::string errorType = GetDirectInputErrorString(hr);

            // Append Custom Advice for Priority/Exclusive Errors
            if (hr == DIERR_OTHERAPPHASPRIO || hr == DIERR_NOTEXCLUSIVEACQUIRED ) {
                errorType += " [CRITICAL: Game has stolen priority! DISABLE IN-GAME FFB]";
                
                // Update exclusivity state to reflect reality
                m_isExclusive = false;
            }

            // FIX: Default to TRUE. If update failed, we must try to reconnect.
            bool recoverable = true; 

            // 2. Log the Context (Rate limited)
            static uint32_t lastLogTime = 0;
            if (GetTickCount() - lastLogTime > DIAGNOSTIC_LOG_INTERVAL_MS) {
                std::cerr << "[DI ERROR] Failed to update force. Error: " << errorType 
                          << " (0x" << std::hex << hr << std::dec << ")" << std::endl;
                std::cerr << "           Active Window: [" << GetActiveWindowTitle() << "]" << std::endl;
                lastLogTime = GetTickCount();
            }

            // 3. Attempt Recovery (with Smart Cool-down)
            if (recoverable) {
                // Throttle recovery attempts to prevent CPU spam when device is locked
                static uint32_t lastRecoveryAttempt = 0;
                uint32_t now = GetTickCount();
                
                // Only attempt recovery if cooldown period has elapsed
                if (now - lastRecoveryAttempt > RECOVERY_COOLDOWN_MS) {
                    lastRecoveryAttempt = now; // Mark this attempt
                    
                    // --- DYNAMIC PROMOTION FIX ---
                    // If we are stuck in "Shared Mode" (0x80040205), standard Acquire() 
                    // just re-confirms Shared Mode. We must force a mode switch.
                    if (hr == DIERR_NOTEXCLUSIVEACQUIRED) {
                        std::cout << "[DI] Attempting to promote to Exclusive Mode..." << std::endl;
                        ((IDirectInputDevice8*)m_pDevice)->Unacquire();
                        ((IDirectInputDevice8*)m_pDevice)->SetCooperativeLevel(m_hwnd, DISCL_EXCLUSIVE | DISCL_BACKGROUND);
                    }
                    // -----------------------------

                    HRESULT hrAcq = ((IDirectInputDevice8*)m_pDevice)->Acquire();
                    
                    if (SUCCEEDED(hrAcq)) {
                        // Log recovery success (rate-limited for diagnostics)
                        static uint32_t lastSuccessLog = 0;
                        if (GetTickCount() - lastSuccessLog > 5000) { // 5 second cooldown
                            std::cout << "[DI RECOVERY] Device re-acquired successfully. FFB motor restarted." << std::endl;
                            lastSuccessLog = GetTickCount();
                        }
                        
                        // Update our internal state if we fixed the exclusivity
                        if (hr == DIERR_NOTEXCLUSIVEACQUIRED) {
                            m_isExclusive = true; 
                            
                            // One-time notification when Dynamic Promotion first succeeds
                            static bool firstPromotionSuccess = false;
                            if (!firstPromotionSuccess) {
                                std::cout << "\n"
                                          << "========================================\n"
                                          << "[SUCCESS] Dynamic Promotion Active!\n"
                                          << "lmuFFB has successfully recovered exclusive\n"
                                          << "control after detecting a conflict.\n"
                                          << "This feature will continue to protect your\n"
                                          << "FFB experience automatically.\n"
                                          << "========================================\n" << std::endl;
                                firstPromotionSuccess = true;
                            }
                        }

                        // Restart the effect to ensure motor is active
                        ((IDirectInputEffect*)m_pEffect)->Start(1, 0);
                        
                        // Retry the update immediately
                        ((IDirectInputEffect*)m_pEffect)->SetParameters(&eff, DIEP_TYPESPECIFICPARAMS);
                    }
                }
            }
        }
    }
#endif
    return true;
}

```

# File: src\DirectInputFFB.h
```cpp
#ifndef DIRECTINPUTFFB_H
#define DIRECTINPUTFFB_H

#include <vector>
#include <string>
#include <atomic>

#ifdef _WIN32
#ifndef DIRECTINPUT_VERSION
#define DIRECTINPUT_VERSION 0x0800
#endif
#include <dinput.h>
#pragma comment(lib, "dinput8.lib")
#pragma comment(lib, "dxguid.lib")
#else
#include "lmu_sm_interface/LinuxMock.h"
// Mock types for non-Windows build/test
typedef void* LPDIRECTINPUT8;
typedef void* LPDIRECTINPUTDEVICE8;
typedef void* LPDIRECTINPUTEFFECT;
#endif

struct DeviceInfo {
    GUID guid;
    std::string name;
};

class DirectInputFFB {
public:
    static DirectInputFFB& Get();

    bool Initialize(HWND hwnd);
    void Shutdown();

    // Returns a list of FFB-capable devices
    std::vector<DeviceInfo> EnumerateDevices();

    // Select and Acquire a device
    bool SelectDevice(const GUID& guid);
    
    // Release the currently acquired device (User unbind)
    void ReleaseDevice();

    // Update the Constant Force effect (-1.0 to 1.0)
    // Returns true if the hardware was actually updated (value changed)
    bool UpdateForce(double normalizedForce);

    // NEW: Helpers for Config persistence
    static std::string GuidToString(const GUID& guid);
    static GUID StringToGuid(const std::string& str);
    static std::string GetActiveWindowTitle();

    bool IsActive() const { return m_active; }
    std::string GetCurrentDeviceName() const { return m_deviceName; }
    
    // Check if device was acquired in exclusive mode
    bool IsExclusive() const { return m_isExclusive; }

private:
    DirectInputFFB();
    ~DirectInputFFB();

    LPDIRECTINPUT8 m_pDI = nullptr;
    LPDIRECTINPUTDEVICE8 m_pDevice = nullptr;
    LPDIRECTINPUTEFFECT m_pEffect = nullptr;
    HWND m_hwnd = nullptr;
    
    bool m_active = false;
    bool m_isExclusive = false; // Track acquisition mode
    std::string m_deviceName = "None";
    
    // Internal helper to create the Constant Force effect
    bool CreateEffect();

    long m_last_force = -999999; 
};

#endif // DIRECTINPUTFFB_H

```

# File: src\FFBEngine.cpp
```cpp
﻿#include "FFBEngine.h"
#include "Config.h"
#include <iostream>
#include <algorithm>
#include <cmath>

using namespace ffb_math;

FFBEngine::FFBEngine() {
    last_log_time = std::chrono::steady_clock::now();
    Preset::ApplyDefaultsToEngine(*this);
}

bool FFBEngine::IsFFBAllowed(const VehicleScoringInfoV01& scoring, unsigned char gamePhase) const {
    if (!scoring.mIsPlayer || scoring.mControl != 0) return false;
    if (gamePhase == 7 || gamePhase == 8) return false;
    if (scoring.mFinishStatus == 3) return false;
    return true;
}

double FFBEngine::ApplySafetySlew(double target_force, double dt, bool restricted) {
    if (!std::isfinite(target_force)) return 0.0;
    double max_slew = restricted ? 100.0 : 1000.0;
    double max_change = max_slew * dt;
    double delta = target_force - m_last_output_force;
    delta = std::clamp(delta, -max_change, max_change);
    m_last_output_force += delta;
    return m_last_output_force;
}

std::vector<FFBSnapshot> FFBEngine::GetDebugBatch() {
    std::vector<FFBSnapshot> batch;
    {
        std::lock_guard<std::mutex> lock(m_debug_mutex);
        if (!m_debug_buffer.empty()) {
            batch.swap(m_debug_buffer);
        }
    }
    return batch;
}

void FFBEngine::update_static_load_reference(double current_load, double speed, double dt) {
    if (speed > 2.0 && speed < 15.0) {
        if (m_static_front_load < 100.0) {
             m_static_front_load = current_load;
        } else {
             m_static_front_load += (dt / 5.0) * (current_load - m_static_front_load);
        }
    }
    if (m_static_front_load < 1000.0) m_static_front_load = 4000.0;
}

void FFBEngine::InitializeLoadReference(const char* className, const char* vehicleName) {
    ParsedVehicleClass vclass = ParseVehicleClass(className, vehicleName);
    m_auto_peak_load = GetDefaultLoadForClass(vclass);
    std::cout << "[FFB] Vehicle Identification -> Detected Class: " << VehicleClassToString(vclass)
              << " | Seed Load: " << m_auto_peak_load << "N" 
              << " (Raw -> Class: " << (className ? className : "Unknown") 
              << ", Name: " << (vehicleName ? vehicleName : "Unknown") << ")" << std::endl;
}

double FFBEngine::calculate_raw_slip_angle_pair(const TelemWheelV01& w1, const TelemWheelV01& w2) {
    double v_long_1 = std::abs(w1.mLongitudinalGroundVel);
    double v_long_2 = std::abs(w2.mLongitudinalGroundVel);
    if (v_long_1 < MIN_SLIP_ANGLE_VELOCITY) v_long_1 = MIN_SLIP_ANGLE_VELOCITY;
    if (v_long_2 < MIN_SLIP_ANGLE_VELOCITY) v_long_2 = MIN_SLIP_ANGLE_VELOCITY;
    double raw_angle_1 = std::atan2(w1.mLateralPatchVel, v_long_1);
    double raw_angle_2 = std::atan2(w2.mLateralPatchVel, v_long_2);
    return (raw_angle_1 + raw_angle_2) / 2.0;
}

double FFBEngine::calculate_slip_angle(const TelemWheelV01& w, double& prev_state, double dt) {
    double v_long = std::abs(w.mLongitudinalGroundVel);
    if (v_long < MIN_SLIP_ANGLE_VELOCITY) v_long = MIN_SLIP_ANGLE_VELOCITY;
    double raw_angle = std::atan2(w.mLateralPatchVel, v_long);
    double tau = (double)m_slip_angle_smoothing;
    if (tau < 0.0001) tau = 0.0001;
    double alpha = dt / (tau + dt);
    alpha = (std::min)(1.0, (std::max)(0.001, alpha));
    prev_state = prev_state + alpha * (raw_angle - prev_state);
    return prev_state;
}

GripResult FFBEngine::calculate_grip(const TelemWheelV01& w1, 
                          const TelemWheelV01& w2,
                          double avg_load,
                          bool& warned_flag,
                          double& prev_slip1,
                          double& prev_slip2,
                          double car_speed,
                          double dt,
                          const char* vehicleName,
                          const TelemInfoV01* data,
                          bool is_front) {
    GripResult result;
    double total_load = w1.mTireLoad + w2.mTireLoad;
    if (total_load > 1.0) {
        result.original = (w1.mGripFract * w1.mTireLoad + w2.mGripFract * w2.mTireLoad) / total_load;
    } else {
        result.original = (w1.mGripFract + w2.mGripFract) / 2.0;
    }

    result.value = result.original;
    result.approximated = false;
    result.slip_angle = 0.0;
    
    double slip1 = calculate_slip_angle(w1, prev_slip1, dt);
    double slip2 = calculate_slip_angle(w2, prev_slip2, dt);
    result.slip_angle = (slip1 + slip2) / 2.0;

    if (result.value < 0.0001 && avg_load > 100.0) {
        result.approximated = true;
        
        if (car_speed < 5.0) {
            result.value = 1.0; 
        } else {
            if (m_slope_detection_enabled && is_front && data) {
                result.value = calculate_slope_grip(
                    data->mLocalAccel.x / 9.81,
                    result.slip_angle,
                    dt,
                    data
                );
            } else {
                double lat_metric = std::abs(result.slip_angle) / (double)m_optimal_slip_angle;
                double ratio1 = calculate_manual_slip_ratio(w1, car_speed);
                double ratio2 = calculate_manual_slip_ratio(w2, car_speed);
                double avg_ratio = (std::abs(ratio1) + std::abs(ratio2)) / 2.0;
                double long_metric = avg_ratio / (double)m_optimal_slip_ratio;
                double combined_slip = std::sqrt((lat_metric * lat_metric) + (long_metric * long_metric));

                if (combined_slip > 1.0) {
                    double excess = combined_slip - 1.0;
                    result.value = 1.0 / (1.0 + excess * 2.0);
                } else {
                    result.value = 1.0;
                }
            }
        }
        
        result.value = (std::max)(0.2, result.value);
        
        if (!warned_flag) {
            std::cout << "Warning: Data for mGripFract from the game seems to be missing for this car (" << vehicleName << "). (Likely Encrypted/DLC Content). A fallback estimation will be used." << std::endl;
            warned_flag = true;
        }
    }
    
    double& state = is_front ? m_front_grip_smoothed_state : m_rear_grip_smoothed_state;
    result.value = apply_adaptive_smoothing(result.value, state, dt,
                                            (double)m_grip_smoothing_steady,
                                            (double)m_grip_smoothing_fast,
                                            (double)m_grip_smoothing_sensitivity);

    result.value = (std::max)(0.0, (std::min)(1.0, result.value));
    return result;
}

double FFBEngine::approximate_load(const TelemWheelV01& w) {
    return w.mSuspForce + 300.0;
}

double FFBEngine::approximate_rear_load(const TelemWheelV01& w) {
    return w.mSuspForce + 300.0;
}

double FFBEngine::calculate_kinematic_load(const TelemInfoV01* data, int wheel_index) {
    bool is_rear = (wheel_index >= 2);
    double bias = is_rear ? m_approx_weight_bias : (1.0 - m_approx_weight_bias);
    double static_weight = (m_approx_mass_kg * 9.81 * bias) / 2.0;

    double speed = std::abs(data->mLocalVel.z);
    double aero_load = m_approx_aero_coeff * (speed * speed);
    double wheel_aero = aero_load / 4.0; 

    double long_transfer = (m_accel_z_smoothed / 9.81) * WEIGHT_TRANSFER_SCALE; 
    if (is_rear) long_transfer *= -1.0;

    double lat_transfer = (m_accel_x_smoothed / 9.81) * WEIGHT_TRANSFER_SCALE * m_approx_roll_stiffness;
    bool is_left = (wheel_index == 0 || wheel_index == 2);
    if (!is_left) lat_transfer *= -1.0;

    double total_load = static_weight + wheel_aero + long_transfer + lat_transfer;
    return (std::max)(0.0, total_load);
}

double FFBEngine::calculate_manual_slip_ratio(const TelemWheelV01& w, double car_speed_ms) {
    if (std::abs(car_speed_ms) < 2.0) return 0.0;
    double radius_m = (double)w.mStaticUndeflectedRadius / 100.0;
    if (radius_m < 0.1) radius_m = 0.33;
    
    double wheel_vel = w.mRotation * radius_m;
    double denom = std::abs(car_speed_ms);
    if (denom < 1.0) denom = 1.0;
    return (wheel_vel - car_speed_ms) / denom;
}

double FFBEngine::calculate_slope_grip(double lateral_g, double slip_angle, double dt, const TelemInfoV01* data) {
    if (m_slope_buffer_count == 0) {
        m_slope_lat_g_prev = std::abs(lateral_g);
        m_slope_lat_g_smoothed = std::abs(lateral_g);
        m_slope_slip_smoothed = std::abs(slip_angle);
        if (data) {
            m_slope_torque_smoothed = std::abs(data->mSteeringShaftTorque);
            m_slope_steer_smoothed = std::abs(data->mUnfilteredSteering);
        }
    }

    double lat_g_slew = apply_slew_limiter(std::abs(lateral_g), m_slope_lat_g_prev, (double)m_slope_g_slew_limit, dt);
    m_debug_lat_g_slew = lat_g_slew;

    double alpha_smooth = dt / (0.01 + dt);
    if (m_slope_buffer_count > 0) {
        m_slope_lat_g_smoothed += alpha_smooth * (lat_g_slew - m_slope_lat_g_smoothed);
        m_slope_slip_smoothed += alpha_smooth * (std::abs(slip_angle) - m_slope_slip_smoothed);
        if (data) {
            m_slope_torque_smoothed += alpha_smooth * (std::abs(data->mSteeringShaftTorque) - m_slope_torque_smoothed);
            m_slope_steer_smoothed += alpha_smooth * (std::abs(data->mUnfilteredSteering) - m_slope_steer_smoothed);
        }
    }

    m_slope_lat_g_buffer[m_slope_buffer_index] = m_slope_lat_g_smoothed;
    m_slope_slip_buffer[m_slope_buffer_index] = m_slope_slip_smoothed;
    if (data) {
        m_slope_torque_buffer[m_slope_buffer_index] = m_slope_torque_smoothed;
        m_slope_steer_buffer[m_slope_buffer_index] = m_slope_steer_smoothed;
    }

    m_slope_buffer_index = (m_slope_buffer_index + 1) % SLOPE_BUFFER_MAX;
    if (m_slope_buffer_count < SLOPE_BUFFER_MAX) m_slope_buffer_count++;

    double dG_dt = calculate_sg_derivative(m_slope_lat_g_buffer, m_slope_buffer_count, m_slope_sg_window, dt, m_slope_buffer_index);
    double dAlpha_dt = calculate_sg_derivative(m_slope_slip_buffer, m_slope_buffer_count, m_slope_sg_window, dt, m_slope_buffer_index);

    m_slope_dG_dt = dG_dt;
    m_slope_dAlpha_dt = dAlpha_dt;

    if (std::abs(dAlpha_dt) > (double)m_slope_alpha_threshold) {
        m_slope_hold_timer = SLOPE_HOLD_TIME;
        m_debug_slope_num = dG_dt * dAlpha_dt;
        m_debug_slope_den = (dAlpha_dt * dAlpha_dt) + 0.000001;
        m_debug_slope_raw = m_debug_slope_num / m_debug_slope_den;
        m_slope_current = std::clamp(m_debug_slope_raw, -20.0, 20.0);
    } else {
        m_slope_hold_timer -= dt;
        if (m_slope_hold_timer <= 0.0) {
            m_slope_hold_timer = 0.0;
            m_slope_current += (double)m_slope_decay_rate * dt * (0.0 - m_slope_current);
        }
    }

    volatile bool can_calc_torque = (m_slope_use_torque && data != nullptr);
    if (can_calc_torque) {
        double dTorque_dt = calculate_sg_derivative(m_slope_torque_buffer, m_slope_buffer_count, m_slope_sg_window, dt, m_slope_buffer_index);
        double dSteer_dt = calculate_sg_derivative(m_slope_steer_buffer, m_slope_buffer_count, m_slope_sg_window, dt, m_slope_buffer_index);

        if (std::abs(dSteer_dt) > (double)m_slope_alpha_threshold) {
            m_debug_slope_torque_num = dTorque_dt * dSteer_dt;
            m_debug_slope_torque_den = (dSteer_dt * dSteer_dt) + 0.000001;
            m_slope_torque_current = std::clamp(m_debug_slope_torque_num / m_debug_slope_torque_den, -50.0, 50.0);
        } else {
            m_slope_torque_current += (double)m_slope_decay_rate * dt * (0.0 - m_slope_torque_current);
        }
    } else {
        m_slope_torque_current = 20.0;
    }

    double current_grip_factor = 1.0;
    double confidence = calculate_slope_confidence(dAlpha_dt);

    double loss_percent_g = inverse_lerp((double)m_slope_min_threshold, (double)m_slope_max_threshold, m_slope_current);

    double loss_percent_torque = 0.0;
    volatile bool use_torque_fusion = (m_slope_use_torque && data != nullptr);
    if (use_torque_fusion) {
        if (m_slope_torque_current < 0.0) {
            loss_percent_torque = std::abs(m_slope_torque_current) * (double)m_slope_torque_sensitivity;
            loss_percent_torque = (std::max)(0.0, (std::min)(1.0, loss_percent_torque));
        }
    }

    double loss_percent = (std::max)(loss_percent_g, loss_percent_torque);
    current_grip_factor = 1.0 - (loss_percent * 0.8 * confidence);
    current_grip_factor = (std::max)(0.2, (std::min)(1.0, current_grip_factor));

    double alpha = dt / ((double)m_slope_smoothing_tau + dt);
    alpha = (std::max)(0.001, (std::min)(1.0, alpha));
    m_slope_smoothed_output += alpha * (current_grip_factor - m_slope_smoothed_output);

    return m_slope_smoothed_output;
}

double FFBEngine::calculate_slope_confidence(double dAlpha_dt) {
    if (!m_slope_confidence_enabled) return 1.0;
    return smoothstep((double)m_slope_alpha_threshold, (double)m_slope_confidence_max_rate, std::abs(dAlpha_dt));
}

double FFBEngine::calculate_wheel_slip_ratio(const TelemWheelV01& w) {
    double v_long = std::abs(w.mLongitudinalGroundVel);
    if (v_long < MIN_SLIP_ANGLE_VELOCITY) v_long = MIN_SLIP_ANGLE_VELOCITY;
    return w.mLongitudinalPatchVel / v_long;
}

double FFBEngine::apply_signal_conditioning(double raw_torque, const TelemInfoV01* data, FFBCalculationContext& ctx) {
    double game_force_proc = raw_torque;

    double effective_shaft_smoothing = (double)m_steering_shaft_smoothing;
    double idle_speed_threshold = (double)m_speed_gate_upper;
    if (idle_speed_threshold < 3.0) idle_speed_threshold = 3.0;
    if (ctx.car_speed < idle_speed_threshold) {
        double idle_blend = (idle_speed_threshold - ctx.car_speed) / idle_speed_threshold;
        double dynamic_smooth = 0.1 * idle_blend; 
        effective_shaft_smoothing = (std::max)(effective_shaft_smoothing, dynamic_smooth);
    }
    
    if (effective_shaft_smoothing > 0.0001) {
        double alpha_shaft = ctx.dt / (effective_shaft_smoothing + ctx.dt);
        alpha_shaft = (std::min)(1.0, (std::max)(0.001, alpha_shaft));
        m_steering_shaft_torque_smoothed += alpha_shaft * (game_force_proc - m_steering_shaft_torque_smoothed);
        game_force_proc = m_steering_shaft_torque_smoothed;
    } else {
        m_steering_shaft_torque_smoothed = game_force_proc;
    }

    double alpha_hpf = ctx.dt / (0.1 + ctx.dt);
    m_torque_ac_smoothed += alpha_hpf * (game_force_proc - m_torque_ac_smoothed);
    double ac_torque = game_force_proc - m_torque_ac_smoothed;

    if ((m_prev_ac_torque < -0.05 && ac_torque > 0.05) ||
        (m_prev_ac_torque > 0.05 && ac_torque < -0.05)) {

        double now = data->mElapsedTime;
        double period = now - m_last_crossing_time;

        if (period > 0.005 && period < 1.0) {
            double inst_freq = 1.0 / (period * 2.0);
            m_debug_freq = m_debug_freq * 0.9 + inst_freq * 0.1;
        }
        m_last_crossing_time = now;
    }
    m_prev_ac_torque = ac_torque;

    const TelemWheelV01& fl_ref = data->mWheel[0];
    double radius = (double)fl_ref.mStaticUndeflectedRadius / 100.0;
    if (radius < 0.1) radius = 0.33;
    double circumference = 2.0 * PI * radius;
    double wheel_freq = (circumference > 0.0) ? (ctx.car_speed / circumference) : 0.0;
    m_theoretical_freq = wheel_freq;
    
    if (m_flatspot_suppression) {
        if (wheel_freq > 1.0) {
            m_notch_filter.Update(wheel_freq, 1.0/ctx.dt, (double)m_notch_q);
            double input_force = game_force_proc;
            double filtered_force = m_notch_filter.Process(input_force);
            game_force_proc = input_force * (1.0f - m_flatspot_strength) + filtered_force * m_flatspot_strength;
        } else {
            m_notch_filter.Reset();
        }
    }
    
    if (m_static_notch_enabled) {
         double bw = (double)m_static_notch_width;
         if (bw < 0.1) bw = 0.1;
         double q = (double)m_static_notch_freq / bw;
         m_static_notch_filter.Update((double)m_static_notch_freq, 1.0/ctx.dt, q);
         game_force_proc = m_static_notch_filter.Process(game_force_proc);
    } else {
         m_static_notch_filter.Reset();
    }

    return game_force_proc;
}

double FFBEngine::calculate_force(const TelemInfoV01* data, const char* vehicleClass, const char* vehicleName, float genFFBTorque) {
    if (!data) return 0.0;

    double raw_torque_input = (m_torque_source == 1) ? (double)genFFBTorque : data->mSteeringShaftTorque;

    if (!std::isfinite(raw_torque_input)) return 0.0;

    bool seeded = false;
    if (vehicleClass && m_current_class_name != vehicleClass) {
        m_current_class_name = vehicleClass;
        InitializeLoadReference(vehicleClass, vehicleName);
        seeded = true;
    }
    
    FFBCalculationContext ctx;
    ctx.dt = data->mDeltaTime;

    if (ctx.dt <= 0.000001) {
        ctx.dt = 0.0025; 
        if (!m_warned_dt) {
            std::cout << "[WARNING] Invalid DeltaTime (<=0). Using default 0.0025s." << std::endl;
            m_warned_dt = true;
        }
        ctx.frame_warn_dt = true;
    }
    
    ctx.car_speed_long = data->mLocalVel.z;
    ctx.car_speed = std::abs(ctx.car_speed_long);
    
    if (m_vehicle_name[0] != data->mVehicleName[0] || m_vehicle_name[10] != data->mVehicleName[10]) {
#ifdef _WIN32
         strncpy_s(m_vehicle_name, data->mVehicleName, 63);
         m_vehicle_name[63] = '\0';
         strncpy_s(m_track_name, data->mTrackName, 63);
         m_track_name[63] = '\0';
#else
         strncpy(m_vehicle_name, data->mVehicleName, 63);
         m_vehicle_name[63] = '\0';
         strncpy(m_track_name, data->mTrackName, 63);
         m_track_name[63] = '\0';
#endif
    }

    double chassis_tau = (double)m_chassis_inertia_smoothing;
    if (chassis_tau < 0.0001) chassis_tau = 0.0001;
    double alpha_chassis = ctx.dt / (chassis_tau + ctx.dt);
    m_accel_x_smoothed += alpha_chassis * (data->mLocalAccel.x - m_accel_x_smoothed);
    m_accel_z_smoothed += alpha_chassis * (data->mLocalAccel.z - m_accel_z_smoothed);

    const TelemWheelV01& fl = data->mWheel[0];
    const TelemWheelV01& fr = data->mWheel[1];

    double raw_torque = raw_torque_input;
    double raw_load = (fl.mTireLoad + fr.mTireLoad) / 2.0;
    double raw_grip = (fl.mGripFract + fr.mGripFract) / 2.0;

    s_torque.Update(raw_torque);
    s_load.Update(raw_load);
    s_grip.Update(raw_grip);
    s_lat_g.Update(data->mLocalAccel.x);
    
    auto now = std::chrono::steady_clock::now();
    if (std::chrono::duration_cast<std::chrono::seconds>(now - last_log_time).count() >= 1) {
        s_torque.ResetInterval(); 
        s_load.ResetInterval(); 
        s_grip.ResetInterval(); 
        s_lat_g.ResetInterval();
        last_log_time = now;
    }

    ctx.avg_load = raw_load;

    if (ctx.avg_load < 1.0 && ctx.car_speed > 1.0) {
        m_missing_load_frames++;
    } else {
        m_missing_load_frames = (std::max)(0, m_missing_load_frames - 1);
    }

    if (m_missing_load_frames > 20) {
        if (fl.mSuspForce > MIN_VALID_SUSP_FORCE) {
            double calc_load_fl = approximate_load(fl);
            double calc_load_fr = approximate_load(fr);
            ctx.avg_load = (calc_load_fl + calc_load_fr) / 2.0;
        } else {
            double kin_load_fl = calculate_kinematic_load(data, 0);
            double kin_load_fr = calculate_kinematic_load(data, 1);
            ctx.avg_load = (kin_load_fl + kin_load_fr) / 2.0;
        }
        if (!m_warned_load) {
            std::cout << "Warning: Data for mTireLoad from the game seems to be missing for this car (" << data->mVehicleName << "). (Likely Encrypted/DLC Content). Using Kinematic Fallback." << std::endl;
            m_warned_load = true;
        }
        ctx.frame_warn_load = true;
    }

    double avg_susp_f = (fl.mSuspForce + fr.mSuspForce) / 2.0;
    if (avg_susp_f < MIN_VALID_SUSP_FORCE && std::abs(data->mLocalVel.z) > 1.0) {
        m_missing_susp_force_frames++;
    } else {
         m_missing_susp_force_frames = (std::max)(0, m_missing_susp_force_frames - 1);
    }
    if (m_missing_susp_force_frames > 50 && !m_warned_susp_force) {
         std::cout << "Warning: Data for mSuspForce from the game seems to be missing for this car (" << data->mVehicleName << "). (Likely Encrypted/DLC Content). A fallback estimation will be used." << std::endl;
         m_warned_susp_force = true;
    }

    double avg_susp_def = (std::abs(fl.mSuspensionDeflection) + std::abs(fr.mSuspensionDeflection)) / 2.0;
    if (avg_susp_def < 0.000001 && std::abs(data->mLocalVel.z) > 10.0) {
        m_missing_susp_deflection_frames++;
    } else {
        m_missing_susp_deflection_frames = (std::max)(0, m_missing_susp_deflection_frames - 1);
    }
    if (m_missing_susp_deflection_frames > 50 && !m_warned_susp_deflection) {
        std::cout << "Warning: Data for mSuspensionDeflection from the game seems to be missing for this car (" << data->mVehicleName << "). (Likely Encrypted/DLC Content). A fallback estimation will be used." << std::endl;
        m_warned_susp_deflection = true;
    }

    double avg_lat_force_front = (std::abs(fl.mLateralForce) + std::abs(fr.mLateralForce)) / 2.0;
    if (avg_lat_force_front < 1.0 && std::abs(data->mLocalAccel.x) > 3.0) {
        m_missing_lat_force_front_frames++;
    } else {
        m_missing_lat_force_front_frames = (std::max)(0, m_missing_lat_force_front_frames - 1);
    }
    if (m_missing_lat_force_front_frames > 50 && !m_warned_lat_force_front) {
         std::cout << "Warning: Data for mLateralForce (Front) from the game seems to be missing for this car (" << data->mVehicleName << "). (Likely Encrypted/DLC Content). A fallback estimation will be used." << std::endl;
         m_warned_lat_force_front = true;
    }

    double avg_lat_force_rear = (std::abs(data->mWheel[2].mLateralForce) + std::abs(data->mWheel[3].mLateralForce)) / 2.0;
    if (avg_lat_force_rear < 1.0 && std::abs(data->mLocalAccel.x) > 3.0) {
        m_missing_lat_force_rear_frames++;
    } else {
        m_missing_lat_force_rear_frames = (std::max)(0, m_missing_lat_force_rear_frames - 1);
    }
    if (m_missing_lat_force_rear_frames > 50 && !m_warned_lat_force_rear) {
         std::cout << "Warning: Data for mLateralForce (Rear) from the game seems to be missing for this car (" << data->mVehicleName << "). (Likely Encrypted/DLC Content). A fallback estimation will be used." << std::endl;
         m_warned_lat_force_rear = true;
    }

    double avg_vert_def = (std::abs(fl.mVerticalTireDeflection) + std::abs(fr.mVerticalTireDeflection)) / 2.0;
    if (avg_vert_def < 0.000001 && std::abs(data->mLocalVel.z) > 10.0) {
        m_missing_vert_deflection_frames++;
    } else {
        m_missing_vert_deflection_frames = (std::max)(0, m_missing_vert_deflection_frames - 1);
    }
    if (m_missing_vert_deflection_frames > 50 && !m_warned_vert_deflection) {
        std::cout << "[WARNING] mVerticalTireDeflection is missing for car: " << data->mVehicleName 
                  << ". (Likely Encrypted/DLC Content). Road Texture fallback active." << std::endl;
        m_warned_vert_deflection = true;
    }
    
    if (m_auto_load_normalization_enabled && !seeded) {
        if (ctx.avg_load > m_auto_peak_load) {
            m_auto_peak_load = ctx.avg_load; 
        } else {
            m_auto_peak_load -= (100.0 * ctx.dt); 
        }
    }
    m_auto_peak_load = (std::max)(3000.0, m_auto_peak_load); 

    double raw_load_factor = ctx.avg_load / m_auto_peak_load;
    double texture_safe_max = (std::min)(10.0, (double)m_texture_load_cap);
    ctx.texture_load_factor = (std::min)(texture_safe_max, (std::max)(0.0, raw_load_factor));

    double brake_safe_max = (std::min)(10.0, (double)m_brake_load_cap);
    ctx.brake_load_factor = (std::min)(brake_safe_max, (std::max)(0.0, raw_load_factor));
    
    double max_torque_safe = (double)m_max_torque_ref;
    if (max_torque_safe < 1.0) max_torque_safe = 1.0;
    ctx.decoupling_scale = max_torque_safe / 20.0;
    if (ctx.decoupling_scale < 0.1) ctx.decoupling_scale = 0.1;

    ctx.speed_gate = smoothstep(
        (double)m_speed_gate_lower, 
        (double)m_speed_gate_upper, 
        ctx.car_speed
    );

    GripResult front_grip_res = calculate_grip(fl, fr, ctx.avg_load, m_warned_grip, 
                                                m_prev_slip_angle[0], m_prev_slip_angle[1],
                                                ctx.car_speed, ctx.dt, data->mVehicleName, data, true);
    ctx.avg_grip = front_grip_res.value;
    m_grip_diag.front_original = front_grip_res.original;
    m_grip_diag.front_approximated = front_grip_res.approximated;
    m_grip_diag.front_slip_angle = front_grip_res.slip_angle;
    if (front_grip_res.approximated) ctx.frame_warn_grip = true;

    double game_force_proc = apply_signal_conditioning(raw_torque_input, data, ctx);

    double base_input = 0.0;
    if (m_base_force_mode == 0) {
        base_input = game_force_proc;
    } else if (m_base_force_mode == 1) {
        if (std::abs(game_force_proc) > SYNTHETIC_MODE_DEADZONE_NM) {
            double sign = (game_force_proc > 0.0) ? 1.0 : -1.0;
            base_input = sign * (double)m_max_torque_ref;
        }
    }
    
    double grip_loss = (1.0 - ctx.avg_grip) * m_understeer_effect;
    ctx.grip_factor = (std::max)(0.0, 1.0 - grip_loss);

    update_static_load_reference(ctx.avg_load, ctx.car_speed, ctx.dt);
    double dynamic_weight_factor = 1.0;

    if (m_dynamic_weight_gain > 0.0 && !ctx.frame_warn_load) {
        double load_ratio = ctx.avg_load / m_static_front_load;
        dynamic_weight_factor = 1.0 + (load_ratio - 1.0) * (double)m_dynamic_weight_gain;
        dynamic_weight_factor = std::clamp(dynamic_weight_factor, 0.5, 2.0);
    }

    double dw_alpha = ctx.dt / ((double)m_dynamic_weight_smoothing + ctx.dt + 1e-9);
    dw_alpha = (std::max)(0.0, (std::min)(1.0, dw_alpha));
    m_dynamic_weight_smoothed += dw_alpha * (dynamic_weight_factor - m_dynamic_weight_smoothed);
    dynamic_weight_factor = m_dynamic_weight_smoothed;
    
    double output_force = (base_input * (double)m_steering_shaft_gain) * dynamic_weight_factor * ctx.grip_factor;
    output_force *= ctx.speed_gate;
    
    calculate_sop_lateral(data, ctx);
    
    calculate_gyro_damping(data, ctx);
    
    calculate_abs_pulse(data, ctx);
    calculate_lockup_vibration(data, ctx);
    calculate_wheel_spin(data, ctx);
    calculate_slide_texture(data, ctx);
    calculate_road_texture(data, ctx);
    calculate_suspension_bottoming(data, ctx);
    
    double structural_sum = output_force + ctx.sop_base_force + ctx.rear_torque + ctx.yaw_force + ctx.gyro_force +
                            ctx.abs_pulse_force + ctx.lockup_rumble + ctx.scrub_drag_force;

    structural_sum *= ctx.gain_reduction_factor;
    
    double texture_sum = ctx.road_noise + ctx.slide_noise + ctx.spin_rumble + ctx.bottoming_crunch;

    double total_sum = structural_sum + texture_sum;

    double norm_force = total_sum / max_torque_safe;
    norm_force *= m_gain;

    if (std::abs(norm_force) > 0.0001 && std::abs(norm_force) < m_min_force) {
        double sign = (norm_force > 0.0) ? 1.0 : -1.0;
        norm_force = sign * m_min_force;
    }

    if (m_invert_force) {
        norm_force *= -1.0;
    }

    for (int i = 0; i < 4; i++) {
        m_prev_vert_deflection[i] = data->mWheel[i].mVerticalTireDeflection;
        m_prev_rotation[i] = data->mWheel[i].mRotation;
        m_prev_brake_pressure[i] = data->mWheel[i].mBrakePressure;
    }
    m_prev_susp_force[0] = fl.mSuspForce;
    m_prev_susp_force[1] = fr.mSuspForce;
    
    m_prev_vert_accel = data->mLocalAccel.y;

    {
        std::lock_guard<std::mutex> lock(m_debug_mutex);
        if (m_debug_buffer.size() < 100) {
            FFBSnapshot snap;
            snap.total_output = (float)norm_force;
            snap.base_force = (float)base_input;
            snap.sop_force = (float)ctx.sop_unboosted_force; 
            snap.understeer_drop = (float)((base_input * m_steering_shaft_gain) * (1.0 - ctx.grip_factor));
            snap.oversteer_boost = (float)(ctx.sop_base_force - ctx.sop_unboosted_force); 

            snap.ffb_rear_torque = (float)ctx.rear_torque;
            snap.ffb_scrub_drag = (float)ctx.scrub_drag_force;
            snap.ffb_yaw_kick = (float)ctx.yaw_force;
            snap.ffb_gyro_damping = (float)ctx.gyro_force;
            snap.texture_road = (float)ctx.road_noise;
            snap.texture_slide = (float)ctx.slide_noise;
            snap.texture_lockup = (float)ctx.lockup_rumble;
            snap.texture_spin = (float)ctx.spin_rumble;
            snap.texture_bottoming = (float)ctx.bottoming_crunch;
            snap.ffb_abs_pulse = (float)ctx.abs_pulse_force; 
            snap.clipping = (std::abs(norm_force) > 0.99f) ? 1.0f : 0.0f;

            snap.calc_front_load = (float)ctx.avg_load;
            snap.calc_rear_load = (float)ctx.avg_rear_load;
            snap.calc_rear_lat_force = (float)ctx.calc_rear_lat_force;
            snap.calc_front_grip = (float)ctx.avg_grip;
            snap.calc_rear_grip = (float)ctx.avg_rear_grip;
            snap.calc_front_slip_angle_smoothed = (float)m_grip_diag.front_slip_angle;
            snap.calc_rear_slip_angle_smoothed = (float)m_grip_diag.rear_slip_angle;

            snap.raw_front_slip_angle = (float)calculate_raw_slip_angle_pair(fl, fr);
            snap.raw_rear_slip_angle = (float)calculate_raw_slip_angle_pair(data->mWheel[2], data->mWheel[3]);

            snap.steer_force = (float)raw_torque;
            snap.raw_input_steering = (float)data->mUnfilteredSteering;
            snap.raw_front_tire_load = (float)raw_load;
            snap.raw_front_grip_fract = (float)raw_grip;
            snap.raw_rear_grip = (float)((data->mWheel[2].mGripFract + data->mWheel[3].mGripFract) / 2.0);
            snap.raw_front_susp_force = (float)((fl.mSuspForce + fr.mSuspForce) / 2.0);
            snap.raw_front_ride_height = (float)((std::min)(fl.mRideHeight, fr.mRideHeight));
            snap.raw_rear_lat_force = (float)((data->mWheel[2].mLateralForce + data->mWheel[3].mLateralForce) / 2.0);
            snap.raw_car_speed = (float)ctx.car_speed_long;
            snap.raw_input_throttle = (float)data->mUnfilteredThrottle;
            snap.raw_input_brake = (float)data->mUnfilteredBrake;
            snap.accel_x = (float)data->mLocalAccel.x;
            snap.raw_front_lat_patch_vel = (float)((std::abs(fl.mLateralPatchVel) + std::abs(fr.mLateralPatchVel)) / 2.0);
            snap.raw_front_deflection = (float)((fl.mVerticalTireDeflection + fr.mVerticalTireDeflection) / 2.0);
            snap.raw_front_long_patch_vel = (float)((fl.mLongitudinalPatchVel + fr.mLongitudinalPatchVel) / 2.0);
            snap.raw_rear_lat_patch_vel = (float)((std::abs(data->mWheel[2].mLateralPatchVel) + std::abs(data->mWheel[3].mLateralPatchVel)) / 2.0);
            snap.raw_rear_long_patch_vel = (float)((data->mWheel[2].mLongitudinalPatchVel + data->mWheel[3].mLongitudinalPatchVel) / 2.0);

            snap.warn_load = ctx.frame_warn_load;
            snap.warn_grip = ctx.frame_warn_grip || ctx.frame_warn_rear_grip;
            snap.warn_dt = ctx.frame_warn_dt;
            snap.debug_freq = (float)m_debug_freq;
            snap.tire_radius = (float)fl.mStaticUndeflectedRadius / 100.0f;
            snap.slope_current = (float)m_slope_current; 

            snap.ffb_rate = (float)m_ffb_rate;
            snap.telemetry_rate = (float)m_telemetry_rate;
            snap.hw_rate = (float)m_hw_rate;
            snap.torque_rate = (float)m_torque_rate;
            snap.gen_torque_rate = (float)m_gen_torque_rate;

            m_debug_buffer.push_back(snap);
        }
    }
    
    if (AsyncLogger::Get().IsLogging()) {
        LogFrame frame;
        frame.timestamp = data->mElapsedTime;
        frame.delta_time = data->mDeltaTime;
        
        frame.steering = (float)data->mUnfilteredSteering;
        frame.throttle = (float)data->mUnfilteredThrottle;
        frame.brake = (float)data->mUnfilteredBrake;
        
        frame.speed = (float)ctx.car_speed;
        frame.lat_accel = (float)data->mLocalAccel.x;
        frame.long_accel = (float)data->mLocalAccel.z;
        frame.yaw_rate = (float)data->mLocalRot.y;
        
        frame.slip_angle_fl = (float)fl.mLateralPatchVel / (float)(std::max)(1.0, ctx.car_speed);
        frame.slip_angle_fr = (float)fr.mLateralPatchVel / (float)(std::max)(1.0, ctx.car_speed);
        frame.slip_ratio_fl = (float)calculate_wheel_slip_ratio(fl);
        frame.slip_ratio_fr = (float)calculate_wheel_slip_ratio(fr);
        frame.grip_fl = (float)fl.mGripFract;
        frame.grip_fr = (float)fr.mGripFract;
        frame.load_fl = (float)fl.mTireLoad;
        frame.load_fr = (float)fr.mTireLoad;
        
        frame.calc_slip_angle_front = (float)m_grip_diag.front_slip_angle;
        frame.calc_grip_front = (float)ctx.avg_grip;
        
        frame.dG_dt = (float)m_slope_dG_dt;
        frame.dAlpha_dt = (float)m_slope_dAlpha_dt;
        frame.slope_current = (float)m_slope_current;
        frame.slope_raw_unclamped = (float)m_debug_slope_raw;
        frame.slope_numerator = (float)m_debug_slope_num;
        frame.slope_denominator = (float)m_debug_slope_den;
        frame.hold_timer = (float)m_slope_hold_timer;
        frame.input_slip_smoothed = (float)m_slope_slip_smoothed;
        frame.slope_smoothed = (float)m_slope_smoothed_output;
        
        frame.confidence = (float)calculate_slope_confidence(m_slope_dAlpha_dt);
        
        frame.surface_type_fl = (float)fl.mSurfaceType;
        frame.surface_type_fr = (float)fr.mSurfaceType;

        frame.slope_torque = (float)m_slope_torque_current;
        frame.slew_limited_g = (float)m_debug_lat_g_slew;

        frame.calc_grip_rear = (float)ctx.avg_rear_grip;
        frame.grip_delta = (float)(ctx.avg_grip - ctx.avg_rear_grip);
        
        frame.ffb_total = (float)norm_force;
        frame.ffb_grip_factor = (float)ctx.grip_factor;
        frame.ffb_sop = (float)ctx.sop_base_force;
        frame.speed_gate = (float)ctx.speed_gate;
        frame.load_peak_ref = (float)m_auto_peak_load;
        frame.clipping = (std::abs(norm_force) > 0.99);
        frame.ffb_base = (float)base_input;
        
        AsyncLogger::Get().Log(frame);
    }
    
    return (std::max)(-1.0, (std::min)(1.0, norm_force));
}

void FFBEngine::calculate_sop_lateral(const TelemInfoV01* data, FFBCalculationContext& ctx) {
    double raw_g = (std::max)(-49.05, (std::min)(49.05, data->mLocalAccel.x));
    double lat_g = (raw_g / 9.81);
    
    double smoothness = 1.0 - (double)m_sop_smoothing_factor;
    smoothness = (std::max)(0.0, (std::min)(0.999, smoothness));
    double tau = smoothness * 0.1;
    double alpha = ctx.dt / (tau + ctx.dt);
    alpha = (std::max)(0.001, (std::min)(1.0, alpha));
    m_sop_lat_g_smoothed += alpha * (lat_g - m_sop_lat_g_smoothed);
    
    double sop_base = m_sop_lat_g_smoothed * m_sop_effect * (double)m_sop_scale * ctx.decoupling_scale;
    ctx.sop_unboosted_force = sop_base; 
    
    GripResult rear_grip_res = calculate_grip(data->mWheel[2], data->mWheel[3], ctx.avg_load, m_warned_rear_grip,
                                                m_prev_slip_angle[2], m_prev_slip_angle[3],
                                                ctx.car_speed, ctx.dt, data->mVehicleName, data, false);
    ctx.avg_rear_grip = rear_grip_res.value;
    m_grip_diag.rear_original = rear_grip_res.original;
    m_grip_diag.rear_approximated = rear_grip_res.approximated;
    m_grip_diag.rear_slip_angle = rear_grip_res.slip_angle;
    if (rear_grip_res.approximated) ctx.frame_warn_rear_grip = true;
    
    if (!m_slope_detection_enabled) {
        double grip_delta = ctx.avg_grip - ctx.avg_rear_grip;
        if (grip_delta > 0.0) {
            sop_base *= (1.0 + (grip_delta * m_oversteer_boost * 2.0));
        }
    }
    ctx.sop_base_force = sop_base;
    
    double calc_load_rl = approximate_rear_load(data->mWheel[2]);
    double calc_load_rr = approximate_rear_load(data->mWheel[3]);
    ctx.avg_rear_load = (calc_load_rl + calc_load_rr) / 2.0;
    
    double rear_slip_angle = m_grip_diag.rear_slip_angle;
    ctx.calc_rear_lat_force = rear_slip_angle * ctx.avg_rear_load * REAR_TIRE_STIFFNESS_COEFFICIENT;
    ctx.calc_rear_lat_force = (std::max)(-MAX_REAR_LATERAL_FORCE, (std::min)(MAX_REAR_LATERAL_FORCE, ctx.calc_rear_lat_force));
    
    ctx.rear_torque = -ctx.calc_rear_lat_force * REAR_ALIGN_TORQUE_COEFFICIENT * m_rear_align_effect * ctx.decoupling_scale;
    
    double raw_yaw_accel = data->mLocalRotAccel.y;
    if (ctx.car_speed < 5.0) raw_yaw_accel = 0.0;
    else if (std::abs(raw_yaw_accel) < (double)m_yaw_kick_threshold) raw_yaw_accel = 0.0;
    
    double tau_yaw = (double)m_yaw_accel_smoothing;
    if (tau_yaw < 0.0001) tau_yaw = 0.0001;
    double alpha_yaw = ctx.dt / (tau_yaw + ctx.dt);
    m_yaw_accel_smoothed += alpha_yaw * (raw_yaw_accel - m_yaw_accel_smoothed);
    
    ctx.yaw_force = -1.0 * m_yaw_accel_smoothed * m_sop_yaw_gain * (double)BASE_NM_YAW_KICK * ctx.decoupling_scale;
    
    ctx.sop_base_force *= ctx.speed_gate;
    ctx.rear_torque *= ctx.speed_gate;
    ctx.yaw_force *= ctx.speed_gate;
}

void FFBEngine::calculate_gyro_damping(const TelemInfoV01* data, FFBCalculationContext& ctx) {
    float range = data->mPhysicalSteeringWheelRange;
    if (range <= 0.0f) range = (float)DEFAULT_STEERING_RANGE_RAD;
    double steer_angle = data->mUnfilteredSteering * (range / 2.0);
    double steer_vel = (steer_angle - m_prev_steering_angle) / ctx.dt;
    m_prev_steering_angle = steer_angle;
    
    double tau_gyro = (double)m_gyro_smoothing;
    if (tau_gyro < 0.0001) tau_gyro = 0.0001;
    double alpha_gyro = ctx.dt / (tau_gyro + ctx.dt);
    m_steering_velocity_smoothed += alpha_gyro * (steer_vel - m_steering_velocity_smoothed);
    
    ctx.gyro_force = -1.0 * m_steering_velocity_smoothed * m_gyro_gain * (ctx.car_speed / GYRO_SPEED_SCALE) * ctx.decoupling_scale;
}

void FFBEngine::calculate_abs_pulse(const TelemInfoV01* data, FFBCalculationContext& ctx) {
    if (!m_abs_pulse_enabled) return;
    
    bool abs_active = false;
    for (int i = 0; i < 4; i++) {
        double pressure_delta = (data->mWheel[i].mBrakePressure - m_prev_brake_pressure[i]) / ctx.dt;
        if (data->mUnfilteredBrake > ABS_PEDAL_THRESHOLD && std::abs(pressure_delta) > ABS_PRESSURE_RATE_THRESHOLD) {
            abs_active = true;
            break;
        }
    }
    
    if (abs_active) {
        m_abs_phase += (double)m_abs_freq_hz * ctx.dt * TWO_PI;
        m_abs_phase = std::fmod(m_abs_phase, TWO_PI);
        ctx.abs_pulse_force = (double)(std::sin(m_abs_phase) * m_abs_gain * 2.0 * ctx.decoupling_scale * ctx.speed_gate);
    }
}

void FFBEngine::calculate_lockup_vibration(const TelemInfoV01* data, FFBCalculationContext& ctx) {
    if (!m_lockup_enabled) return;
    
    double worst_severity = 0.0;
    double chosen_freq_multiplier = 1.0;
    double chosen_pressure_factor = 0.0;
    
    double slip_fl = calculate_wheel_slip_ratio(data->mWheel[0]);
    double slip_fr = calculate_wheel_slip_ratio(data->mWheel[1]);
    double worst_front = (std::min)(slip_fl, slip_fr);

    for (int i = 0; i < 4; i++) {
        const auto& w = data->mWheel[i];
        double slip = calculate_wheel_slip_ratio(w);
        double slip_abs = std::abs(slip);
        double wheel_accel = (w.mRotation - m_prev_rotation[i]) / ctx.dt;
        double radius = (double)w.mStaticUndeflectedRadius / 100.0;
        if (radius < 0.1) radius = 0.33;
        double car_dec_ang = -std::abs(data->mLocalAccel.z / radius);
        double susp_vel = std::abs(w.mVerticalTireDeflection - m_prev_vert_deflection[i]) / ctx.dt;
        bool is_bumpy = (susp_vel > (double)m_lockup_bump_reject);
        bool brake_active = (data->mUnfilteredBrake > PREDICTION_BRAKE_THRESHOLD);
        bool is_grounded = (w.mSuspForce > PREDICTION_LOAD_THRESHOLD);

        double start_threshold = (double)m_lockup_start_pct / 100.0;
        double full_threshold = (double)m_lockup_full_pct / 100.0;
        double trigger_threshold = full_threshold;

        if (brake_active && is_grounded && !is_bumpy) {
            double sensitivity_threshold = -1.0 * (double)m_lockup_prediction_sens;
            if (wheel_accel < car_dec_ang * 2.0 && wheel_accel < sensitivity_threshold) {
                trigger_threshold = start_threshold;
            }
        }

        if (slip_abs > trigger_threshold) {
            double window = full_threshold - start_threshold;
            if (window < 0.01) window = 0.01;
            double normalized = (slip_abs - start_threshold) / window;
            double severity = (std::min)(1.0, (std::max)(0.0, normalized));
            severity = std::pow(severity, (double)m_lockup_gamma);
            
            double freq_mult = 1.0;
            if (i >= 2) {
                if (slip < (worst_front - AXLE_DIFF_HYSTERESIS)) {
                    freq_mult = LOCKUP_FREQ_MULTIPLIER_REAR;
                }
            }
            double pressure_factor = w.mBrakePressure;
            if (pressure_factor < 0.1 && slip_abs > 0.5) pressure_factor = 0.5;

            if (severity > worst_severity) {
                worst_severity = severity;
                chosen_freq_multiplier = freq_mult;
                chosen_pressure_factor = pressure_factor;
            }
        }
    }

    if (worst_severity > 0.0) {
        double base_freq = 10.0 + (ctx.car_speed * 1.5);
        double final_freq = base_freq * chosen_freq_multiplier * (double)m_lockup_freq_scale;
        m_lockup_phase += final_freq * ctx.dt * TWO_PI;
        m_lockup_phase = std::fmod(m_lockup_phase, TWO_PI);
        double amp = worst_severity * chosen_pressure_factor * m_lockup_gain * (double)BASE_NM_LOCKUP_VIBRATION * ctx.decoupling_scale * ctx.brake_load_factor;
        if (chosen_freq_multiplier < 1.0) amp *= (double)m_lockup_rear_boost;
        ctx.lockup_rumble = std::sin(m_lockup_phase) * amp * ctx.speed_gate;
    }
}

void FFBEngine::calculate_wheel_spin(const TelemInfoV01* data, FFBCalculationContext& ctx) {
    if (m_spin_enabled && data->mUnfilteredThrottle > 0.05) {
        double slip_rl = calculate_wheel_slip_ratio(data->mWheel[2]);
        double slip_rr = calculate_wheel_slip_ratio(data->mWheel[3]);
        double max_slip = (std::max)(slip_rl, slip_rr);
        
        if (max_slip > 0.2) {
            double severity = (max_slip - 0.2) / 0.5;
            severity = (std::min)(1.0, severity);
            
            ctx.gain_reduction_factor = (1.0 - (severity * m_spin_gain * 0.6));
            
            double slip_speed_ms = ctx.car_speed * max_slip;
            double freq = (10.0 + (slip_speed_ms * 2.5)) * (double)m_spin_freq_scale;
            if (freq > 80.0) freq = 80.0;
            m_spin_phase += freq * ctx.dt * TWO_PI;
            m_spin_phase = std::fmod(m_spin_phase, TWO_PI);
            double amp = severity * m_spin_gain * (double)BASE_NM_SPIN_VIBRATION * ctx.decoupling_scale;
            ctx.spin_rumble = std::sin(m_spin_phase) * amp;
        }
    }
}

void FFBEngine::calculate_slide_texture(const TelemInfoV01* data, FFBCalculationContext& ctx) {
    if (!m_slide_texture_enabled) return;
    double lat_vel_fl = std::abs(data->mWheel[0].mLateralPatchVel);
    double lat_vel_fr = std::abs(data->mWheel[1].mLateralPatchVel);
    double front_slip_avg = (lat_vel_fl + lat_vel_fr) / 2.0;
    double lat_vel_rl = std::abs(data->mWheel[2].mLateralPatchVel);
    double lat_vel_rr = std::abs(data->mWheel[3].mLateralPatchVel);
    double rear_slip_avg = (lat_vel_rl + lat_vel_rr) / 2.0;
    double effective_slip_vel = (std::max)(front_slip_avg, rear_slip_avg);
    
    if (effective_slip_vel > 1.5) {
        double base_freq = 10.0 + (effective_slip_vel * 5.0);
        double freq = base_freq * (double)m_slide_freq_scale;
        if (freq > 250.0) freq = 250.0;
        m_slide_phase += freq * ctx.dt * TWO_PI;
        m_slide_phase = std::fmod(m_slide_phase, TWO_PI);
        double sawtooth = (m_slide_phase / TWO_PI) * 2.0 - 1.0;
        double grip_scale = (std::max)(0.0, 1.0 - ctx.avg_grip);
        ctx.slide_noise = sawtooth * m_slide_texture_gain * (double)BASE_NM_SLIDE_TEXTURE * ctx.texture_load_factor * grip_scale * ctx.decoupling_scale;
    }
}

void FFBEngine::calculate_road_texture(const TelemInfoV01* data, FFBCalculationContext& ctx) {
    if (m_scrub_drag_gain > 0.0) {
        double avg_lat_vel = (data->mWheel[0].mLateralPatchVel + data->mWheel[1].mLateralPatchVel) / 2.0;
        double abs_lat_vel = std::abs(avg_lat_vel);
        if (abs_lat_vel > 0.001) {
            double fade = (std::min)(1.0, abs_lat_vel / 0.5);
            double drag_dir = (avg_lat_vel > 0.0) ? -1.0 : 1.0;
            ctx.scrub_drag_force = drag_dir * m_scrub_drag_gain * (double)BASE_NM_SCRUB_DRAG * fade * ctx.decoupling_scale;
        }
    }

    if (!m_road_texture_enabled) return;
    
    double delta_l = data->mWheel[0].mVerticalTireDeflection - m_prev_vert_deflection[0];
    double delta_r = data->mWheel[1].mVerticalTireDeflection - m_prev_vert_deflection[1];
    delta_l = (std::max)(-0.01, (std::min)(0.01, delta_l));
    delta_r = (std::max)(-0.01, (std::min)(0.01, delta_r));
    
    double road_noise_val = 0.0;
    bool deflection_active = (std::abs(delta_l) > 0.000001 || std::abs(delta_r) > 0.000001);
    
    if (deflection_active || ctx.car_speed < 5.0) {
        road_noise_val = (delta_l + delta_r) * 50.0;
    } else {
        double vert_accel = data->mLocalAccel.y;
        double delta_accel = vert_accel - m_prev_vert_accel;
        road_noise_val = delta_accel * 0.05 * 50.0;
    }
    
    ctx.road_noise = road_noise_val * m_road_texture_gain * ctx.decoupling_scale * ctx.texture_load_factor;
    ctx.road_noise *= ctx.speed_gate;
}

void FFBEngine::calculate_suspension_bottoming(const TelemInfoV01* data, FFBCalculationContext& ctx) {
    if (!m_bottoming_enabled) return;
    bool triggered = false;
    double intensity = 0.0;
    
    if (m_bottoming_method == 0) {
        double min_rh = (std::min)(data->mWheel[0].mRideHeight, data->mWheel[1].mRideHeight);
        if (min_rh < 0.002 && min_rh > -1.0) {
            triggered = true;
            intensity = (0.002 - min_rh) / 0.002;
        }
    } else {
        double dForceL = (data->mWheel[0].mSuspForce - m_prev_susp_force[0]) / ctx.dt;
        double dForceR = (data->mWheel[1].mSuspForce - m_prev_susp_force[1]) / ctx.dt;
        double max_dForce = (std::max)(dForceL, dForceR);
        if (max_dForce > 100000.0) {
            triggered = true;
            intensity = (max_dForce - 100000.0) / 200000.0;
        }
    }

    if (!triggered) {
        double max_load = (std::max)(data->mWheel[0].mTireLoad, data->mWheel[1].mTireLoad);
        if (max_load > 8000.0) {
            triggered = true;
            double excess = max_load - 8000.0;
            intensity = std::sqrt(excess) * 0.05;
        }
    }

    if (triggered) {
        double bump_magnitude = intensity * m_bottoming_gain * (double)BASE_NM_BOTTOMING * ctx.decoupling_scale;
        double freq = 50.0;
        m_bottoming_phase += freq * ctx.dt * TWO_PI;
        m_bottoming_phase = std::fmod(m_bottoming_phase, TWO_PI);
        ctx.bottoming_crunch = std::sin(m_bottoming_phase) * bump_magnitude * ctx.speed_gate;
    }
}

```

# File: src\FFBEngine.h
```cpp
#ifndef FFBENGINE_H
#define FFBENGINE_H

#include <cmath>
#include <algorithm>
#include <vector>
#include <mutex>
#include <iostream>
#include <chrono>
#include <array>
#include <cstring>
#include "lmu_sm_interface/InternalsPluginWrapper.h"
#include "AsyncLogger.h"
#include "MathUtils.h"
#include "PerfStats.h"
#include "VehicleUtils.h"

// Bring common math into scope
using namespace ffb_math;

// ChannelStats moved to PerfStats.h

// 1. Define the Snapshot Struct (Unified FFB + Telemetry)
struct FFBSnapshot {
    // --- Header A: FFB Components (Outputs) ---
    float total_output;
    float base_force;
    float sop_force;
    float understeer_drop;
    float oversteer_boost;
    float ffb_rear_torque;  // New v0.4.7
    float ffb_scrub_drag;   // New v0.4.7
    float ffb_yaw_kick;     // New v0.4.16
    float ffb_gyro_damping; // New v0.4.17
    float texture_road;
    float texture_slide;
    float texture_lockup;
    float texture_spin;
    float texture_bottoming;
    float ffb_abs_pulse;    // New v0.7.53
    float clipping;

    // --- Header B: Internal Physics (Calculated) ---
    float calc_front_load;       // New v0.4.7
    float calc_rear_load;        // New v0.4.10
    float calc_rear_lat_force;   // New v0.4.10
    float calc_front_grip;       // New v0.4.7
    float calc_rear_grip;        // New v0.4.7 (Refined)
    float calc_front_slip_ratio; // New v0.4.7 (Manual Calc)
    float calc_front_slip_angle_smoothed; // Renamed from slip_angle
    float raw_front_slip_angle;  // New v0.4.7 (Raw atan2)
    float calc_rear_slip_angle_smoothed; // New v0.4.9
    float raw_rear_slip_angle;   // New v0.4.9 (Raw atan2)

    // --- Header C: Raw Game Telemetry (Inputs) ---
    float steer_force;
    float raw_input_steering;    // New v0.4.7 (Unfiltered -1 to 1)
    float raw_front_tire_load;   // New v0.4.7
    float raw_front_grip_fract;  // New v0.4.7
    float raw_rear_grip;         // New v0.4.7
    float raw_front_susp_force;  // New v0.4.7
    float raw_front_ride_height; // New v0.4.7
    float raw_rear_lat_force;    // New v0.4.7
    float raw_car_speed;         // New v0.4.7
    float raw_front_slip_ratio;  // New v0.4.7 (Game API)
    float raw_input_throttle;    // New v0.4.7
    float raw_input_brake;       // New v0.4.7
    float accel_x;
    float raw_front_lat_patch_vel; // Renamed from patch_vel
    float raw_front_deflection;    // Renamed from deflection
    float raw_front_long_patch_vel; // New v0.4.9
    float raw_rear_lat_patch_vel;   // New v0.4.9
    float raw_rear_long_patch_vel;  // New v0.4.9

    // Telemetry Health Flags
    bool warn_load;
    bool warn_grip;
    bool warn_dt;

    float debug_freq; // New v0.4.41: Frequency for diagnostics
    float tire_radius; // New v0.4.41: Tire radius in meters for theoretical freq calculation
    float slope_current; // New v0.7.1: Slope detection derivative value

    // Rate Monitoring (Issue #129)
    float ffb_rate;
    float telemetry_rate;
    float hw_rate;
    float torque_rate;
    float gen_torque_rate;
};

// BiquadNotch moved to MathUtils.h

// Helper Result Struct for calculate_grip
struct GripResult {
    double value;           // Final grip value
    bool approximated;      // Was approximation used?
    double original;        // Original telemetry value
    double slip_angle;      // Calculated slip angle (if approximated)
};

namespace FFBEngineTests { class FFBEngineTestAccess; }

struct FFBCalculationContext {
    double dt = 0.0025;
    double car_speed = 0.0;       // Absolute m/s
    double car_speed_long = 0.0;  // Longitudinal m/s (Raw)
    double decoupling_scale = 1.0;
    double speed_gate = 1.0;
    double texture_load_factor = 1.0;
    double brake_load_factor = 1.0;
    double avg_load = 0.0;
    double avg_grip = 0.0;

    // Diagnostics
    bool frame_warn_load = false;
    bool frame_warn_grip = false;
    bool frame_warn_rear_grip = false;
    bool frame_warn_dt = false;

    // Intermediate results
    double grip_factor = 1.0;     // 1.0 = full grip, 0.0 = no grip
    double sop_base_force = 0.0;
    double sop_unboosted_force = 0.0; // For snapshot compatibility
    double rear_torque = 0.0;
    double yaw_force = 0.0;
    double scrub_drag_force = 0.0;
    double gyro_force = 0.0;
    double avg_rear_grip = 0.0;
    double calc_rear_lat_force = 0.0;
    double avg_rear_load = 0.0;

    // Effect outputs
    double road_noise = 0.0;
    double slide_noise = 0.0;
    double lockup_rumble = 0.0;
    double spin_rumble = 0.0;
    double bottoming_crunch = 0.0;
    double abs_pulse_force = 0.0;
    double gain_reduction_factor = 1.0;
};
    
// FFB Engine Class
class FFBEngine {
public:
    using ParsedVehicleClass = ::ParsedVehicleClass;

    // Settings (GUI Sliders)
    float m_gain;
    float m_understeer_effect;
    float m_sop_effect;
    float m_min_force;
    float m_dynamic_weight_gain; 
    
    // Smoothing Settings (v0.7.47)
    float m_dynamic_weight_smoothing;
    float m_grip_smoothing_steady;
    float m_grip_smoothing_fast;
    float m_grip_smoothing_sensitivity;

    // Configurable Smoothing & Caps (v0.3.9)
    float m_sop_smoothing_factor;
    float m_texture_load_cap = 1.5f; 
    float m_brake_load_cap = 1.5f;   
    float m_sop_scale;
    
    // v0.4.4 Features
    float m_max_torque_ref;
    bool m_invert_force;
    
    // Base Force Debugging (v0.4.13)
    float m_steering_shaft_gain;
    int m_base_force_mode;
    int m_torque_source = 0; 

    // New Effects (v0.2)
    float m_oversteer_boost;
    float m_rear_align_effect;
    float m_sop_yaw_gain;
    float m_gyro_gain;
    float m_gyro_smoothing;
    float m_yaw_accel_smoothing;
    float m_chassis_inertia_smoothing;
    
    bool m_lockup_enabled;
    float m_lockup_gain;
    // NEW Lockup Tuning (v0.5.11)
    float m_lockup_start_pct = 5.0f;
    float m_lockup_full_pct = 15.0f;
    float m_lockup_rear_boost = 1.5f;
    float m_lockup_gamma = 2.0f;           
    float m_lockup_prediction_sens = 50.0f; 
    float m_lockup_bump_reject = 1.0f;     
    
    bool m_abs_pulse_enabled = true;      
    float m_abs_gain = 1.0f;               
    
    bool m_spin_enabled;
    float m_spin_gain;

    // Texture toggles
    bool m_slide_texture_enabled;
    float m_slide_texture_gain;
    float m_slide_freq_scale;
    
    bool m_road_texture_enabled;
    float m_road_texture_gain;
    
    // Bottoming Effect (v0.3.2)
    bool m_bottoming_enabled = true;  
    float m_bottoming_gain = 1.0f;    

    float m_slip_angle_smoothing;
    
    // NEW: Grip Estimation Settings (v0.5.7)
    float m_optimal_slip_angle;
    float m_optimal_slip_ratio;
    
    // NEW: Steering Shaft Smoothing (v0.5.7)
    float m_steering_shaft_smoothing;
    
    // v0.4.41: Signal Filtering Settings
    bool m_flatspot_suppression = false;
    float m_notch_q = 2.0f; 
    float m_flatspot_strength = 1.0f; 
    
    // Static Notch Filter (v0.4.43)
    bool m_static_notch_enabled = false;
    float m_static_notch_freq = 11.0f;
    float m_static_notch_width = 2.0f; 
    float m_yaw_kick_threshold = 0.2f; 

    // v0.6.23: User-Adjustable Speed Gate
    float m_speed_gate_lower = 1.0f; 
    float m_speed_gate_upper = 5.0f; 

    // v0.6.23: Additional Advanced Physics (Reserved for future use)
    float m_road_fallback_scale = 0.05f;
    bool m_understeer_affects_sop = false;
    
    // ===== SLOPE DETECTION (v0.7.0 -> v0.7.3 stability fixes) =====
    bool m_slope_detection_enabled = false;
    int m_slope_sg_window = 15;
    float m_slope_sensitivity = 0.5f;            

    float m_slope_smoothing_tau = 0.04f;         

    // NEW v0.7.3: Stability fixes
    float m_slope_alpha_threshold = 0.02f;    
    float m_slope_decay_rate = 5.0f;          
    bool m_slope_confidence_enabled = true;   
    float m_slope_confidence_max_rate = 0.10f; 

    // NEW v0.7.11: Min/Max Threshold System
    float m_slope_min_threshold = -0.3f;   
    float m_slope_max_threshold = -2.0f;   

    // NEW v0.7.40: Advanced Features
    float m_slope_g_slew_limit = 50.0f;
    bool m_slope_use_torque = true;
    float m_slope_torque_sensitivity = 0.5f;

    // Signal Diagnostics
    double m_debug_freq = 0.0; 
    double m_theoretical_freq = 0.0; 

    // Rate Monitoring (Issue #129)
    double m_ffb_rate = 0.0;
    double m_telemetry_rate = 0.0;
    double m_hw_rate = 0.0;
    double m_torque_rate = 0.0;
    double m_gen_torque_rate = 0.0;

    // Warning States (Console logging)
    bool m_warned_load = false;
    bool m_warned_grip = false;
    bool m_warned_rear_grip = false; 
    bool m_warned_dt = false;
    bool m_warned_lat_force_front = false;
    bool m_warned_lat_force_rear = false;
    bool m_warned_susp_force = false;
    bool m_warned_susp_deflection = false;
    bool m_warned_vert_deflection = false; 
    
    // Diagnostics (v0.4.5 Fix)
    struct GripDiagnostics {
        bool front_approximated = false;
        bool rear_approximated = false;
        double front_original = 0.0;
        double rear_original = 0.0;
        double front_slip_angle = 0.0;
        double rear_slip_angle = 0.0;
    } m_grip_diag;
    
    // Hysteresis for missing load
    int m_missing_load_frames = 0;
    int m_missing_lat_force_front_frames = 0;
    int m_missing_lat_force_rear_frames = 0;
    int m_missing_susp_force_frames = 0;
    int m_missing_susp_deflection_frames = 0;
    int m_missing_vert_deflection_frames = 0; 

    // Internal state
    double m_prev_vert_deflection[4] = {0.0, 0.0, 0.0, 0.0}; 
    double m_prev_vert_accel = 0.0; 
    double m_prev_slip_angle[4] = {0.0, 0.0, 0.0, 0.0}; 
    double m_prev_rotation[4] = {0.0, 0.0, 0.0, 0.0};    
    double m_prev_brake_pressure[4] = {0.0, 0.0, 0.0, 0.0}; 
    
    // Gyro State (v0.4.17)
    double m_prev_steering_angle = 0.0;
    double m_steering_velocity_smoothed = 0.0;
    
    // Yaw Acceleration Smoothing State (v0.4.18)
    double m_yaw_accel_smoothed = 0.0;

    // Internal state for Steering Shaft Smoothing (v0.5.7)
    double m_steering_shaft_torque_smoothed = 0.0;

    // Kinematic Smoothing State (v0.4.38)
    double m_accel_x_smoothed = 0.0;
    double m_accel_z_smoothed = 0.0; 
    
    // Kinematic Physics Parameters (v0.4.39)
    float m_approx_mass_kg = 1100.0f;
    float m_approx_aero_coeff = 2.0f;
    float m_approx_weight_bias = 0.55f;
    float m_approx_roll_stiffness = 0.6f;

    // Phase Accumulators for Dynamic Oscillators
    double m_lockup_phase = 0.0;
    double m_spin_phase = 0.0;
    double m_slide_phase = 0.0;
    double m_abs_phase = 0.0; 
    double m_bottoming_phase = 0.0;
    
    // Phase Accumulators for Dynamic Oscillators (v0.6.20)
    float m_abs_freq_hz = 20.0f;
    float m_lockup_freq_scale = 1.0f;
    float m_spin_freq_scale = 1.0f;
    
    // Internal state for Bottoming (Method B)
    double m_prev_susp_force[2] = {0.0, 0.0}; 

    // New Settings (v0.4.5)
    int m_bottoming_method = 0; 
    float m_scrub_drag_gain; 

    // Smoothing State
    double m_sop_lat_g_smoothed = 0.0;
    
    // Filter Instances (v0.4.41)
    BiquadNotch m_notch_filter;
    BiquadNotch m_static_notch_filter;

    // Slope Detection Buffers (Circular) - v0.7.0
    static constexpr int SLOPE_BUFFER_MAX = 41;  
    std::array<double, SLOPE_BUFFER_MAX> m_slope_lat_g_buffer = {};
    std::array<double, SLOPE_BUFFER_MAX> m_slope_slip_buffer = {};
    int m_slope_buffer_index = 0;
    int m_slope_buffer_count = 0;

    // Slope Detection State (Public for diagnostics) - v0.7.0
    double m_slope_current = 0.0;
    double m_slope_grip_factor = 1.0;
    double m_slope_smoothed_output = 1.0;

    // NEW v0.7.38: Input Smoothing State
    double m_slope_lat_g_smoothed = 0.0;
    double m_slope_slip_smoothed = 0.0;

    // NEW v0.7.38: Steady State Logic
    double m_slope_hold_timer = 0.0;
    static constexpr double SLOPE_HOLD_TIME = 0.25; 

    // NEW v0.7.38: Debug members for Logger
    double m_debug_slope_raw = 0.0;
    double m_debug_slope_num = 0.0;
    double m_debug_slope_den = 0.0;

    // NEW v0.7.40: Advanced Slope Detection State
    double m_slope_lat_g_prev = 0.0;
    std::array<double, SLOPE_BUFFER_MAX> m_slope_torque_buffer = {};
    std::array<double, SLOPE_BUFFER_MAX> m_slope_steer_buffer = {};
    double m_slope_torque_smoothed = 0.0;
    double m_slope_steer_smoothed = 0.0;
    double m_slope_torque_current = 0.0;
    
    // NEW v0.7.40: More Debug members
    double m_debug_slope_torque_num = 0.0;
    double m_debug_slope_torque_den = 0.0;
    double m_debug_lat_g_slew = 0.0;

    // Dynamic Weight State (v0.7.46)
    double m_static_front_load = 0.0; 
    double m_dynamic_weight_smoothed = 1.0; 
    double m_front_grip_smoothed_state = 1.0; 
    double m_rear_grip_smoothed_state = 1.0;  

    // Context for Logging (v0.7.x)
    char m_vehicle_name[64] = "Unknown";
    char m_track_name[64] = "Unknown";

    // Logging intermediate values (exposed for AsyncLogger)
    double m_slope_dG_dt = 0.0;       
    double m_slope_dAlpha_dt = 0.0;   

    // Frequency Estimator State (v0.4.41)
    double m_last_crossing_time = 0.0;
    double m_last_output_force = 0.0; 
    double m_torque_ac_smoothed = 0.0; 
    double m_prev_ac_torque = 0.0;

    // Telemetry Stats
    ChannelStats s_torque;
    ChannelStats s_load;
    ChannelStats s_grip;
    ChannelStats s_lat_g;
    std::chrono::steady_clock::time_point last_log_time;

    // Thread-Safe Buffer (Producer-Consumer)
    std::vector<FFBSnapshot> m_debug_buffer;
    std::mutex m_debug_mutex;
    
    friend class FFBEngineTests::FFBEngineTestAccess;

    FFBEngine();

    bool IsFFBAllowed(const VehicleScoringInfoV01& scoring, unsigned char gamePhase) const;
    double ApplySafetySlew(double target_force, double dt, bool restricted);
    std::vector<FFBSnapshot> GetDebugBatch();

    // UI Reference & Physics Multipliers (v0.4.50)
    static constexpr float BASE_NM_SOP_LATERAL      = 1.0f;
    static constexpr float BASE_NM_REAR_ALIGN       = 3.0f;
    static constexpr float BASE_NM_YAW_KICK         = 5.0f;
    static constexpr float BASE_NM_GYRO_DAMPING     = 1.0f;
    static constexpr float BASE_NM_SLIDE_TEXTURE    = 1.5f;
    static constexpr float BASE_NM_ROAD_TEXTURE     = 2.5f;
    static constexpr float BASE_NM_LOCKUP_VIBRATION = 4.0f;
    static constexpr float BASE_NM_SPIN_VIBRATION   = 2.5f;
    static constexpr float BASE_NM_SCRUB_DRAG       = 5.0f;
    static constexpr float BASE_NM_BOTTOMING        = 1.0f;

private:
    static constexpr double MIN_SLIP_ANGLE_VELOCITY = 0.5; // m/s
    static constexpr double REAR_TIRE_STIFFNESS_COEFFICIENT = 15.0; 
    static constexpr double MAX_REAR_LATERAL_FORCE = 6000.0; // N
    static constexpr double REAR_ALIGN_TORQUE_COEFFICIENT = 0.001; // Nm per N
    static constexpr double SYNTHETIC_MODE_DEADZONE_NM = 0.5; // Nm
    static constexpr double DEFAULT_STEERING_RANGE_RAD = 9.4247; 
    static constexpr double GYRO_SPEED_SCALE = 10.0;
    static constexpr double WEIGHT_TRANSFER_SCALE = 2000.0; // N per G
    static constexpr double MIN_VALID_SUSP_FORCE = 10.0; // N 
    static constexpr double LOCKUP_FREQ_MULTIPLIER_REAR = 0.3;  
    static constexpr double LOCKUP_AMPLITUDE_BOOST_REAR = 1.5;  
    static constexpr double AXLE_DIFF_HYSTERESIS = 0.01;  
    static constexpr double ABS_PEDAL_THRESHOLD = 0.5;  
    static constexpr double ABS_PRESSURE_RATE_THRESHOLD = 2.0;  
    static constexpr double PREDICTION_BRAKE_THRESHOLD = 0.02;  
    static constexpr double PREDICTION_LOAD_THRESHOLD = 50.0;   

    double m_auto_peak_load = 4500.0; 
    std::string m_current_class_name = "";
    bool m_auto_load_normalization_enabled = true; 

    void update_static_load_reference(double current_load, double speed, double dt);
    void InitializeLoadReference(const char* className, const char* vehicleName);
    
public:
    double calculate_raw_slip_angle_pair(const TelemWheelV01& w1, const TelemWheelV01& w2);
    double calculate_slip_angle(const TelemWheelV01& w, double& prev_state, double dt);
    
    GripResult calculate_grip(const TelemWheelV01& w1, 
                              const TelemWheelV01& w2,
                              double avg_load,
                              bool& warned_flag,
                              double& prev_slip1,
                              double& prev_slip2,
                              double car_speed,
                              double dt,
                              const char* vehicleName,
                              const TelemInfoV01* data,
                              bool is_front);

    double approximate_load(const TelemWheelV01& w);
    double approximate_rear_load(const TelemWheelV01& w);
    double calculate_kinematic_load(const TelemInfoV01* data, int wheel_index);
    double calculate_manual_slip_ratio(const TelemWheelV01& w, double car_speed_ms);
    __declspec(noinline) double calculate_slope_grip(double lateral_g, double slip_angle, double dt, const TelemInfoV01* data = nullptr);
    double calculate_slope_confidence(double dAlpha_dt);
    double calculate_wheel_slip_ratio(const TelemWheelV01& w);

    double calculate_force(const TelemInfoV01* data, const char* vehicleClass = nullptr, const char* vehicleName = nullptr, float genFFBTorque = 0.0f);

    double apply_signal_conditioning(double raw_torque, const TelemInfoV01* data, FFBCalculationContext& ctx);

private:
    void calculate_sop_lateral(const TelemInfoV01* data, FFBCalculationContext& ctx);
    __declspec(noinline) void calculate_gyro_damping(const TelemInfoV01* data, FFBCalculationContext& ctx);
    __declspec(noinline) void calculate_abs_pulse(const TelemInfoV01* data, FFBCalculationContext& ctx);
    void calculate_lockup_vibration(const TelemInfoV01* data, FFBCalculationContext& ctx);
    void calculate_wheel_spin(const TelemInfoV01* data, FFBCalculationContext& ctx);
    void calculate_slide_texture(const TelemInfoV01* data, FFBCalculationContext& ctx);
    void calculate_road_texture(const TelemInfoV01* data, FFBCalculationContext& ctx);
    void calculate_suspension_bottoming(const TelemInfoV01* data, FFBCalculationContext& ctx);
};

#endif // FFBENGINE_H

```

# File: src\GameConnector.cpp
```cpp
#include "GameConnector.h"
#include "Logger.h"
#ifndef _WIN32
#include "lmu_sm_interface/LinuxMock.h"
#endif
#include "lmu_sm_interface/SafeSharedMemoryLock.h"
#include <iostream>

#define LEGACY_SHARED_MEMORY_NAME "$rFactor2SMMP_Telemetry$"

GameConnector& GameConnector::Get() {
    static GameConnector instance;
    return instance;
}

GameConnector::GameConnector() {}

GameConnector::~GameConnector() {
    Disconnect();
}

void GameConnector::Disconnect() {
    std::lock_guard<std::mutex> lock(m_mutex);
    _DisconnectLocked();
}

void GameConnector::_DisconnectLocked() {
#if defined(_WIN32) || defined(HEADLESS_GUI)
    if (m_pSharedMemLayout) {
        UnmapViewOfFile(m_pSharedMemLayout);
        m_pSharedMemLayout = nullptr;
    }
    if (m_hMapFile) {
        CloseHandle(m_hMapFile);
        m_hMapFile = NULL;
    }
    m_hwndGame = NULL;
#endif
    m_smLock.reset();
    m_connected = false;
    m_processId = 0;
}

bool GameConnector::TryConnect() {
    std::lock_guard<std::mutex> lock(m_mutex);
    if (m_connected) return true;

    // Ensure we don't leak handles from a previous partial/failed attempt
    _DisconnectLocked();

#if defined(_WIN32) || defined(HEADLESS_GUI)
    m_hMapFile = OpenFileMappingA(FILE_MAP_READ, FALSE, LMU_SHARED_MEMORY_FILE);
    
    if (m_hMapFile == NULL) {
        return false;
    } 

    m_pSharedMemLayout = (SharedMemoryLayout*)MapViewOfFile(m_hMapFile, FILE_MAP_READ, 0, 0, sizeof(SharedMemoryLayout));
    if (m_pSharedMemLayout == NULL) {
        std::cerr << "[GameConnector] Could not map view of file." << std::endl;
        Logger::Get().LogWin32Error("MapViewOfFile", GetLastError());
        _DisconnectLocked();
        return false;
    }

    m_smLock = SafeSharedMemoryLock::MakeSafeSharedMemoryLock();
    if (!m_smLock.has_value()) {
        std::cerr << "[GameConnector] Failed to init LMU Shared Memory Lock" << std::endl;
        Logger::Get().Log("Failed to init SafeSharedMemoryLock.");
        _DisconnectLocked();
        return false;
    }

    HWND hwnd = m_pSharedMemLayout->data.generic.appInfo.mAppWindow;
    if (hwnd) {
        m_hwndGame = hwnd; // Store HWND for liveness check (IsWindow)
        // Note: multiple threads might access shared memory, but HWND is usually stable during session.
        // We use IsWindow(m_hwndGame) instead of OpenProcess to avoid AV heuristics flagging "Process Access".
    }

    m_connected = true;
    m_lastUpdateLocalTime = std::chrono::steady_clock::now();
    std::cout << "[GameConnector] Connected to LMU Shared Memory." << std::endl;
    Logger::Get().Log("Connected to LMU Shared Memory.");
    return true;
#else
    return false;
#endif
}

bool GameConnector::CheckLegacyConflict() {
#if defined(_WIN32) || defined(HEADLESS_GUI)
    HANDLE hLegacy = OpenFileMappingA(FILE_MAP_READ, FALSE, LEGACY_SHARED_MEMORY_NAME);
    if (hLegacy) {
        std::cout << "[Warning] Legacy rFactor 2 Shared Memory Plugin detected. This may conflict with LMU 1.2 data." << std::endl;
        CloseHandle(hLegacy);
        return true;
    }
#endif
    return false;
}

bool GameConnector::IsConnected() const {
  if (!m_connected.load(std::memory_order_acquire)) return false;

  std::lock_guard<std::mutex> lock(m_mutex);
  if (!m_connected.load(std::memory_order_relaxed)) return false;

#if defined(_WIN32) || defined(HEADLESS_GUI)
  if (m_hwndGame) {
    if (!IsWindow(m_hwndGame)) {
      // Window is gone, game likely exited
      const_cast<GameConnector*>(this)->_DisconnectLocked();
      return false;
    }
  }
#endif

  return m_connected.load(std::memory_order_relaxed) && m_pSharedMemLayout && m_smLock.has_value();
}

bool GameConnector::CopyTelemetry(SharedMemoryObjectOut& dest) {
    if (!m_connected.load(std::memory_order_acquire)) return false;

    std::lock_guard<std::mutex> lock(m_mutex);
    if (!m_connected.load(std::memory_order_relaxed) || !m_pSharedMemLayout || !m_smLock.has_value()) return false;

    if (m_smLock->Lock(50)) {
        CopySharedMemoryObj(dest, m_pSharedMemLayout->data);
        
        if (dest.telemetry.playerHasVehicle) {
            uint8_t idx = dest.telemetry.playerVehicleIdx;
            if (idx < 104) {
                double currentET = dest.telemetry.telemInfo[idx].mElapsedTime;
                if (currentET != m_lastElapsedTime) {
                    m_lastElapsedTime = currentET;
                    m_lastUpdateLocalTime = std::chrono::steady_clock::now();
                }
            }
        } else {
            m_lastUpdateLocalTime = std::chrono::steady_clock::now();
        }

        bool isRealtime = (m_pSharedMemLayout->data.scoring.scoringInfo.mInRealtime != 0);
        m_smLock->Unlock();
        return isRealtime;
    } else {
        return false;
    }
}

bool GameConnector::IsStale(long timeoutMs) const {
    if (!m_connected.load(std::memory_order_acquire)) return true;

    auto now = std::chrono::steady_clock::now();
    auto diff = std::chrono::duration_cast<std::chrono::milliseconds>(now - m_lastUpdateLocalTime).count();
    return (diff > timeoutMs);
}

```

# File: src\GameConnector.h
```cpp
#ifndef GAMECONNECTOR_H
#define GAMECONNECTOR_H

#ifdef _WIN32
#include <windows.h>
#else
#include "lmu_sm_interface/LinuxMock.h"
#endif

#include "lmu_sm_interface/LmuSharedMemoryWrapper.h"
#include "lmu_sm_interface/SafeSharedMemoryLock.h"
#include <mutex>
#include <atomic>

class GameConnector {
public:
    static GameConnector& Get();
    
    // Attempt to connect to LMU Shared Memory
    bool TryConnect();
    
    // Disconnect and clean up resources
    void Disconnect();
    
    // Check for Legacy rFactor 2 Plugin conflict
    bool CheckLegacyConflict();
    
    // Is connected to LMU SM?
    bool IsConnected() const;
    
    // Thread-safe copy of telemetry data
    // Returns true if in realtime (driving) mode, false if in menu/replay
    bool CopyTelemetry(SharedMemoryObjectOut& dest);

    // Returns true if telemetry data hasn't changed for more than timeout (v0.7.15)
    bool IsStale(long timeoutMs = 100) const;

private:
    GameConnector();
    ~GameConnector();
    
    SharedMemoryLayout* m_pSharedMemLayout = nullptr;
    mutable std::optional<SafeSharedMemoryLock> m_smLock;
    HANDLE m_hMapFile = NULL;
    mutable HWND m_hwndGame = NULL;
    DWORD m_processId = 0;

    std::atomic<bool> m_connected{false};
    mutable std::mutex m_mutex;

    // Heartbeat for staleness detection (v0.7.15)
    double m_lastElapsedTime = -1.0;
    mutable std::chrono::steady_clock::time_point m_lastUpdateLocalTime;

    void _DisconnectLocked();
};
#endif // GAMECONNECTOR_H

```

# File: src\GuiLayer.h
```cpp
#ifndef GUILAYER_H
#define GUILAYER_H

#include "FFBEngine.h"
#include <string>

class GuiLayer {
public:
    static bool Init();
    static void Shutdown(FFBEngine& engine);
    
    static void* GetWindowHandle(); // Returns HWND on Windows, GLFWwindow* on Linux
    static void SetupGUIStyle();   // Setup professional theme

    // Returns true if the GUI is active/focused (affects lazy rendering)
    static bool Render(FFBEngine& engine);

private:
    static void DrawTuningWindow(FFBEngine& engine);
    static void DrawDebugWindow(FFBEngine& engine);
};

// Platform helper functions (implemented in GuiLayer_Win32.cpp and GuiLayer_Linux.cpp)
void ResizeWindowPlatform(int x, int y, int w, int h);
void SaveCurrentWindowGeometryPlatform(bool is_graph_mode);
void SetWindowAlwaysOnTopPlatform(bool enabled);
bool OpenPresetFileDialogPlatform(std::string& outPath);
bool SavePresetFileDialogPlatform(std::string& outPath, const std::string& defaultName);

#endif // GUILAYER_H

```

# File: src\GuiLayer_Common.cpp
```cpp
#include "GuiLayer.h"
#include "Version.h"
#include "Config.h"
#include "DirectInputFFB.h"
#include "GameConnector.h"
#include "GuiWidgets.h"
#include "AsyncLogger.h"
#include <iostream>
#include <vector>
#include <algorithm>
#include <cstring>
#include <mutex>
#include <chrono>
#include <ctime>

#ifdef ENABLE_IMGUI
#include "imgui.h"

// External linkage to FFB loop status
extern std::atomic<bool> g_running;
extern std::mutex g_engine_mutex;

static const float CONFIG_PANEL_WIDTH = 500.0f;
static const int LATENCY_WARNING_THRESHOLD_MS = 15;

// Professional "Flat Dark" Theme
void GuiLayer::SetupGUIStyle() {
    ImGuiStyle& style = ImGui::GetStyle();

    style.WindowRounding = 5.0f;
    style.FrameRounding = 4.0f;
    style.GrabRounding = 4.0f;
    style.FramePadding = ImVec2(8, 4);
    style.ItemSpacing = ImVec2(8, 6);

    ImVec4* colors = style.Colors;

    colors[ImGuiCol_WindowBg]       = ImVec4(0.12f, 0.12f, 0.12f, 1.00f);
    colors[ImGuiCol_ChildBg]        = ImVec4(0.15f, 0.15f, 0.15f, 1.00f);
    colors[ImGuiCol_PopupBg]        = ImVec4(0.15f, 0.15f, 0.15f, 0.98f);

    colors[ImGuiCol_Header]         = ImVec4(0.20f, 0.20f, 0.20f, 0.00f);
    colors[ImGuiCol_HeaderHovered]  = ImVec4(0.25f, 0.25f, 0.25f, 0.50f);
    colors[ImGuiCol_HeaderActive]   = ImVec4(0.30f, 0.30f, 0.30f, 0.50f);

    colors[ImGuiCol_FrameBg]        = ImVec4(0.20f, 0.20f, 0.20f, 1.00f);
    colors[ImGuiCol_FrameBgHovered] = ImVec4(0.25f, 0.25f, 0.25f, 1.00f);
    colors[ImGuiCol_FrameBgActive]  = ImVec4(0.30f, 0.30f, 0.30f, 1.00f);

    ImVec4 accent = ImVec4(0.00f, 0.60f, 0.85f, 1.00f);
    colors[ImGuiCol_SliderGrab]     = accent;
    colors[ImGuiCol_SliderGrabActive] = ImVec4(0.00f, 0.70f, 0.95f, 1.00f);
    colors[ImGuiCol_Button]         = ImVec4(0.25f, 0.25f, 0.25f, 1.00f);
    colors[ImGuiCol_ButtonHovered]  = accent;
    colors[ImGuiCol_ButtonActive]   = ImVec4(0.00f, 0.50f, 0.75f, 1.00f);
    colors[ImGuiCol_CheckMark]      = accent;

    colors[ImGuiCol_Text]           = ImVec4(0.90f, 0.90f, 0.90f, 1.00f);
    colors[ImGuiCol_TextDisabled]   = ImVec4(0.50f, 0.50f, 0.50f, 1.00f);
}


static constexpr std::chrono::seconds CONNECT_ATTEMPT_INTERVAL(2);

void GuiLayer::DrawTuningWindow(FFBEngine& engine) {
    std::lock_guard<std::mutex> lock(g_engine_mutex);

    ImGuiViewport* viewport = ImGui::GetMainViewport();
    float current_width = Config::show_graphs ? CONFIG_PANEL_WIDTH : viewport->Size.x;

    ImGui::SetNextWindowPos(viewport->Pos);
    ImGui::SetNextWindowSize(ImVec2(current_width, viewport->Size.y));

    ImGuiWindowFlags flags = ImGuiWindowFlags_NoDecoration | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoResize;
    ImGui::Begin("MainUI", nullptr, flags);

    ImGui::TextColored(ImVec4(1, 1, 1, 0.4f), "lmuFFB v%s", LMUFFB_VERSION);
    ImGui::Separator();

    static std::chrono::steady_clock::time_point last_check_time = std::chrono::steady_clock::now();

    if (!GameConnector::Get().IsConnected()) {
      ImGui::TextColored(ImVec4(1, 1, 0, 1), "Connecting to LMU...");
      if (std::chrono::steady_clock::now() - last_check_time > CONNECT_ATTEMPT_INTERVAL) {
        last_check_time = std::chrono::steady_clock::now();
        GameConnector::Get().TryConnect();
      }
    } else {
      ImGui::TextColored(ImVec4(0, 1, 0, 1), "Connected to LMU");
      ImGui::SameLine();
      ImGui::TextColored(ImVec4(0.7f, 0.7f, 0.7f, 1.0f), "| FFB: %.0fHz | Tel: %.0fHz", engine.m_ffb_rate, engine.m_telemetry_rate);
    }

    static std::vector<DeviceInfo> devices;
    static int selected_device_idx = -1;

    if (devices.empty()) {
        devices = DirectInputFFB::Get().EnumerateDevices();
        if (selected_device_idx == -1 && !Config::m_last_device_guid.empty()) {
            GUID target = DirectInputFFB::StringToGuid(Config::m_last_device_guid);
            for (int i = 0; i < (int)devices.size(); i++) {
                if (memcmp(&devices[i].guid, &target, sizeof(GUID)) == 0) {
                    selected_device_idx = i;
                    DirectInputFFB::Get().SelectDevice(devices[i].guid);
                    break;
                }
            }
        }
    }

    ImGui::SetNextItemWidth(ImGui::GetContentRegionAvail().x * 0.4f);
    if (ImGui::BeginCombo("FFB Device", selected_device_idx >= 0 ? devices[selected_device_idx].name.c_str() : "Select Device...")) {
        for (int i = 0; i < (int)devices.size(); i++) {
            bool is_selected = (selected_device_idx == i);
            ImGui::PushID(i);
            if (ImGui::Selectable(devices[i].name.c_str(), is_selected)) {
                selected_device_idx = i;
                DirectInputFFB::Get().SelectDevice(devices[i].guid);
                Config::m_last_device_guid = DirectInputFFB::GuidToString(devices[i].guid);
                Config::Save(engine);
            }
            if (is_selected) ImGui::SetItemDefaultFocus();
            ImGui::PopID();
        }
        ImGui::EndCombo();
    }
    if (ImGui::IsItemHovered()) ImGui::SetTooltip("Select the DirectInput device to receive Force Feedback signals.\nTypically your steering wheel.");

    ImGui::SameLine();
    if (ImGui::Button("Rescan")) {
        devices = DirectInputFFB::Get().EnumerateDevices();
        selected_device_idx = -1;
    }
    if (ImGui::IsItemHovered()) ImGui::SetTooltip("Refresh the list of available DirectInput devices.");
    ImGui::SameLine();
    if (ImGui::Button("Unbind")) {
        DirectInputFFB::Get().ReleaseDevice();
        selected_device_idx = -1;
    }
    if (ImGui::IsItemHovered()) ImGui::SetTooltip("Release the current device and disable FFB output.");

    if (DirectInputFFB::Get().IsActive()) {
        if (DirectInputFFB::Get().IsExclusive()) {
            ImGui::TextColored(ImVec4(0.4f, 1.0f, 0.4f, 1.0f), "Mode: EXCLUSIVE (Game FFB Blocked)");
            if (ImGui::IsItemHovered()) ImGui::SetTooltip("lmuFFB has exclusive control.\nThe game can read steering but cannot send FFB.\nThis prevents 'Double FFB' issues.");
        } else {
            ImGui::TextColored(ImVec4(1.0f, 1.0f, 0.4f, 1.0f), "Mode: SHARED (Potential Conflict)");
            if (ImGui::IsItemHovered()) ImGui::SetTooltip("lmuFFB is sharing the device.\nEnsure In-Game FFB is disabled\nto avoid LMU reacquiring the device.");
        }
    } else {
        ImGui::TextColored(ImVec4(1.0f, 0.4f, 0.4f, 1.0f), "No device selected.");
        if (ImGui::IsItemHovered()) ImGui::SetTooltip("Please select your steering wheel from the 'FFB Device' menu above.");
    }

    if (ImGui::Checkbox("Always on Top", &Config::m_always_on_top)) {
        SetWindowAlwaysOnTopPlatform(Config::m_always_on_top);
        Config::Save(engine);
    }
    if (ImGui::IsItemHovered()) ImGui::SetTooltip("Keep the lmuFFB window visible over other applications (including the game).");
    ImGui::SameLine();

    bool toggled = Config::show_graphs;
    if (ImGui::Checkbox("Graphs", &toggled)) {
        SaveCurrentWindowGeometryPlatform(Config::show_graphs);
        Config::show_graphs = toggled;
        int target_w = Config::show_graphs ? Config::win_w_large : Config::win_w_small;
        int target_h = Config::show_graphs ? Config::win_h_large : Config::win_h_small;
        ResizeWindowPlatform(Config::win_pos_x, Config::win_pos_y, target_w, target_h);
        Config::Save(engine);
    }
    if (ImGui::IsItemHovered()) ImGui::SetTooltip("Show real-time physics and output graphs for debugging.\nIncreases window width.");

    ImGui::Separator();
    bool is_logging = AsyncLogger::Get().IsLogging();
    if (is_logging) {
         if (ImGui::Button("STOP LOG", ImVec2(80, 0))) {
             AsyncLogger::Get().Stop();
         }
         if (ImGui::IsItemHovered()) ImGui::SetTooltip("Finish recording and save the log file.");
         ImGui::SameLine();
         float time = (float)ImGui::GetTime();
         bool blink = (fmod(time, 1.0f) < 0.5f);
         ImGui::TextColored(blink ? ImVec4(1,0,0,1) : ImVec4(0.6f,0,0,1), "REC");
         if (ImGui::IsItemHovered()) ImGui::SetTooltip("Currently recording high-frequency telemetry data at 100Hz.");

         ImGui::SameLine();
         size_t bytes = AsyncLogger::Get().GetFileSizeBytes();
         if (bytes < 1024 * 1024)
             ImGui::Text("%zu f (%.0f KB)", AsyncLogger::Get().GetFrameCount(), (float)bytes / 1024.0f);
         else
             ImGui::Text("%zu f (%.1f MB)", AsyncLogger::Get().GetFrameCount(), (float)bytes / (1024.0f * 1024.0f));

         ImGui::SameLine();
         if (ImGui::Button("MARKER")) {
             AsyncLogger::Get().SetMarker();
         }
         if (ImGui::IsItemHovered()) ImGui::SetTooltip("Add a timestamped marker to the log file to tag an interesting event.");
    } else {
         if (ImGui::Button("START LOGGING", ImVec2(120, 0))) {
             SessionInfo info;
             info.app_version = LMUFFB_VERSION;
             if (engine.m_vehicle_name[0] != '\0') info.vehicle_name = engine.m_vehicle_name;
             else info.vehicle_name = "UnknownCar";

             if (engine.m_track_name[0] != '\0') info.track_name = engine.m_track_name;
             else info.track_name = "UnknownTrack";

             info.driver_name = "Auto";

             info.gain = engine.m_gain;
             info.understeer_effect = engine.m_understeer_effect;
             info.sop_effect = engine.m_sop_effect;
             info.slope_enabled = engine.m_slope_detection_enabled;
             info.slope_sensitivity = engine.m_slope_sensitivity;
             info.slope_threshold = (float)engine.m_slope_min_threshold;
             info.slope_alpha_threshold = engine.m_slope_alpha_threshold;
             info.slope_decay_rate = engine.m_slope_decay_rate;

             AsyncLogger::Get().Start(info, Config::m_log_path);
         }
         if (ImGui::IsItemHovered()) ImGui::SetTooltip("Start recording high-frequency telemetry and FFB data to a CSV file for analysis.");
         ImGui::SameLine();
         ImGui::TextDisabled("(Diagnostics)");
    }


    ImGui::Separator();

    static int selected_preset = 0;

    auto FormatDecoupled = [&](float val, float base_nm) {
        float scale = (engine.m_max_torque_ref / 20.0f);
        if (scale < 0.1f) scale = 0.1f;
        float estimated_nm = val * base_nm * scale;
        static char buf[64];
        snprintf(buf, 64, "%.1f%%%% (~%.1f Nm)", val * 100.0f, estimated_nm);
        return (const char*)buf;
    };

    auto FormatPct = [&](float val) {
        static char buf[32];
        snprintf(buf, 32, "%.1f%%%%", val * 100.0f);
        return (const char*)buf;
    };

    auto FloatSetting = [&](const char* label, float* v, float min, float max, const char* fmt = "%.2f", const char* tooltip = nullptr, std::function<void()> decorator = nullptr) {
        GuiWidgets::Result res = GuiWidgets::Float(label, v, min, max, fmt, tooltip, decorator);
        if (res.deactivated) {
            Config::Save(engine);
        }
    };

    auto BoolSetting = [&](const char* label, bool* v, const char* tooltip = nullptr) {
        GuiWidgets::Result res = GuiWidgets::Checkbox(label, v, tooltip);
        if (res.deactivated) {
            Config::Save(engine);
        }
    };

    auto IntSetting = [&](const char* label, int* v, const char* const items[], int items_count, const char* tooltip = nullptr) {
        GuiWidgets::Result res = GuiWidgets::Combo(label, v, items, items_count, tooltip);
        if (res.deactivated) {
            Config::Save(engine);
        }
    };

    if (ImGui::TreeNodeEx("Presets and Configuration", ImGuiTreeNodeFlags_DefaultOpen | ImGuiTreeNodeFlags_Framed)) {
        if (Config::presets.empty()) Config::LoadPresets();

        static bool first_run = true;
        if (first_run && !Config::presets.empty()) {
            for (int i = 0; i < (int)Config::presets.size(); i++) {
                if (Config::presets[i].name == Config::m_last_preset_name) {
                    selected_preset = i;
                    break;
                }
            }
            first_run = false;
        }

        static std::string preview_buf;
        const char* preview_value = "Custom";
        if (selected_preset >= 0 && selected_preset < (int)Config::presets.size()) {
            preview_buf = Config::presets[selected_preset].name;
            if (Config::IsEngineDirtyRelativeToPreset(selected_preset, engine)) {
                preview_buf += "*";
            }
            preview_value = preview_buf.c_str();
        }

        ImGui::SetNextItemWidth(ImGui::GetContentRegionAvail().x * 0.6f);
        if (ImGui::BeginCombo("Load Preset", preview_value)) {
            for (int i = 0; i < (int)Config::presets.size(); i++) {
                bool is_selected = (selected_preset == i);
                ImGui::PushID(i);
                if (ImGui::Selectable(Config::presets[i].name.c_str(), is_selected)) {
                    selected_preset = i;
                    Config::ApplyPreset(i, engine);
                }
                if (is_selected) ImGui::SetItemDefaultFocus();
                ImGui::PopID();
            }
            ImGui::EndCombo();
        }

        static char new_preset_name[64] = "";
        ImGui::SetNextItemWidth(ImGui::GetContentRegionAvail().x * 0.4f);
        ImGui::InputText("##NewPresetName", new_preset_name, 64);
        if (ImGui::IsItemHovered()) ImGui::SetTooltip("Enter a name for your new user preset.");
        ImGui::SameLine();
        if (ImGui::Button("Save New")) {
            if (strlen(new_preset_name) > 0) {
                Config::AddUserPreset(std::string(new_preset_name), engine);
                for (int i = 0; i < (int)Config::presets.size(); i++) {
                    if (Config::presets[i].name == std::string(new_preset_name)) {
                        selected_preset = i;
                        break;
                    }
                }
                new_preset_name[0] = '\0';
            }
        }
        if (ImGui::IsItemHovered()) ImGui::SetTooltip("Create a new user preset from the current settings.");

        if (ImGui::Button("Save Current Config")) {
            if (selected_preset >= 0 && selected_preset < (int)Config::presets.size() && !Config::presets[selected_preset].is_builtin) {
                Config::AddUserPreset(Config::presets[selected_preset].name, engine);
            } else {
                Config::Save(engine);
            }
        }
        if (ImGui::IsItemHovered()) ImGui::SetTooltip("Save modifications to the selected user preset or global calibration.");
        ImGui::SameLine();
        if (ImGui::Button("Reset Defaults")) {
            Config::ApplyPreset(0, engine);
            selected_preset = 0;
        }
        if (ImGui::IsItemHovered()) ImGui::SetTooltip("Revert all settings to factory default (T300 baseline).");
        ImGui::SameLine();
        if (ImGui::Button("Duplicate")) {
            if (selected_preset >= 0) {
                Config::DuplicatePreset(selected_preset, engine);
                for (int i = 0; i < (int)Config::presets.size(); i++) {
                    if (Config::presets[i].name == Config::m_last_preset_name) {
                        selected_preset = i;
                        break;
                    }
                }
            }
        }
        if (ImGui::IsItemHovered()) ImGui::SetTooltip("Create a copy of the currently selected preset.");
        ImGui::SameLine();
        bool can_delete = (selected_preset >= 0 && selected_preset < (int)Config::presets.size() && !Config::presets[selected_preset].is_builtin);
        if (!can_delete) ImGui::BeginDisabled();
        if (ImGui::Button("Delete")) {
            Config::DeletePreset(selected_preset, engine);
            selected_preset = 0;
            Config::ApplyPreset(0, engine);
        }
        if (ImGui::IsItemHovered()) ImGui::SetTooltip("Remove the selected user preset (builtin presets are protected).");
        if (!can_delete) ImGui::EndDisabled();

        ImGui::Separator();
        if (ImGui::Button("Import Preset...")) {
            std::string path;
            if (OpenPresetFileDialogPlatform(path)) {
                if (Config::ImportPreset(path, engine)) {
                    selected_preset = (int)Config::presets.size() - 1;
                }
            }
        }
        if (ImGui::IsItemHovered()) ImGui::SetTooltip("Import an external .ini preset file.");
        ImGui::SameLine();
        if (ImGui::Button("Export Selected...")) {
            if (selected_preset >= 0 && selected_preset < (int)Config::presets.size()) {
                std::string path;
                std::string defaultName = Config::presets[selected_preset].name + ".ini";
                if (SavePresetFileDialogPlatform(path, defaultName)) {
                    Config::ExportPreset(selected_preset, path);
                }
            }
        }
        if (ImGui::IsItemHovered()) ImGui::SetTooltip("Export the current preset to an external .ini file.");

        ImGui::TreePop();
    }

    ImGui::Spacing();

    ImGui::Columns(2, "SettingsGrid", false);
    ImGui::SetColumnWidth(0, ImGui::GetWindowWidth() * 0.45f);

    if (ImGui::TreeNodeEx("General FFB", ImGuiTreeNodeFlags_DefaultOpen | ImGuiTreeNodeFlags_Framed)) {
        ImGui::NextColumn(); ImGui::NextColumn();

        if (ImGui::TreeNode("System Health (Hz)")) {
            ImGui::Columns(3, "RateCols", false);
            auto DisplayRate = [](const char* label, double rate, double target) {
                ImGui::Text("%s", label);
                ImVec4 color = ImVec4(1.0f, 0.4f, 0.4f, 1.0f); // Red
                if (rate >= target * 0.95) color = ImVec4(0.4f, 1.0f, 0.4f, 1.0f); // Green
                else if (rate >= target * 0.75) color = ImVec4(1.0f, 1.0f, 0.4f, 1.0f); // Yellow
                ImGui::TextColored(color, "%.1f Hz", rate);
            };
            DisplayRate("FFB Loop", engine.m_ffb_rate, 400.0);
            ImGui::NextColumn();
            DisplayRate("Telemetry", engine.m_telemetry_rate, 400.0);
            ImGui::NextColumn();
            DisplayRate("Hardware", engine.m_hw_rate, 400.0);
            ImGui::NextColumn();
            DisplayRate("S.Torque", engine.m_torque_rate, 400.0);
            ImGui::NextColumn();
            DisplayRate("G.Torque", engine.m_gen_torque_rate, 400.0);
            ImGui::Columns(1);
            if ((engine.m_telemetry_rate < 380.0 || engine.m_torque_rate < 380.0) && engine.m_telemetry_rate > 1.0 && GameConnector::Get().IsConnected()) {
                ImGui::TextColored(ImVec4(1, 1, 0, 1), "Warning: Low telemetry/torque rate. Check game FFB settings.");
            }
            ImGui::TreePop();
            ImGui::Separator();
        }

        BoolSetting("Invert FFB Signal", &engine.m_invert_force, "Check this if the wheel pulls away from center instead of aligning.");
        FloatSetting("Master Gain", &engine.m_gain, 0.0f, 2.0f, FormatPct(engine.m_gain), "Global scale factor for all forces.\n100% = No attenuation.\nReduce if experiencing heavy clipping.");
        FloatSetting("Max Torque Ref", &engine.m_max_torque_ref, 1.0f, 200.0f, "%.1f Nm", "The expected PEAK torque of the CAR in the game.");
        FloatSetting("Min Force", &engine.m_min_force, 0.0f, 0.20f, "%.3f", "Boosts small forces to overcome mechanical friction/deadzone.");

        ImGui::TreePop();
    } else {
        ImGui::NextColumn(); ImGui::NextColumn();
    }

    if (ImGui::TreeNodeEx("Front Axle (Understeer)", ImGuiTreeNodeFlags_DefaultOpen | ImGuiTreeNodeFlags_Framed)) {
        ImGui::NextColumn(); ImGui::NextColumn();

        FloatSetting("Steering Shaft Gain", &engine.m_steering_shaft_gain, 0.0f, 2.0f, FormatPct(engine.m_steering_shaft_gain), "Scales the raw steering torque from the physics engine.");

        FloatSetting("Steering Shaft Smoothing", &engine.m_steering_shaft_smoothing, 0.000f, 0.100f, "%.3f s",
            "Low Pass Filter applied ONLY to the raw game force.",
            [&]() {
                int ms = (int)(engine.m_steering_shaft_smoothing * 1000.0f + 0.5f);
                ImVec4 color = (ms < LATENCY_WARNING_THRESHOLD_MS) ? ImVec4(0,1,0,1) : ImVec4(1,0,0,1);
                ImGui::TextColored(color, "Latency: %d ms - %s", ms, (ms < LATENCY_WARNING_THRESHOLD_MS) ? "OK" : "High");
            });

        FloatSetting("Understeer Effect", &engine.m_understeer_effect, 0.0f, 2.0f, FormatPct(engine.m_understeer_effect),
            "Scales how much front grip loss reduces steering force.");

        FloatSetting("Dynamic Weight", &engine.m_dynamic_weight_gain, 0.0f, 2.0f, FormatPct(engine.m_dynamic_weight_gain),
            "Scales steering weight based on longitudinal load transfer.\n"
            "Heavier under braking, lighter under acceleration.");

        FloatSetting("  Weight Smoothing", &engine.m_dynamic_weight_smoothing, 0.000f, 0.500f, "%.3f s",
            "Filters the Dynamic Weight signal to simulate suspension damping.\n"
            "Higher = Smoother weight transfer feel, but less instant.\n"
            "Recommended: 0.100s - 0.200s.");

        const char* base_modes[] = { "Native (Steering Shaft Torque)", "Synthetic (Constant)", "Muted (Off)" };
        IntSetting("Base Force Mode", &engine.m_base_force_mode, base_modes, sizeof(base_modes)/sizeof(base_modes[0]),
            "Debug tool to isolate effects.\nNative: Normal Operation.\nSynthetic: Constant force to test direction.\nMuted: Disables base physics (good for tuning vibrations).");

        const char* torque_sources[] = { "Shaft Torque (100Hz Legacy)", "Direct Torque (400Hz LMU 1.2+)" };
        IntSetting("Torque Source", &engine.m_torque_source, torque_sources, sizeof(torque_sources)/sizeof(torque_sources[0]),
            "Select the telemetry channel for base steering torque.\n"
            "Shaft Torque: Standard rF2 physics channel (typically 100Hz).\n"
            "Direct Torque: New LMU high-frequency channel (native 400Hz). RECOMMENDED.");

        if (ImGui::TreeNodeEx("Signal Filtering", ImGuiTreeNodeFlags_DefaultOpen)) {
            ImGui::NextColumn(); ImGui::NextColumn();

            BoolSetting("  Flatspot Suppression", &engine.m_flatspot_suppression, "Dynamic Notch Filter that targets wheel rotation frequency.\nSuppresses vibrations caused by tire flatspots.");
            if (engine.m_flatspot_suppression) {
                FloatSetting("    Filter Width (Q)", &engine.m_notch_q, 0.5f, 10.0f, "Q: %.2f", "Quality Factor of the Notch Filter.\nHigher = Narrower bandwidth (surgical removal).\nLower = Wider bandwidth (affects surrounding frequencies).");
                FloatSetting("    Suppression Strength", &engine.m_flatspot_strength, 0.0f, 1.0f, "%.2f", "How strongly to mute the flatspot vibration.\n1.0 = 100% removal.");
                ImGui::Text("    Est. / Theory Freq");
                ImGui::NextColumn();
                ImGui::TextDisabled("%.1f Hz / %.1f Hz", engine.m_debug_freq, engine.m_theoretical_freq);
                ImGui::NextColumn();
            }

            BoolSetting("  Static Noise Filter", &engine.m_static_notch_enabled, "Fixed frequency notch filter to remove hardware resonance or specific noise.");
            if (engine.m_static_notch_enabled) {
                FloatSetting("    Target Frequency", &engine.m_static_notch_freq, 10.0f, 100.0f, "%.1f Hz", "Center frequency to suppress.");
                FloatSetting("    Filter Width", &engine.m_static_notch_width, 0.1f, 10.0f, "%.1f Hz", "Bandwidth of the notch filter.\nLarger = Blocks more frequencies around the target.");
            }

            ImGui::TreePop();
        } else {
            ImGui::NextColumn(); ImGui::NextColumn();
        }

        ImGui::TreePop();
    } else {
        ImGui::NextColumn(); ImGui::NextColumn();
    }

    if (ImGui::TreeNodeEx("Rear Axle (Oversteer)", ImGuiTreeNodeFlags_DefaultOpen | ImGuiTreeNodeFlags_Framed)) {
        ImGui::NextColumn(); ImGui::NextColumn();

        FloatSetting("Lateral G Boost (Slide)", &engine.m_oversteer_boost, 0.0f, 4.0f, FormatPct(engine.m_oversteer_boost),
            "Increases the Lateral G (SoP) force when the rear tires lose grip.\nMakes the car feel heavier during a slide, helping you judge the momentum.\nShould build up slightly more gradually than Rear Align Torque,\nreflecting the inertia of the car's mass swinging out.\nIt's a sustained force that tells you about the magnitude of the slide\nTuning Goal: The driver should feel the direction of the counter-steer (Rear Align)\nand the effort required to hold it (Lateral G Boost).");
        FloatSetting("Lateral G", &engine.m_sop_effect, 0.0f, 2.0f, FormatDecoupled(engine.m_sop_effect, FFBEngine::BASE_NM_SOP_LATERAL), "Represents Chassis Roll, simulates the weight of the car leaning in the corner.");
        FloatSetting("SoP Self-Aligning Torque", &engine.m_rear_align_effect, 0.0f, 2.0f, FormatDecoupled(engine.m_rear_align_effect, FFBEngine::BASE_NM_REAR_ALIGN),
            "Counter-steering force generated by rear tire slip.\nShould build up very quickly after the Yaw Kick, as the slip angle develops.\nThis is the active \"pull.\"\nTuning Goal: The driver should feel the direction of the counter-steer (Rear Align)\nand the effort required to hold it (Lateral G Boost).");
        FloatSetting("Yaw Kick", &engine.m_sop_yaw_gain, 0.0f, 1.0f, FormatDecoupled(engine.m_sop_yaw_gain, FFBEngine::BASE_NM_YAW_KICK),
            "This is the earliest cue for rear stepping out. It's a sharp, momentary impulse that signals the onset of rotation.\nBased on Yaw Acceleration.");
        FloatSetting("  Activation Threshold", &engine.m_yaw_kick_threshold, 0.0f, 10.0f, "%.2f rad/s²", "Minimum yaw acceleration required to trigger the kick.\nIncrease to filter out road noise and small vibrations.");

        FloatSetting("  Kick Response", &engine.m_yaw_accel_smoothing, 0.000f, 0.050f, "%.3f s",
            "Low Pass Filter for the Yaw Kick signal.\nSmoothes out kick noise.\nLower = Sharper/Faster kick.\nHigher = Duller/Softer kick.",
            [&]() {
                int ms = (int)(engine.m_yaw_accel_smoothing * 1000.0f + 0.5f);
                ImVec4 color = (ms <= 15) ? ImVec4(0,1,0,1) : ImVec4(1,0,0,1);
                ImGui::TextColored(color, "Latency: %d ms", ms);
            });

        FloatSetting("Gyro Damping", &engine.m_gyro_gain, 0.0f, 1.0f, FormatDecoupled(engine.m_gyro_gain, FFBEngine::BASE_NM_GYRO_DAMPING), "Simulates the gyroscopic solidity of the spinning wheels.\nResists rapid steering movements.\nPrevents oscillation and 'Tank Slappers'.\nActs like a steering damper.");

        FloatSetting("  Gyro Smooth", &engine.m_gyro_smoothing, 0.000f, 0.050f, "%.3f s",
            "Filters the steering velocity signal used for damping.\nReduces noise in the damping effect.\nLow = Crisper damping, High = Smoother.",
            [&]() {
                int ms = (int)(engine.m_gyro_smoothing * 1000.0f + 0.5f);
                ImVec4 color = (ms <= 20) ? ImVec4(0,1,0,1) : ImVec4(1,0,0,1);
                ImGui::TextColored(color, "Latency: %d ms", ms);
            });

        ImGui::TextColored(ImVec4(0.0f, 0.6f, 0.85f, 1.0f), "Advanced SoP");
        ImGui::NextColumn(); ImGui::NextColumn();

        FloatSetting("SoP Smoothing", &engine.m_sop_smoothing_factor, 0.0f, 1.0f, "%.2f",
            "Filters the Lateral G signal.\nReduces jerkiness in the SoP effect.",
            [&]() {
                int ms = (int)((1.0f - engine.m_sop_smoothing_factor) * 100.0f + 0.5f);
                ImVec4 color = (ms < LATENCY_WARNING_THRESHOLD_MS) ? ImVec4(0,1,0,1) : ImVec4(1,0,0,1);
                ImGui::TextColored(color, "Latency: %d ms - %s", ms, (ms < LATENCY_WARNING_THRESHOLD_MS) ? "OK" : "High");
            });

        FloatSetting("Grip Smoothing", &engine.m_grip_smoothing_steady, 0.000f, 0.100f, "%.3f s",
            "Filters the final estimated grip value.\n"
            "Uses an adaptive non-linear filter: smooths steady-state noise\n"
            "but maintains zero-latency during rapid grip loss events.\n"
            "Recommended: 0.030s - 0.060s.");

        FloatSetting("  SoP Scale", &engine.m_sop_scale, 0.0f, 20.0f, "%.2f", "Multiplies the raw G-force signal before limiting.\nAdjusts the dynamic range of the SoP effect.");

        ImGui::TreePop();
    } else {
        ImGui::NextColumn(); ImGui::NextColumn();
    }

    if (ImGui::TreeNodeEx("Grip & Slip Angle Estimation", ImGuiTreeNodeFlags_DefaultOpen | ImGuiTreeNodeFlags_Framed)) {
        ImGui::NextColumn(); ImGui::NextColumn();

        FloatSetting("Slip Angle Smoothing", &engine.m_slip_angle_smoothing, 0.000f, 0.100f, "%.3f s",
            "Applies a time-based filter (LPF) to the Calculated Slip Angle used to estimate tire grip.\n"
            "Smooths the high fluctuations from lateral and longitudinal velocity,\nespecially over bumps or curbs.\n"
            "Affects: Understeer effect, Rear Aligning Torque.",
            [&]() {
                int ms = (int)(engine.m_slip_angle_smoothing * 1000.0f + 0.5f);
                ImVec4 color = (ms < LATENCY_WARNING_THRESHOLD_MS) ? ImVec4(0,1,0,1) : ImVec4(1,0,0,1);
                ImGui::TextColored(color, "Latency: %d ms - %s", ms, (ms < LATENCY_WARNING_THRESHOLD_MS) ? "OK" : "High");
            });

        FloatSetting("Chassis Inertia (Load)", &engine.m_chassis_inertia_smoothing, 0.000f, 0.100f, "%.3f s",
            "Simulation time for weight transfer.\nSimulates how fast the suspension settles.\nAffects calculated tire load magnitude.\n25ms = Stiff Race Car.\n50ms = Soft Road Car.",
            [&]() {
                int ms = (int)(engine.m_chassis_inertia_smoothing * 1000.0f + 0.5f);
                ImGui::TextColored(ImVec4(0.5f, 0.5f, 1.0f, 1.0f), "Simulation: %d ms", ms);
            });

        FloatSetting("Optimal Slip Angle", &engine.m_optimal_slip_angle, 0.05f, 0.20f, "%.2f rad",
            "The slip angle THRESHOLD above which grip loss begins.\n"
            "Set this HIGHER than the car's physical peak slip angle.\n"
            "Recommended: 0.10 for LMDh/LMP2, 0.12 for GT3.\n\n"
            "Lower = More sensitive (force drops earlier).\n"
            "Higher = More buffer zone before force drops.\n\n"
            "NOTE: If the wheel feels too light at the limit, INCREASE this value.\n"
            "Affects: Understeer Effect, Lateral G Boost (Slide), Slide Texture.");
        FloatSetting("Optimal Slip Ratio", &engine.m_optimal_slip_ratio, 0.05f, 0.20f, "%.2f",
            "The longitudinal slip ratio (0.0-1.0) where peak braking/traction occurs.\n"
            "Typical: 0.12 - 0.15 (12-15%).\n"
            "Used to estimate grip loss under braking/acceleration.\n"
            "Affects: How much braking/acceleration contributes to calculated grip loss.");

        ImGui::Separator();
        ImGui::TextColored(ImVec4(1.0f, 0.8f, 0.0f, 1.0f), "Slope Detection (Experimental)");
        ImGui::NextColumn(); ImGui::NextColumn();

        bool prev_slope_enabled = engine.m_slope_detection_enabled;
        GuiWidgets::Result slope_res = GuiWidgets::Checkbox("Enable Slope Detection", &engine.m_slope_detection_enabled,
            "Replaces static 'Optimal Slip Angle' threshold with dynamic derivative monitoring.\n\n"
            "When enabled:\n"
            "• Grip is estimated by tracking the slope of lateral-G vs slip angle\n"
            "• Automatically adapts to tire temperature, wear, and conditions\n"
            "• 'Optimal Slip Angle' and 'Optimal Slip Ratio' settings are IGNORED\n\n"
            "When disabled:\n"
            "• Uses the static threshold method (default behavior)");

        if (slope_res.changed) {
            if (!prev_slope_enabled && engine.m_slope_detection_enabled) {
                engine.m_slope_buffer_count = 0;
                engine.m_slope_buffer_index = 0;
                engine.m_slope_smoothed_output = 1.0;
            }
        }
        if (slope_res.deactivated) {
            Config::Save(engine);
        }

        if (engine.m_slope_detection_enabled && engine.m_oversteer_boost > 0.01f) {
            ImGui::TextColored(ImVec4(1.0f, 0.5f, 0.0f, 1.0f),
                "Note: Lateral G Boost (Slide) is auto-disabled when Slope Detection is ON.");
            ImGui::NextColumn(); ImGui::NextColumn();
        }

        if (engine.m_slope_detection_enabled) {
            int window = engine.m_slope_sg_window;
            if (ImGui::SliderInt("  Filter Window", &window, 5, 41)) {
                if (window % 2 == 0) window++;
                engine.m_slope_sg_window = window;
            }
            if (ImGui::IsItemHovered()) {
                ImGui::SetTooltip(
                    "Savitzky-Golay filter window size (samples).\n\n"
                    "Larger = Smoother but higher latency\n"
                    "Smaller = Faster response but noisier\n\n"
                    "Recommended:\n"
                    "  Direct Drive: 11-15\n"
                    "  Belt Drive: 15-21\n"
                    "  Gear Drive: 21-31\n\n"
                    "Must be ODD (enforced automatically).");
            }
            if (ImGui::IsItemDeactivatedAfterEdit()) Config::Save(engine);

            ImGui::SameLine();
            float latency_ms = (float)(engine.m_slope_sg_window / 2) * 2.5f;
            ImVec4 color = (latency_ms < 25.0f) ? ImVec4(0,1,0,1) : ImVec4(1,0.5f,0,1);
            ImGui::TextColored(color, "~%.0f ms latency", latency_ms);
            ImGui::NextColumn(); ImGui::NextColumn();

            FloatSetting("  Sensitivity", &engine.m_slope_sensitivity, 0.1f, 5.0f, "%.1fx",
                "Multiplier for slope-to-grip conversion.\n"
                "Higher = More aggressive grip loss detection.\n"
                "Lower = Smoother, less pronounced effect.");

            if (ImGui::TreeNode("Advanced Slope Settings")) {
                ImGui::NextColumn(); ImGui::NextColumn();
                FloatSetting("  Slope Threshold", &engine.m_slope_min_threshold, -1.0f, 0.0f, "%.2f", "Slope value below which grip loss begins.\nMore negative = Later detection (safer).");
                FloatSetting("  Output Smoothing", &engine.m_slope_smoothing_tau, 0.005f, 0.100f, "%.3f s", "Time constant for grip factor smoothing.\nPrevents abrupt FFB changes.");

                ImGui::Separator();
                ImGui::Text("Stability Fixes (v0.7.3)");
                ImGui::NextColumn(); ImGui::NextColumn();
                FloatSetting("  Alpha Threshold", &engine.m_slope_alpha_threshold, 0.001f, 0.100f, "%.3f", "Confidence threshold for slope detection.\nHigher = Stricter (less noise, potentially slower).");
                FloatSetting("  Decay Rate", &engine.m_slope_decay_rate, 0.5f, 20.0f, "%.1f", "How quickly the grip factor recovers after a slide.\nHigher = Faster recovery.");
                BoolSetting("  Confidence Gate", &engine.m_slope_confidence_enabled, "Ensures slope changes are statistically significant before applying grip loss.");

                ImGui::TreePop();
            } else {
                ImGui::NextColumn(); ImGui::NextColumn();
            }

            ImGui::Text("  Live Slope: %.3f | Grip: %.0f%%",
                engine.m_slope_current,
                engine.m_slope_smoothed_output * 100.0f);
            ImGui::NextColumn(); ImGui::NextColumn();
        }

        ImGui::TreePop();
    } else {
        ImGui::NextColumn(); ImGui::NextColumn();
    }

    if (ImGui::TreeNodeEx("Braking & Lockup", ImGuiTreeNodeFlags_DefaultOpen | ImGuiTreeNodeFlags_Framed)) {
        ImGui::NextColumn(); ImGui::NextColumn();

        BoolSetting("Lockup Vibration", &engine.m_lockup_enabled, "Simulates tire judder when wheels are locked under braking.");
        if (engine.m_lockup_enabled) {
            FloatSetting("  Lockup Strength", &engine.m_lockup_gain, 0.0f, 3.0f, FormatDecoupled(engine.m_lockup_gain, FFBEngine::BASE_NM_LOCKUP_VIBRATION), "Controls the intensity of the vibration when wheels lock up.\nScales with wheel load and speed.");
            FloatSetting("  Brake Load Cap", &engine.m_brake_load_cap, 1.0f, 10.0f, "%.2fx", "Scales vibration intensity based on tire load.\nPrevents weak vibrations during high-speed heavy braking.");
            FloatSetting("  Vibration Pitch", &engine.m_lockup_freq_scale, 0.5f, 2.0f, "%.2fx", "Scales the frequency of lockup and wheel spin vibrations.\nMatch to your hardware resonance.");

            ImGui::Separator();
            ImGui::Text("Response Curve");
            ImGui::NextColumn(); ImGui::NextColumn();

            FloatSetting("  Gamma", &engine.m_lockup_gamma, 0.1f, 3.0f, "%.1f", "Response Curve Non-Linearity.\n1.0 = Linear.\n>1.0 = Progressive (Starts weak, gets strong fast).\n<1.0 = Aggressive (Starts strong). 2.0=Quadratic, 3.0=Cubic (Late/Sharp)");
            FloatSetting("  Start Slip %", &engine.m_lockup_start_pct, 1.0f, 10.0f, "%.1f%%", "Slip percentage where vibration begins.\n1.0% = Immediate feedback.\n5.0% = Only on deep lock.");
            FloatSetting("  Full Slip %", &engine.m_lockup_full_pct, 5.0f, 25.0f, "%.1f%%", "Slip percentage where vibration reaches maximum intensity.");

            ImGui::Separator();
            ImGui::Text("Prediction (Advanced)");
            ImGui::NextColumn(); ImGui::NextColumn();

            FloatSetting("  Sensitivity", &engine.m_lockup_prediction_sens, 10.0f, 100.0f, "%.0f", "Angular Deceleration Threshold.\nHow aggressively the system predicts a lockup before it physically occurs.\nLower = More sensitive (triggers earlier).\nHigher = Less sensitive.");
            FloatSetting("  Bump Rejection", &engine.m_lockup_bump_reject, 0.1f, 5.0f, "%.1f m/s", "Suspension velocity threshold.\nDisables prediction on bumpy surfaces to prevent false positives.\nIncrease for bumpy tracks (Sebring).");
            FloatSetting("  Rear Boost", &engine.m_lockup_rear_boost, 1.0f, 10.0f, "%.2fx", "Multiplies amplitude when rear wheels lock harder than front wheels.\nHelps distinguish rear locking (dangerous) from front locking (understeer).");
        }

        ImGui::Separator();
        ImGui::Text("ABS & Hardware");
        ImGui::NextColumn(); ImGui::NextColumn();

        BoolSetting("ABS Pulse", &engine.m_abs_pulse_enabled, "Simulates the pulsing of an ABS system.\nInjects high-frequency pulse when ABS modulates pressure.");
        if (engine.m_abs_pulse_enabled) {
            FloatSetting("  Pulse Gain", &engine.m_abs_gain, 0.0f, 10.0f, "%.2f", "Intensity of the ABS pulse.");
            FloatSetting("  Pulse Frequency", &engine.m_abs_freq_hz, 10.0f, 50.0f, "%.1f Hz", "Rate of the ABS pulse oscillation.");
        }

        ImGui::TreePop();
    } else {
        ImGui::NextColumn(); ImGui::NextColumn();
    }

    if (ImGui::TreeNodeEx("Tactile Textures", ImGuiTreeNodeFlags_DefaultOpen | ImGuiTreeNodeFlags_Framed)) {
        ImGui::NextColumn(); ImGui::NextColumn();

        FloatSetting("Texture Load Cap", &engine.m_texture_load_cap, 1.0f, 3.0f, "%.2fx", "Safety Limiter specific to Road and Slide textures.\nPrevents violent shaking when under high downforce or compression.\nONLY affects Road Details and Slide Rumble.");

        BoolSetting("Slide Rumble", &engine.m_slide_texture_enabled, "Vibration proportional to tire sliding/scrubbing velocity.");
        if (engine.m_slide_texture_enabled) {
            FloatSetting("  Slide Gain", &engine.m_slide_texture_gain, 0.0f, 2.0f, FormatDecoupled(engine.m_slide_texture_gain, FFBEngine::BASE_NM_SLIDE_TEXTURE), "Intensity of the scrubbing vibration.");
            FloatSetting("  Slide Pitch", &engine.m_slide_freq_scale, 0.5f, 5.0f, "%.2fx", "Frequency multiplier for the scrubbing sound/feel.\nHigher = Screeching.\nLower = Grinding.");
        }

        BoolSetting("Road Details", &engine.m_road_texture_enabled, "Vibration derived from high-frequency suspension movement.\nFeels road surface, cracks, and bumps.");
        if (engine.m_road_texture_enabled) {
            FloatSetting("  Road Gain", &engine.m_road_texture_gain, 0.0f, 2.0f, FormatDecoupled(engine.m_road_texture_gain, FFBEngine::BASE_NM_ROAD_TEXTURE), "Intensity of road details.");
        }

        BoolSetting("Spin Vibration", &engine.m_spin_enabled, "Vibration when wheels lose traction under acceleration (Wheel Spin).");
        if (engine.m_spin_enabled) {
            FloatSetting("  Spin Strength", &engine.m_spin_gain, 0.0f, 2.0f, FormatDecoupled(engine.m_spin_gain, FFBEngine::BASE_NM_SPIN_VIBRATION), "Intensity of the wheel spin vibration.");
            FloatSetting("  Spin Pitch", &engine.m_spin_freq_scale, 0.5f, 2.0f, "%.2fx", "Scales the frequency of the wheel spin vibration.");
        }

        FloatSetting("Scrub Drag", &engine.m_scrub_drag_gain, 0.0f, 1.0f, FormatDecoupled(engine.m_scrub_drag_gain, FFBEngine::BASE_NM_SCRUB_DRAG), "Constant resistance force when pushing tires laterally (Understeer drag).\nAdds weight to the wheel when scrubbing.");

        const char* bottoming_modes[] = { "Method A: Scraping", "Method B: Susp. Spike" };
        IntSetting("Bottoming Logic", &engine.m_bottoming_method, bottoming_modes, sizeof(bottoming_modes)/sizeof(bottoming_modes[0]), "Algorithm for detecting suspension bottoming.\nScraping = Ride height based.\nSusp Spike = Force rate based.");

        ImGui::TreePop();
    } else {
        ImGui::NextColumn(); ImGui::NextColumn();
    }

    if (ImGui::CollapsingHeader("Advanced Settings")) {
        ImGui::Indent();

        if (ImGui::TreeNode("Stationary Vibration Gate")) {
            float lower_kmh = engine.m_speed_gate_lower * 3.6f;
            if (ImGui::SliderFloat("Mute Below", &lower_kmh, 0.0f, 20.0f, "%.1f km/h")) {
                engine.m_speed_gate_lower = lower_kmh / 3.6f;
                if (engine.m_speed_gate_upper <= engine.m_speed_gate_lower + 0.1f)
                    engine.m_speed_gate_upper = engine.m_speed_gate_lower + 0.5f;
            }
            if (ImGui::IsItemHovered()) ImGui::SetTooltip("The speed below which all haptic vibrations (Road, Slide, Lockup, Spin) are completely muted to prevent idle shaking.");
            if (ImGui::IsItemDeactivatedAfterEdit()) Config::Save(engine);

            float upper_kmh = engine.m_speed_gate_upper * 3.6f;
            if (ImGui::SliderFloat("Full Above", &upper_kmh, 1.0f, 50.0f, "%.1f km/h")) {
                engine.m_speed_gate_upper = upper_kmh / 3.6f;
                if (engine.m_speed_gate_upper <= engine.m_speed_gate_lower + 0.1f)
                    engine.m_speed_gate_upper = engine.m_speed_gate_lower + 0.5f;
            }
            if (ImGui::IsItemHovered()) ImGui::SetTooltip("The speed above which all haptic vibrations reach their full configured strength.");
            if (ImGui::IsItemDeactivatedAfterEdit()) Config::Save(engine);

            ImGui::TreePop();
        }

        if (ImGui::TreeNode("Telemetry Logger")) {
            if (ImGui::Checkbox("Auto-Start on Session", &Config::m_auto_start_logging)) {
                Config::Save(engine);
            }

            char log_path_buf[256];
#ifdef _WIN32
            strncpy_s(log_path_buf, Config::m_log_path.c_str(), 255);
#else
            strncpy(log_path_buf, Config::m_log_path.c_str(), 255);
#endif
            log_path_buf[255] = '\0';
            if (ImGui::InputText("Log Path", log_path_buf, 255)) {
                Config::m_log_path = log_path_buf;
            }
            if (ImGui::IsItemHovered()) ImGui::SetTooltip("Directory where .csv telemetry logs will be saved.");
            if (ImGui::IsItemDeactivatedAfterEdit()) Config::Save(engine);

            if (AsyncLogger::Get().IsLogging()) {
                ImGui::BulletText("Filename: %s", AsyncLogger::Get().GetFilename().c_str());
            }

            ImGui::TreePop();
        }
        ImGui::Unindent();
    }

    ImGui::Columns(1);
    ImGui::End();
}

const float PLOT_HISTORY_SEC = 10.0f;
const int PHYSICS_RATE_HZ = 400;
const int PLOT_BUFFER_SIZE = (int)(PLOT_HISTORY_SEC * PHYSICS_RATE_HZ);

struct RollingBuffer {
    std::vector<float> data;
    int offset = 0;

    RollingBuffer() {
        data.resize(PLOT_BUFFER_SIZE, 0.0f);
    }

    void Add(float val) {
        data[offset] = val;
        offset = (offset + 1) % (int)data.size();
    }

    float GetCurrent() const {
        if (data.empty()) return 0.0f;
        size_t idx = (offset - 1 + (int)data.size()) % (int)data.size();
        return data[idx];
    }

    float GetMin() const {
        if (data.empty()) return 0.0f;
        return *std::min_element(data.begin(), data.end());
    }

    float GetMax() const {
        if (data.empty()) return 0.0f;
        return *std::max_element(data.begin(), data.end());
    }
};

inline void PlotWithStats(const char* label, const RollingBuffer& buffer,
                          float scale_min, float scale_max,
                          const ImVec2& size = ImVec2(0, 40),
                          const char* tooltip = nullptr) {
    ImGui::Text("%s", label);
    char hidden_label[256];
    snprintf(hidden_label, sizeof(hidden_label), "##%s", label);
    ImGui::PlotLines(hidden_label, buffer.data.data(), (int)buffer.data.size(),
                     buffer.offset, NULL, scale_min, scale_max, size);
    if (tooltip && ImGui::IsItemHovered()) ImGui::SetTooltip("%s", tooltip);

    float current = buffer.GetCurrent();
    float min_val = buffer.GetMin();
    float max_val = buffer.GetMax();
    char stats_overlay[128];
    snprintf(stats_overlay, sizeof(stats_overlay), "Cur:%.4f Min:%.3f Max:%.3f", current, min_val, max_val);

    ImVec2 p_min = ImGui::GetItemRectMin();
    ImVec2 p_max = ImGui::GetItemRectMax();
    float plot_width = p_max.x - p_min.x;
    p_min.x += 2; p_min.y += 2;

    ImDrawList* draw_list = ImGui::GetWindowDrawList();
    ImFont* font = ImGui::GetFont();
    float font_size = ImGui::GetFontSize();
    ImVec2 text_size = font->CalcTextSizeA(font_size, FLT_MAX, 0.0f, stats_overlay);

    if (text_size.x > plot_width - 4) {
         snprintf(stats_overlay, sizeof(stats_overlay), "%.4f [%.3f, %.3f]", current, min_val, max_val);
         text_size = font->CalcTextSizeA(font_size, FLT_MAX, 0.0f, stats_overlay);
         if (text_size.x > plot_width - 4) {
             snprintf(stats_overlay, sizeof(stats_overlay), "Val: %.4f", current);
             text_size = font->CalcTextSizeA(font_size, FLT_MAX, 0.0f, stats_overlay);
         }
    }
    draw_list->AddRectFilled(ImVec2(p_min.x - 1, p_min.y), ImVec2(p_min.x + text_size.x + 2, p_min.y + text_size.y), IM_COL32(0, 0, 0, 90));
    draw_list->AddText(font, font_size, p_min, IM_COL32(255, 255, 255, 255), stats_overlay);
}

// Global Buffers
static RollingBuffer plot_total, plot_base, plot_sop, plot_yaw_kick, plot_rear_torque, plot_gyro_damping, plot_scrub_drag, plot_oversteer, plot_understeer, plot_clipping, plot_road, plot_slide, plot_lockup, plot_spin, plot_bottoming;
static RollingBuffer plot_calc_front_load, plot_calc_rear_load, plot_calc_front_grip, plot_calc_rear_grip, plot_calc_slip_ratio, plot_calc_slip_angle_smoothed, plot_calc_rear_slip_angle_smoothed, plot_slope_current, plot_calc_rear_lat_force;
static RollingBuffer plot_raw_steer, plot_raw_input_steering, plot_raw_throttle, plot_raw_brake, plot_input_accel, plot_raw_car_speed, plot_raw_load, plot_raw_grip, plot_raw_rear_grip, plot_raw_front_slip_ratio, plot_raw_susp_force, plot_raw_ride_height, plot_raw_front_lat_patch_vel, plot_raw_front_long_patch_vel, plot_raw_rear_lat_patch_vel, plot_raw_rear_long_patch_vel, plot_raw_slip_angle, plot_raw_rear_slip_angle, plot_raw_front_deflection;

static bool g_warn_dt = false;

void GuiLayer::DrawDebugWindow(FFBEngine& engine) {
    if (!Config::show_graphs) return;

    ImGuiViewport* viewport = ImGui::GetMainViewport();
    ImGui::SetNextWindowPos(ImVec2(viewport->Pos.x + CONFIG_PANEL_WIDTH, viewport->Pos.y));
    ImGui::SetNextWindowSize(ImVec2(viewport->Size.x - CONFIG_PANEL_WIDTH, viewport->Size.y));

    ImGuiWindowFlags flags = ImGuiWindowFlags_NoDecoration | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoResize;
    ImGui::Begin("FFB Analysis", nullptr, flags);

    auto snapshots = engine.GetDebugBatch();
    for (const auto& snap : snapshots) {
        plot_total.Add(snap.total_output);
        plot_base.Add(snap.base_force);
        plot_sop.Add(snap.sop_force);
        plot_yaw_kick.Add(snap.ffb_yaw_kick);
        plot_rear_torque.Add(snap.ffb_rear_torque);
        plot_gyro_damping.Add(snap.ffb_gyro_damping);
        plot_scrub_drag.Add(snap.ffb_scrub_drag);
        plot_oversteer.Add(snap.oversteer_boost);
        plot_understeer.Add(snap.understeer_drop);
        plot_clipping.Add(snap.clipping);
        plot_road.Add(snap.texture_road);
        plot_slide.Add(snap.texture_slide);
        plot_lockup.Add(snap.texture_lockup);
        plot_spin.Add(snap.texture_spin);
        plot_bottoming.Add(snap.texture_bottoming);
        plot_calc_front_load.Add(snap.calc_front_load);
        plot_calc_rear_load.Add(snap.calc_rear_load);
        plot_calc_front_grip.Add(snap.calc_front_grip);
        plot_calc_rear_grip.Add(snap.calc_rear_grip);
        plot_calc_slip_ratio.Add(snap.calc_front_slip_ratio);
        plot_calc_slip_angle_smoothed.Add(snap.calc_front_slip_angle_smoothed);
        plot_calc_rear_slip_angle_smoothed.Add(snap.calc_rear_slip_angle_smoothed);
        plot_calc_rear_lat_force.Add(snap.calc_rear_lat_force);
        plot_slope_current.Add(snap.slope_current);
        plot_raw_steer.Add(snap.steer_force);
        plot_raw_input_steering.Add(snap.raw_input_steering);
        plot_raw_throttle.Add(snap.raw_input_throttle);
        plot_raw_brake.Add(snap.raw_input_brake);
        plot_input_accel.Add(snap.accel_x);
        plot_raw_car_speed.Add(snap.raw_car_speed);
        plot_raw_load.Add(snap.raw_front_tire_load);
        plot_raw_grip.Add(snap.raw_front_grip_fract);
        plot_raw_rear_grip.Add(snap.raw_rear_grip);
        plot_raw_front_slip_ratio.Add(snap.raw_front_slip_ratio);
        plot_raw_susp_force.Add(snap.raw_front_susp_force);
        plot_raw_ride_height.Add(snap.raw_front_ride_height);
        plot_raw_front_lat_patch_vel.Add(snap.raw_front_lat_patch_vel);
        plot_raw_front_long_patch_vel.Add(snap.raw_front_long_patch_vel);
        plot_raw_rear_lat_patch_vel.Add(snap.raw_rear_lat_patch_vel);
        plot_raw_rear_long_patch_vel.Add(snap.raw_rear_long_patch_vel);
        plot_raw_slip_angle.Add(snap.raw_front_slip_angle);
        plot_raw_rear_slip_angle.Add(snap.raw_rear_slip_angle);
        plot_raw_front_deflection.Add(snap.raw_front_deflection);
        g_warn_dt = snap.warn_dt;
    }

    if (g_warn_dt) {
        ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(1.0f, 0.0f, 0.0f, 1.0f));
        ImGui::Text("TELEMETRY WARNINGS: - Invalid DeltaTime");
        ImGui::PopStyleColor();
        ImGui::Separator();
    }

    if (ImGui::CollapsingHeader("A. FFB Components (Output)", ImGuiTreeNodeFlags_DefaultOpen)) {
        PlotWithStats("Total Output", plot_total, -1.0f, 1.0f, ImVec2(0, 60));
        ImGui::Separator();
        ImGui::Columns(3, "FFBMain", false);
        ImGui::TextColored(ImVec4(0.7f, 0.7f, 1.0f, 1.0f), "[Main Forces]");
        PlotWithStats("Base Torque (Nm)", plot_base, -30.0f, 30.0f);
        PlotWithStats("SoP (Chassis G)", plot_sop, -20.0f, 20.0f);
        PlotWithStats("Yaw Kick", plot_yaw_kick, -20.0f, 20.0f);
        PlotWithStats("Rear Align", plot_rear_torque, -20.0f, 20.0f);
        PlotWithStats("Gyro Damping", plot_gyro_damping, -20.0f, 20.0f);
        PlotWithStats("Scrub Drag", plot_scrub_drag, -20.0f, 20.0f);
        ImGui::NextColumn();
        ImGui::TextColored(ImVec4(1.0f, 0.7f, 0.7f, 1.0f), "[Modifiers]");
        PlotWithStats("Lateral G Boost", plot_oversteer, -20.0f, 20.0f);
        PlotWithStats("Understeer Cut", plot_understeer, -20.0f, 20.0f);
        PlotWithStats("Clipping", plot_clipping, 0.0f, 1.1f);
        ImGui::NextColumn();
        ImGui::TextColored(ImVec4(0.7f, 1.0f, 0.7f, 1.0f), "[Textures]");
        PlotWithStats("Road Texture", plot_road, -10.0f, 10.0f);
        PlotWithStats("Slide Texture", plot_slide, -10.0f, 10.0f);
        PlotWithStats("Lockup Vib", plot_lockup, -10.0f, 10.0f);
        PlotWithStats("Spin Vib", plot_spin, -10.0f, 10.0f);
        PlotWithStats("Bottoming", plot_bottoming, -10.0f, 10.0f);
        ImGui::Columns(1);
    }

    if (ImGui::CollapsingHeader("B. Internal Physics (Brain)", ImGuiTreeNodeFlags_None)) {
        ImGui::Columns(3, "PhysCols", false);
        ImGui::TextColored(ImVec4(1.0f, 1.0f, 0.0f, 1.0f), "[Loads]");
        ImGui::Text("Front: %.0f N | Rear: %.0f N", plot_calc_front_load.GetCurrent(), plot_calc_rear_load.GetCurrent());
        ImGui::PushStyleColor(ImGuiCol_PlotLines, ImVec4(0.0f, 1.0f, 1.0f, 1.0f));
        ImGui::PlotLines("##CLoadF", plot_calc_front_load.data.data(), (int)plot_calc_front_load.data.size(), plot_calc_front_load.offset, NULL, 0.0f, 10000.0f, ImVec2(0, 40));
        ImGui::PopStyleColor();
        ImVec2 pos_load = ImGui::GetItemRectMin();
        ImGui::SetCursorScreenPos(pos_load);
        ImGui::PushStyleColor(ImGuiCol_FrameBg, ImVec4(0,0,0,0));
        ImGui::PushStyleColor(ImGuiCol_PlotLines, ImVec4(1.0f, 0.0f, 1.0f, 1.0f));
        ImGui::PlotLines("##CLoadR", plot_calc_rear_load.data.data(), (int)plot_calc_rear_load.data.size(), plot_calc_rear_load.offset, NULL, 0.0f, 10000.0f, ImVec2(0, 40));
        ImGui::PopStyleColor(2);
        ImGui::NextColumn();
        ImGui::TextColored(ImVec4(1.0f, 1.0f, 0.0f, 1.0f), "[Grip/Slip]");
        PlotWithStats("Calc Front Grip", plot_calc_front_grip, 0.0f, 1.2f);
        PlotWithStats("Calc Rear Grip", plot_calc_rear_grip, 0.0f, 1.2f);
        PlotWithStats("Front Slip Ratio", plot_calc_slip_ratio, -1.0f, 1.0f);
        PlotWithStats("Front Slip Angle", plot_calc_slip_angle_smoothed, 0.0f, 1.0f);
        PlotWithStats("Rear Slip Angle", plot_calc_rear_slip_angle_smoothed, 0.0f, 1.0f);
        if (engine.m_slope_detection_enabled) PlotWithStats("Slope", plot_slope_current, -5.0f, 5.0f);
        ImGui::NextColumn();
        ImGui::TextColored(ImVec4(1.0f, 1.0f, 0.0f, 1.0f), "[Forces]");
        PlotWithStats("Calc Rear Lat Force", plot_calc_rear_lat_force, -5000.0f, 5000.0f);
        ImGui::Columns(1);
    }

    if (ImGui::CollapsingHeader("C. Raw Game Telemetry (Input)", ImGuiTreeNodeFlags_None)) {
        ImGui::Columns(4, "TelCols", false);
        ImGui::TextColored(ImVec4(0.0f, 1.0f, 1.0f, 1.0f), "[Driver Input]");
        PlotWithStats("Steering Torque", plot_raw_steer, -30.0f, 30.0f);
        PlotWithStats("Steering Input", plot_raw_input_steering, -1.0f, 1.0f);
        ImGui::Text("Combined Input");
        ImVec2 pos = ImGui::GetCursorScreenPos();
        ImGui::PushStyleColor(ImGuiCol_PlotLines, ImVec4(1.0f, 0.0f, 0.0f, 1.0f));
        ImGui::PlotLines("##BrkComb", plot_raw_brake.data.data(), (int)plot_raw_brake.data.size(), plot_raw_brake.offset, NULL, 0.0f, 1.0f, ImVec2(0, 40));
        ImGui::PopStyleColor();
        ImGui::SetCursorScreenPos(pos);
        ImGui::PushStyleColor(ImGuiCol_PlotLines, ImVec4(0.0f, 1.0f, 0.0f, 1.0f));
        ImGui::PushStyleColor(ImGuiCol_FrameBg, ImVec4(0.0f, 0.0f, 0.0f, 0.0f));
        ImGui::PlotLines("##ThrComb", plot_raw_throttle.data.data(), (int)plot_raw_throttle.data.size(), plot_raw_throttle.offset, NULL, 0.0f, 1.0f, ImVec2(0, 40));
        ImGui::PopStyleColor(2);
        ImGui::NextColumn();
        ImGui::TextColored(ImVec4(0.0f, 1.0f, 1.0f, 1.0f), "[Vehicle State]");
        PlotWithStats("Lat Accel", plot_input_accel, -20.0f, 20.0f);
        PlotWithStats("Speed (m/s)", plot_raw_car_speed, 0.0f, 100.0f);
        ImGui::NextColumn();
        ImGui::TextColored(ImVec4(0.0f, 1.0f, 1.0f, 1.0f), "[Raw Tire Data]");
        PlotWithStats("Raw Front Load", plot_raw_load, 0.0f, 10000.0f);
        PlotWithStats("Raw Front Grip", plot_raw_grip, 0.0f, 1.2f);
        PlotWithStats("Raw Rear Grip", plot_raw_rear_grip, 0.0f, 1.2f);
        ImGui::NextColumn();
        ImGui::TextColored(ImVec4(0.0f, 1.0f, 1.0f, 1.0f), "[Patch Velocities]");
        PlotWithStats("F-Lat PatchVel", plot_raw_front_lat_patch_vel, 0.0f, 20.0f);
        PlotWithStats("R-Lat PatchVel", plot_raw_rear_lat_patch_vel, 0.0f, 20.0f);
        PlotWithStats("F-Long PatchVel", plot_raw_front_long_patch_vel, -20.0f, 20.0f);
        PlotWithStats("R-Long PatchVel", plot_raw_rear_long_patch_vel, -20.0f, 20.0f);
        ImGui::Columns(1);
    }

    ImGui::End();
}
#endif

```

# File: src\GuiLayer_Linux.cpp
```cpp
#include "GuiLayer.h"
#include "GuiPlatform.h"
#include "Version.h"
#include "Config.h"
#include <iostream>
#include <vector>
#include <algorithm>
#include <mutex>
#include <chrono>

#if defined(ENABLE_IMGUI) && !defined(HEADLESS_GUI)
#include "imgui.h"
#include "imgui_impl_glfw.h"
#include "imgui_impl_opengl3.h"
#include <GLFW/glfw3.h>
#if defined(__APPLE__)
#include <OpenGL/gl.h>
#else
#include <GL/gl.h>
#endif

static GLFWwindow* g_window = nullptr;
#endif

extern std::atomic<bool> g_running;

class LinuxGuiPlatform : public IGuiPlatform {
public:
    void SetAlwaysOnTop(bool enabled) override {
#if defined(ENABLE_IMGUI) && !defined(HEADLESS_GUI)
        if (g_window) {
            glfwSetWindowAttrib(g_window, GLFW_FLOATING, enabled ? GLFW_TRUE : GLFW_FALSE);
        }
#else
        m_always_on_top_mock = enabled;
#endif
    }

    void ResizeWindow(int x, int y, int w, int h) override {
#if defined(ENABLE_IMGUI) && !defined(HEADLESS_GUI)
        if (g_window) {
            glfwSetWindowSize(g_window, w, h);
        }
#endif
    }

    void SaveWindowGeometry(bool is_graph_mode) override {
#if defined(ENABLE_IMGUI) && !defined(HEADLESS_GUI)
        if (g_window) {
            int x, y, w, h;
            glfwGetWindowPos(g_window, &x, &y);
            glfwGetWindowSize(g_window, &w, &h);
            Config::win_pos_x = x;
            Config::win_pos_y = y;
            if (is_graph_mode) {
                Config::win_w_large = w;
                Config::win_h_large = h;
            } else {
                Config::win_w_small = w;
                Config::win_h_small = h;
            }
        }
#endif
    }

    bool OpenPresetFileDialog(std::string& outPath) override {
        std::cout << "[GUI] File Dialog not implemented on Linux yet." << std::endl;
        return false;
    }

    bool SavePresetFileDialog(std::string& outPath, const std::string& defaultName) override {
        std::cout << "[GUI] File Dialog not implemented on Linux yet." << std::endl;
        return false;
    }

    void* GetWindowHandle() override {
#if defined(ENABLE_IMGUI) && !defined(HEADLESS_GUI)
        return (void*)g_window;
#else
        return nullptr;
#endif
    }

    bool GetAlwaysOnTopMock() override { return m_always_on_top_mock; }

    // Mock access for tests
    bool m_always_on_top_mock = false;
};

static LinuxGuiPlatform g_platform;
IGuiPlatform& GetGuiPlatform() { return g_platform; }

// Compatibility Helpers
void ResizeWindowPlatform(int x, int y, int w, int h) { GetGuiPlatform().ResizeWindow(x, y, w, h); }
void SaveCurrentWindowGeometryPlatform(bool is_graph_mode) { GetGuiPlatform().SaveWindowGeometry(is_graph_mode); }
void SetWindowAlwaysOnTopPlatform(bool enabled) { GetGuiPlatform().SetAlwaysOnTop(enabled); }
bool OpenPresetFileDialogPlatform(std::string& outPath) { return GetGuiPlatform().OpenPresetFileDialog(outPath); }
bool SavePresetFileDialogPlatform(std::string& outPath, const std::string& defaultName) { return GetGuiPlatform().SavePresetFileDialog(outPath, defaultName); }

#if defined(ENABLE_IMGUI) && !defined(HEADLESS_GUI)

static void glfw_error_callback(int error, const char* description) {
    fprintf(stderr, "Glfw Error %d: %s\n", error, description);
}

bool GuiLayer::Init() {
    glfwSetErrorCallback(glfw_error_callback);
    if (!glfwInit()) return false;

    // GL 3.0 + GLSL 130
    const char* glsl_version = "#version 130";
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 0);

    int start_w = Config::show_graphs ? Config::win_w_large : Config::win_w_small;
    int start_h = Config::show_graphs ? Config::win_h_large : Config::win_h_small;

    std::string title = "lmuFFB v" + std::string(LMUFFB_VERSION);
    g_window = glfwCreateWindow(start_w, start_h, title.c_str(), NULL, NULL);
    if (g_window == NULL) return false;

    glfwMakeContextCurrent(g_window);
    glfwSwapInterval(1); // Enable vsync

    if (Config::m_always_on_top) SetWindowAlwaysOnTopPlatform(true);

    IMGUI_CHECKVERSION();
    ImGui::CreateContext();
    ImGuiIO& io = ImGui::GetIO(); (void)io;
    io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;

    SetupGUIStyle();

    ImGui_ImplGlfw_InitForOpenGL(g_window, true);
    ImGui_ImplOpenGL3_Init(glsl_version);

    return true;
}

void GuiLayer::Shutdown(FFBEngine& engine) {
    SaveCurrentWindowGeometryPlatform(Config::show_graphs);
    Config::Save(engine);

    ImGui_ImplOpenGL3_Shutdown();
    ImGui_ImplGlfw_Shutdown();
    ImGui::DestroyContext();

    glfwDestroyWindow(g_window);
    glfwTerminate();
}

void* GuiLayer::GetWindowHandle() {
    return (void*)g_window;
}

bool GuiLayer::Render(FFBEngine& engine) {
    if (glfwWindowShouldClose(g_window)) {
        g_running = false;
        return false;
    }

    glfwPollEvents();

    ImGui_ImplOpenGL3_NewFrame();
    ImGui_ImplGlfw_NewFrame();
    ImGui::NewFrame();

    DrawTuningWindow(engine);
    if (Config::show_graphs) DrawDebugWindow(engine);

    ImGui::Render();
    int display_w, display_h;
    glfwGetFramebufferSize(g_window, &display_w, &display_h);
    glViewport(0, 0, display_w, display_h);
    glClearColor(0.45f, 0.55f, 0.60f, 1.00f);
    glClear(GL_COLOR_BUFFER_BIT);
    ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());

    glfwSwapBuffers(g_window);

    return true; // Always return true to keep the main loop running at full speed
}

#else
// Stub Implementation for Headless Builds (or if IMGUI disabled)
bool GuiLayer::Init() {
    std::cout << "[GUI] Disabled (Headless Mode)" << std::endl;
    return true;
}
void GuiLayer::Shutdown(FFBEngine& engine) {
    Config::Save(engine);
}
bool GuiLayer::Render(FFBEngine& engine) { return true; }
void* GuiLayer::GetWindowHandle() { return nullptr; }

#endif

```

# File: src\GuiLayer_Win32.cpp
```cpp
#include "GuiLayer.h"
#include "GuiPlatform.h"
#include "Version.h"
#include "Logger.h"
#include "Config.h"
#include <windows.h>
#include <commdlg.h>
#include <iostream>
#include <vector>
#include <algorithm>
#include <mutex>
#include <chrono>

#if defined(ENABLE_IMGUI) && !defined(HEADLESS_GUI)
#include "imgui.h"
#include "imgui_impl_win32.h"
#include "imgui_impl_dx11.h"
#include <d3d11.h>
#define DIRECTINPUT_VERSION 0x0800
#include <dinput.h>
#include <tchar.h>


// Global DirectX variables
static ID3D11Device*            g_pd3dDevice = NULL;
static ID3D11DeviceContext*     g_pd3dDeviceContext = NULL;
static IDXGISwapChain*          g_pSwapChain = NULL;
static ID3D11RenderTargetView*  g_mainRenderTargetView = NULL;
static HWND                     g_hwnd = NULL;

static const int MIN_WINDOW_WIDTH = 400;
static const int MIN_WINDOW_HEIGHT = 600;

#ifndef PW_RENDERFULLCONTENT
#define PW_RENDERFULLCONTENT 0x00000002
#endif

// Forward declarations
bool CreateDeviceD3D(HWND hWnd);
void CleanupDeviceD3D();
void CreateRenderTarget();
void CleanupRenderTarget();
LRESULT WINAPI WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

extern std::atomic<bool> g_running;

class Win32GuiPlatform : public IGuiPlatform {
public:
    void SetAlwaysOnTop(bool enabled) override {
        if (!g_hwnd) return;
        HWND insertAfter = enabled ? HWND_TOPMOST : HWND_NOTOPMOST;
        ::SetWindowPos(g_hwnd, insertAfter, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE | SWP_FRAMECHANGED);
    }

    void ResizeWindow(int x, int y, int w, int h) override {
        if (w < MIN_WINDOW_WIDTH) w = MIN_WINDOW_WIDTH;
        if (h < MIN_WINDOW_HEIGHT) h = MIN_WINDOW_HEIGHT;
        ::SetWindowPos(g_hwnd, NULL, x, y, w, h, SWP_NOZORDER | SWP_NOACTIVATE);
    }

    void SaveWindowGeometry(bool is_graph_mode) override {
        RECT rect;
        if (::GetWindowRect(g_hwnd, &rect)) {
            Config::win_pos_x = rect.left;
            Config::win_pos_y = rect.top;
            int w = rect.right - rect.left;
            int h = rect.bottom - rect.top;
            if (w < MIN_WINDOW_WIDTH) w = MIN_WINDOW_WIDTH;
            if (h < MIN_WINDOW_HEIGHT) h = MIN_WINDOW_HEIGHT;
            if (is_graph_mode) {
                Config::win_w_large = w;
                Config::win_h_large = h;
            } else {
                Config::win_w_small = w;
                Config::win_h_small = h;
            }
        }
    }

    bool OpenPresetFileDialog(std::string& outPath) override {
        char filename[MAX_PATH] = "";
        OPENFILENAMEA ofn;
        ZeroMemory(&ofn, sizeof(ofn));
        ofn.lStructSize = sizeof(ofn);
        ofn.hwndOwner = g_hwnd;
        ofn.lpstrFilter = "Preset Files (*.ini)\0*.ini\0All Files (*.*)\0*.*\0";
        ofn.lpstrFile = filename;
        ofn.nMaxFile = MAX_PATH;
        ofn.Flags = OFN_EXPLORER | OFN_FILEMUSTEXIST | OFN_HIDEREADONLY;
        ofn.lpstrDefExt = "ini";
        if (GetOpenFileNameA(&ofn)) {
            outPath = filename;
            return true;
        }
        return false;
    }

    bool SavePresetFileDialog(std::string& outPath, const std::string& defaultName) override {
        char filename[MAX_PATH] = "";
        strncpy_s(filename, defaultName.c_str(), _TRUNCATE);
        OPENFILENAMEA ofn;
        ZeroMemory(&ofn, sizeof(ofn));
        ofn.lStructSize = sizeof(ofn);
        ofn.hwndOwner = g_hwnd;
        ofn.lpstrFilter = "Preset Files (*.ini)\0*.ini\0All Files (*.*)\0*.*\0";
        ofn.lpstrFile = filename;
        ofn.nMaxFile = MAX_PATH;
        ofn.Flags = OFN_EXPLORER | OFN_PATHMUSTEXIST | OFN_OVERWRITEPROMPT | OFN_HIDEREADONLY;
        ofn.lpstrDefExt = "ini";
        if (GetSaveFileNameA(&ofn)) {
            outPath = filename;
            return true;
        }
        return false;
    }

    void* GetWindowHandle() override {
        return (void*)g_hwnd;
    }
};

static Win32GuiPlatform g_platform;
IGuiPlatform& GetGuiPlatform() { return g_platform; }

// Compatibility Helpers
void ResizeWindowPlatform(int x, int y, int w, int h) { GetGuiPlatform().ResizeWindow(x, y, w, h); }
void SaveCurrentWindowGeometryPlatform(bool is_graph_mode) { GetGuiPlatform().SaveWindowGeometry(is_graph_mode); }
void SetWindowAlwaysOnTopPlatform(bool enabled) { GetGuiPlatform().SetAlwaysOnTop(enabled); }
bool OpenPresetFileDialogPlatform(std::string& outPath) { return GetGuiPlatform().OpenPresetFileDialog(outPath); }
bool SavePresetFileDialogPlatform(std::string& outPath, const std::string& defaultName) { return GetGuiPlatform().SavePresetFileDialog(outPath, defaultName); }


bool GuiLayer::Init() {
    WNDCLASSEXW wc = { sizeof(wc), CS_CLASSDC, WndProc, 0L, 0L, GetModuleHandle(NULL), NULL, NULL, NULL, NULL, L"lmuFFB", NULL };
    ::RegisterClassExW(&wc);
    std::string ver = LMUFFB_VERSION;
    std::wstring wver(ver.begin(), ver.end());
    std::wstring title = L"lmuFFB v" + wver;
    int start_w = Config::show_graphs ? Config::win_w_large : Config::win_w_small;
    int start_h = Config::show_graphs ? Config::win_h_large : Config::win_h_small;
    if (start_w < MIN_WINDOW_WIDTH) start_w = MIN_WINDOW_WIDTH;
    if (start_h < MIN_WINDOW_HEIGHT) start_h = MIN_WINDOW_HEIGHT;
    int pos_x = Config::win_pos_x, pos_y = Config::win_pos_y;
    RECT workArea; SystemParametersInfo(SPI_GETWORKAREA, 0, &workArea, 0);
    if (pos_x < workArea.left - 100 || pos_x > workArea.right - 100 || pos_y < workArea.top - 100 || pos_y > workArea.bottom - 100) {
        pos_x = 100; pos_y = 100;
    }
    g_hwnd = ::CreateWindowW(wc.lpszClassName, title.c_str(), WS_OVERLAPPEDWINDOW, pos_x, pos_y, start_w, start_h, NULL, NULL, wc.hInstance, NULL);
    if (!g_hwnd) {
        Logger::Get().LogWin32Error("CreateWindowW", GetLastError());
        return false;
    }
    Logger::Get().Log("Window Created: %p", g_hwnd);

    if (!CreateDeviceD3D(g_hwnd)) {
        CleanupDeviceD3D(); ::UnregisterClassW(wc.lpszClassName, wc.hInstance);
        Logger::Get().Log("Failed to create D3D Device.");
        return false;
    }
    ::ShowWindow(g_hwnd, SW_SHOWDEFAULT); ::UpdateWindow(g_hwnd);
    if (Config::m_always_on_top) SetWindowAlwaysOnTopPlatform(true);
    IMGUI_CHECKVERSION(); ImGui::CreateContext();
    ImGuiIO& io = ImGui::GetIO(); (void)io;
    io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;
    SetupGUIStyle();
    ImGui_ImplWin32_Init(g_hwnd);
    ImGui_ImplDX11_Init(g_pd3dDevice, g_pd3dDeviceContext);
    return true;
}

void GuiLayer::Shutdown(FFBEngine& engine) {
    SaveCurrentWindowGeometryPlatform(Config::show_graphs);
    Config::Save(engine);
    ImGui_ImplDX11_Shutdown();
    ImGui_ImplWin32_Shutdown();
    ImGui::DestroyContext();
    CleanupDeviceD3D();
    ::DestroyWindow(g_hwnd);
    ::UnregisterClassW(L"lmuFFB", GetModuleHandle(NULL));
}

void* GuiLayer::GetWindowHandle() {
    return (void*)g_hwnd;
}

bool GuiLayer::Render(FFBEngine& engine) {
    if (!g_pd3dDeviceContext) return true; // Safety for uninitialized state (e.g. unit tests)

    MSG msg;
    while (::PeekMessage(&msg, NULL, 0U, 0U, PM_REMOVE)) {
        ::TranslateMessage(&msg); ::DispatchMessage(&msg);
        if (msg.message == WM_QUIT) { g_running = false; return false; }
    }
    if (g_running == false) return false;
    ImGui_ImplDX11_NewFrame();
    ImGui_ImplWin32_NewFrame();
    ImGui::NewFrame();
    DrawTuningWindow(engine);
    if (Config::show_graphs) DrawDebugWindow(engine);
    ImGui::Render();
    const float clear_color_with_alpha[4] = { 0.45f, 0.55f, 0.60f, 1.00f };
    g_pd3dDeviceContext->OMSetRenderTargets(1, &g_mainRenderTargetView, NULL);
    g_pd3dDeviceContext->ClearRenderTargetView(g_mainRenderTargetView, clear_color_with_alpha);
    ImGui_ImplDX11_RenderDrawData(ImGui::GetDrawData());
    g_pSwapChain->Present(1, 0);
    return true; // Always return true to keep the main loop running at full speed
}

extern IMGUI_IMPL_API LRESULT ImGui_ImplWin32_WndProcHandler(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
LRESULT WINAPI WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) {
    if (ImGui_ImplWin32_WndProcHandler(hWnd, msg, wParam, lParam)) return true;
    switch (msg) {
    case WM_SIZE:
        if (g_pd3dDevice != NULL && wParam != SIZE_MINIMIZED) {
            Logger::Get().Log("ResizeBuffers: %d x %d", LOWORD(lParam), HIWORD(lParam));
            CleanupRenderTarget();
            g_pSwapChain->ResizeBuffers(0, (UINT)LOWORD(lParam), (UINT)HIWORD(lParam), DXGI_FORMAT_UNKNOWN, 0);
            CreateRenderTarget();
        }
        return 0;
    case WM_SYSCOMMAND:
        if ((wParam & 0xfff0) == SC_KEYMENU) return 0;
        break;
    case WM_DESTROY: ::PostQuitMessage(0); return 0;
    }
    return ::DefWindowProc(hWnd, msg, wParam, lParam);
}

bool CreateDeviceD3D(HWND hWnd) {
    DXGI_SWAP_CHAIN_DESC sd;
    ZeroMemory(&sd, sizeof(sd));
    sd.BufferCount = 2; sd.BufferDesc.Width = 0; sd.BufferDesc.Height = 0;
    sd.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM; sd.BufferDesc.RefreshRate.Numerator = 60; sd.BufferDesc.RefreshRate.Denominator = 1;
    sd.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH; sd.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
    sd.OutputWindow = hWnd; sd.SampleDesc.Count = 1; sd.SampleDesc.Quality = 0; sd.Windowed = TRUE; sd.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;
    D3D_FEATURE_LEVEL featureLevel; const D3D_FEATURE_LEVEL featureLevelArray[2] = { D3D_FEATURE_LEVEL_11_0, D3D_FEATURE_LEVEL_10_0, };
    HRESULT hr = D3D11CreateDeviceAndSwapChain(NULL, D3D_DRIVER_TYPE_HARDWARE, NULL, 0, featureLevelArray, 2, D3D11_SDK_VERSION, &sd, &g_pSwapChain, &g_pd3dDevice, &featureLevel, &g_pd3dDeviceContext);
    if (hr != S_OK) {
        Logger::Get().LogWin32Error("D3D11CreateDeviceAndSwapChain", hr);
        return false;
    }
    Logger::Get().Log("D3D11 Device Created. Feature Level: 0x%X", featureLevel);
    CreateRenderTarget(); return true;
}

void CleanupDeviceD3D() {
    CleanupRenderTarget();
    if (g_pSwapChain) { g_pSwapChain->Release(); g_pSwapChain = NULL; }
    if (g_pd3dDeviceContext) { g_pd3dDeviceContext->Release(); g_pd3dDeviceContext = NULL; }
    if (g_pd3dDevice) { g_pd3dDevice->Release(); g_pd3dDevice = NULL; }
}

void CreateRenderTarget() {
    ID3D11Texture2D* pBackBuffer; g_pSwapChain->GetBuffer(0, IID_PPV_ARGS(&pBackBuffer));
    g_pd3dDevice->CreateRenderTargetView(pBackBuffer, NULL, &g_mainRenderTargetView); pBackBuffer->Release();
}

void CleanupRenderTarget() {
    if (g_mainRenderTargetView) { g_mainRenderTargetView->Release(); g_mainRenderTargetView = NULL; }
}

#else
// Stub Implementation for Headless Builds
class Win32GuiPlatform : public IGuiPlatform {
public:
    void SetAlwaysOnTop(bool enabled) override { m_always_on_top_mock = enabled; }
    void ResizeWindow(int x, int y, int w, int h) override {}
    void SaveWindowGeometry(bool is_graph_mode) override {}
    bool OpenPresetFileDialog(std::string& outPath) override { return false; }
    bool SavePresetFileDialog(std::string& outPath, const std::string& defaultName) override { return false; }
    void* GetWindowHandle() override { return nullptr; }
    bool GetAlwaysOnTopMock() override { return m_always_on_top_mock; }
    bool m_always_on_top_mock = false;
};
static Win32GuiPlatform g_platform;
IGuiPlatform& GetGuiPlatform() { return g_platform; }

bool GuiLayer::Init() {
    return true;
}
void GuiLayer::Shutdown(FFBEngine& engine) {
    Config::Save(engine);
}
bool GuiLayer::Render(FFBEngine& engine) { return true; }
void* GuiLayer::GetWindowHandle() { return nullptr; }

void ResizeWindowPlatform(int x, int y, int w, int h) { GetGuiPlatform().ResizeWindow(x, y, w, h); }
void SaveCurrentWindowGeometryPlatform(bool is_graph_mode) { GetGuiPlatform().SaveWindowGeometry(is_graph_mode); }
void SetWindowAlwaysOnTopPlatform(bool enabled) { GetGuiPlatform().SetAlwaysOnTop(enabled); }
bool OpenPresetFileDialogPlatform(std::string& outPath) { return GetGuiPlatform().OpenPresetFileDialog(outPath); }
bool SavePresetFileDialogPlatform(std::string& outPath, const std::string& defaultName) { return GetGuiPlatform().SavePresetFileDialog(outPath, defaultName); }

#endif

```

# File: src\GuiPlatform.h
```cpp
#pragma once
#include <string>

class IGuiPlatform {
public:
    virtual ~IGuiPlatform() = default;
    virtual void SetAlwaysOnTop(bool enabled) = 0;
    virtual void ResizeWindow(int x, int y, int w, int h) = 0;
    virtual void SaveWindowGeometry(bool is_graph_mode) = 0;
    virtual bool OpenPresetFileDialog(std::string& outPath) = 0;
    virtual bool SavePresetFileDialog(std::string& outPath, const std::string& defaultName) = 0;
    virtual void* GetWindowHandle() = 0;

    // Test support
    virtual bool GetAlwaysOnTopMock() { return false; }
};

// Singleton access
IGuiPlatform& GetGuiPlatform();

// Global helper for simple access (compatibility)
void SetWindowAlwaysOnTopPlatform(bool enabled);

```

# File: src\GuiWidgets.h
```cpp
#ifndef GUIWIDGETS_H
#define GUIWIDGETS_H

#ifdef ENABLE_IMGUI
#include "imgui.h"
#include <string>
#include <algorithm>
#include <functional>

namespace GuiWidgets {

    /**
     * Represents the result of a widget interaction.
     * Use this to trigger higher-level logic like auto-save or preset dirtying.
     */
    struct Result {
        bool changed = false;     // True if value was modified this frame
        bool deactivated = false; // True if interaction finished (mouse release, enter key, or discrete change)
    };

    /**
     * A standardized float slider with label, adaptive arrow-key support, and decorators.
     */
    inline Result Float(const char* label, float* v, float min, float max, const char* fmt = "%.2f", const char* tooltip = nullptr, std::function<void()> decorator = nullptr) {
        Result res;
        ImGui::Text("%s", label);
        bool labelHovered = ImGui::IsItemHovered();
        ImGui::NextColumn();

        // Render decorator (e.g., latency indicator) above the slider
        if (decorator) {
            decorator();
        }

        ImGui::SetNextItemWidth(-1);
        std::string id = "##" + std::string(label);

        // Core Slider
        if (ImGui::SliderFloat(id.c_str(), v, min, max, fmt)) {
            res.changed = true;
        }

        // Detect mouse release or Enter key after a series of edits
        if (ImGui::IsItemDeactivatedAfterEdit()) {
            res.deactivated = true;
        }

        // Unified Interaction Logic (Arrow Keys & Tooltips)
        if (ImGui::IsItemHovered() || labelHovered) {
            float range = max - min;
            // Adaptive step size: finer steps for smaller ranges
            float step = (range > 50.0f) ? 0.5f : (range < 1.0f) ? 0.001f : 0.01f; 
            
            bool keyChanged = false;
            // Note: We use IsKeyPressed which supports repeats
            if (ImGui::IsKeyPressed(ImGuiKey_LeftArrow)) { *v -= step; keyChanged = true; }
            if (ImGui::IsKeyPressed(ImGuiKey_RightArrow)) { *v += step; keyChanged = true; }

            if (keyChanged) {
                *v = (std::max)(min, (std::min)(max, *v));
                res.changed = true;
                res.deactivated = true; // Arrow keys are discrete adjustments, save immediately
            }

            // Show tooltip only if not actively interacting
            if (!keyChanged && !ImGui::IsItemActive()) {
                ImGui::BeginTooltip();
                if (tooltip && strlen(tooltip) > 0) {
                    ImGui::Text("%s", tooltip);
                    ImGui::Separator();
                }
                ImGui::Text("Fine Tune: Arrow Keys | Exact: Ctrl+Click");
                ImGui::EndTooltip();
            }
        }

        ImGui::NextColumn();
        return res;
    }

    /**
     * A standardized checkbox with label and tooltip.
     */
    inline Result Checkbox(const char* label, bool* v, const char* tooltip = nullptr) {
        Result res;
        ImGui::Text("%s", label);
        bool labelHovered = ImGui::IsItemHovered();
        ImGui::NextColumn();
        std::string id = "##" + std::string(label);
        
        if (ImGui::Checkbox(id.c_str(), v)) {
            res.changed = true;
            res.deactivated = true; // Checkboxes are immediate
        }

        if (tooltip && (ImGui::IsItemHovered() || labelHovered)) {
            ImGui::SetTooltip("%s", tooltip);
        }

        ImGui::NextColumn();
        return res;
    }

    /**
     * A standardized combo box with label and tooltip.
     */
    inline Result Combo(const char* label, int* v, const char* const items[], int items_count, const char* tooltip = nullptr) {
        Result res;
        ImGui::Text("%s", label);
        bool labelHovered = ImGui::IsItemHovered();
        ImGui::NextColumn();
        ImGui::SetNextItemWidth(-1);
        std::string id = "##" + std::string(label);

        if (ImGui::Combo(id.c_str(), v, items, items_count)) {
            res.changed = true;
            res.deactivated = true; // Selection changes are immediate
        }

        if (tooltip && (ImGui::IsItemHovered() || labelHovered)) {
            ImGui::SetTooltip("%s", tooltip);
        }

        ImGui::NextColumn();
        return res;
    }
}

#endif // ENABLE_IMGUI

#endif // GUIWIDGETS_H

```

# File: src\Logger.h
```cpp
#ifndef LOGGER_H
#define LOGGER_H

#include <string>
#include <fstream>
#include <mutex>
#include <memory>
#include <iostream>
#include <sstream>
#include <iomanip>
#include <chrono>
#include <cstdarg>

// Simple synchronous logger that flushes every line for crash debugging
class Logger {
public:
    static Logger& Get() {
        static Logger instance;
        return instance;
    }

    void Init(const std::string& filename) {
        std::lock_guard<std::mutex> lock(m_mutex);
        m_filename = filename;
        m_file.open(m_filename, std::ios::out | std::ios::trunc);
        if (m_file.is_open()) {
            m_initialized = true;
            _LogNoLock("Logger Initialized. Version: " + std::string(LMUFFB_VERSION));
        }
    }

    void Log(const char* fmt, ...) {
        if (!m_initialized) return;

        char buffer[1024];
        va_list args;
        va_start(args, fmt);
        vsnprintf(buffer, sizeof(buffer), fmt, args);
        va_end(args);

        std::string message(buffer);

        std::lock_guard<std::mutex> lock(m_mutex);
        _LogNoLock(message);
    }

    // Helper for std::string
    void LogStr(const std::string& msg) {
        Log("%s", msg.c_str());
    }

    // Helper for error logging with GetLastError()
    void LogWin32Error(const char* context, unsigned long errorCode) {
        Log("Error in %s: Code %lu", context, errorCode);
    }

private:
    Logger() {}
    ~Logger() {
        if (m_file.is_open()) {
            m_file << "Logger Shutdown.\n";
            m_file.close();
        }
    }

    void _LogNoLock(const std::string& message) {
        if (!m_file.is_open()) return;

        // Timestamp
        auto now = std::chrono::system_clock::now();
        auto in_time_t = std::chrono::system_clock::to_time_t(now);
        std::tm time_info;
        #ifdef _WIN32
            localtime_s(&time_info, &in_time_t);
        #else
            localtime_r(&in_time_t, &time_info);
        #endif

        m_file << "[" << std::put_time(&time_info, "%H:%M:%S") << "] " << message << "\n";
        m_file.flush(); // Critical for crash debugging

        // Also print to console for consistency
        std::cout << "[Log] " << message << std::endl;
    }

    std::string m_filename;
    std::ofstream m_file;
    std::mutex m_mutex;
    bool m_initialized = false;
};

#endif // LOGGER_H

```

# File: src\main.cpp
```cpp
#ifdef _WIN32
#include <windows.h>
#endif
#include <iostream>
#include <cmath>
#include <algorithm>
#include <thread>
#include <chrono>

#include "FFBEngine.h"
#include "GuiLayer.h"
#include "Config.h"
#include "DirectInputFFB.h"
#include "GameConnector.h"
#include "Version.h"
#include "Logger.h"    // Added Logger
#include "RateMonitor.h"
#include <optional>
#include <atomic>
#include <mutex>

// Constants

// Threading Globals
std::atomic<bool> g_running(true);
std::atomic<bool> g_ffb_active(true);

SharedMemoryObjectOut g_localData; // Local copy of shared memory

FFBEngine g_engine;
std::mutex g_engine_mutex; // Protects settings access if GUI changes them

// --- FFB Loop (High Priority 400Hz) ---
void FFBThread() {
    std::cout << "[FFB] Loop Started." << std::endl;
    RateMonitor loopMonitor;
    RateMonitor telemMonitor;
    RateMonitor hwMonitor;
    RateMonitor torqueMonitor;
    RateMonitor genTorqueMonitor;
    double lastET = -1.0;
    double lastTorque = -9999.0;
    float lastGenTorque = -9999.0f;

    // Extended monitors for Issue #133
    struct ChannelMonitor {
        RateMonitor monitor;
        double lastValue = -1e18;
        void Update(double newValue) {
            if (newValue != lastValue) {
                monitor.RecordEvent();
                lastValue = newValue;
            }
        }
    };

    ChannelMonitor mAccX, mAccY, mAccZ;
    ChannelMonitor mVelX, mVelY, mVelZ;
    ChannelMonitor mRotX, mRotY, mRotZ;
    ChannelMonitor mRotAccX, mRotAccY, mRotAccZ;
    ChannelMonitor mUnfSteer, mFilSteer;
    ChannelMonitor mRPM;
    ChannelMonitor mLoadFL, mLoadFR, mLoadRL, mLoadRR;
    ChannelMonitor mLatFL, mLatFR, mLatRL, mLatRR;
    ChannelMonitor mPosX, mPosY, mPosZ;
    ChannelMonitor mDtMon;

    // Precise Timing: Target 400Hz (2500 microseconds)
    const std::chrono::microseconds target_period(2500);
    auto next_tick = std::chrono::steady_clock::now();

    while (g_running) {
        loopMonitor.RecordEvent();
        next_tick += target_period;

        double force = 0.0;
        double dt = 0.0025; // Default 400Hz
        bool restricted = true;

        if (g_ffb_active && GameConnector::Get().IsConnected()) {
            bool in_realtime = GameConnector::Get().CopyTelemetry(g_localData);
            bool is_stale = GameConnector::Get().IsStale(100);

            static bool was_in_menu = true;
            if (was_in_menu && in_realtime) {
                std::cout << "[Game] User entered driving session." << std::endl;
                if (Config::m_auto_start_logging && !AsyncLogger::Get().IsLogging()) {
                    SessionInfo info;
                    info.app_version = LMUFFB_VERSION;
                    std::lock_guard<std::mutex> lock(g_engine_mutex);
                    info.vehicle_name = g_engine.m_vehicle_name;
                    info.track_name = g_engine.m_track_name;
                    info.driver_name = "Auto";
                    info.gain = g_engine.m_gain;
                    info.understeer_effect = g_engine.m_understeer_effect;
                    info.sop_effect = g_engine.m_sop_effect;
                    info.slope_enabled = g_engine.m_slope_detection_enabled;
                    info.slope_sensitivity = g_engine.m_slope_sensitivity;
                    info.slope_threshold = (float)g_engine.m_slope_min_threshold;
                    info.slope_alpha_threshold = g_engine.m_slope_alpha_threshold;
                    info.slope_decay_rate = g_engine.m_slope_decay_rate;
                    AsyncLogger::Get().Start(info, Config::m_log_path);
                }
            } else if (!was_in_menu && !in_realtime) {
                std::cout << "[Game] User exited to menu (FFB Muted)." << std::endl;
                if (Config::m_auto_start_logging && AsyncLogger::Get().IsLogging()) {
                    AsyncLogger::Get().Stop();
                }
            }
            was_in_menu = !in_realtime;
            
            bool should_output = false;

            if (in_realtime && !is_stale && g_localData.telemetry.playerHasVehicle) {
                uint8_t idx = g_localData.telemetry.playerVehicleIdx;
                if (idx < 104) {
                    auto& scoring = g_localData.scoring.vehScoringInfo[idx];
                    TelemInfoV01* pPlayerTelemetry = &g_localData.telemetry.telemInfo[idx];
                    dt = pPlayerTelemetry->mDeltaTime;

                    // Track telemetry update rate
                    if (pPlayerTelemetry->mElapsedTime != lastET) {
                        telemMonitor.RecordEvent();
                        lastET = pPlayerTelemetry->mElapsedTime;
                    }

                    // Track torque update rates
                    if (pPlayerTelemetry->mSteeringShaftTorque != lastTorque) {
                        torqueMonitor.RecordEvent();
                        lastTorque = pPlayerTelemetry->mSteeringShaftTorque;
                    }
                    if (g_localData.generic.FFBTorque != lastGenTorque) {
                        genTorqueMonitor.RecordEvent();
                        lastGenTorque = g_localData.generic.FFBTorque;
                    }

                    // Extended monitoring (Issue #133)
                    mAccX.Update(pPlayerTelemetry->mLocalAccel.x);
                    mAccY.Update(pPlayerTelemetry->mLocalAccel.y);
                    mAccZ.Update(pPlayerTelemetry->mLocalAccel.z);
                    mVelX.Update(pPlayerTelemetry->mLocalVel.x);
                    mVelY.Update(pPlayerTelemetry->mLocalVel.y);
                    mVelZ.Update(pPlayerTelemetry->mLocalVel.z);
                    mRotX.Update(pPlayerTelemetry->mLocalRot.x);
                    mRotY.Update(pPlayerTelemetry->mLocalRot.y);
                    mRotZ.Update(pPlayerTelemetry->mLocalRot.z);
                    mRotAccX.Update(pPlayerTelemetry->mLocalRotAccel.x);
                    mRotAccY.Update(pPlayerTelemetry->mLocalRotAccel.y);
                    mRotAccZ.Update(pPlayerTelemetry->mLocalRotAccel.z);
                    mUnfSteer.Update(pPlayerTelemetry->mUnfilteredSteering);
                    mFilSteer.Update(pPlayerTelemetry->mFilteredSteering);
                    mRPM.Update(pPlayerTelemetry->mEngineRPM);
                    mLoadFL.Update(pPlayerTelemetry->mWheel[0].mTireLoad);
                    mLoadFR.Update(pPlayerTelemetry->mWheel[1].mTireLoad);
                    mLoadRL.Update(pPlayerTelemetry->mWheel[2].mTireLoad);
                    mLoadRR.Update(pPlayerTelemetry->mWheel[3].mTireLoad);
                    mLatFL.Update(pPlayerTelemetry->mWheel[0].mLateralForce);
                    mLatFR.Update(pPlayerTelemetry->mWheel[1].mLateralForce);
                    mLatRL.Update(pPlayerTelemetry->mWheel[2].mLateralForce);
                    mLatRR.Update(pPlayerTelemetry->mWheel[3].mLateralForce);
                    mPosX.Update(pPlayerTelemetry->mPos.x);
                    mPosY.Update(pPlayerTelemetry->mPos.y);
                    mPosZ.Update(pPlayerTelemetry->mPos.z);
                    mDtMon.Update(pPlayerTelemetry->mDeltaTime);

                    std::lock_guard<std::mutex> lock(g_engine_mutex);
                    if (g_engine.IsFFBAllowed(scoring, g_localData.scoring.scoringInfo.mGamePhase)) {
                        force = g_engine.calculate_force(pPlayerTelemetry, scoring.mVehicleClass, scoring.mVehicleName, g_localData.generic.FFBTorque);
                        should_output = true;
                        restricted = (scoring.mFinishStatus != 0);
                    }
                }
            }
            
            if (!should_output) force = 0.0;

            // Warning for low sample rate (Issue #129)
            static auto lastWarningTime = std::chrono::steady_clock::now();
            if (in_realtime && (telemMonitor.GetRate() < 380.0 || torqueMonitor.GetRate() < 380.0) && telemMonitor.GetRate() > 1.0) {
                 auto now = std::chrono::steady_clock::now();
                 if (std::chrono::duration_cast<std::chrono::seconds>(now - lastWarningTime).count() >= 5) {
                     std::cout << "[WARNING] Low Sample Rate detected: Telemetry=" << telemMonitor.GetRate() << "Hz, Torque=" << torqueMonitor.GetRate() << "Hz (Target: 400 Hz)" << std::endl;
                     Logger::Get().Log("Low Sample Rate detected: Telemetry=%.1fHz, Torque=%.1fHz", telemMonitor.GetRate(), torqueMonitor.GetRate());
                     lastWarningTime = now;
                 }
            }
        }

        // Safety Layer (v0.7.49): Slew Rate Limiting and NaN protection
        // v0.7.48: Always update hardware even if disconnected/inactive to ensure zeroing
        {
            std::lock_guard<std::mutex> lock(g_engine_mutex);
            if (dt < 0.0001) dt = 0.0025;

            // Push rates to engine for GUI/Snapshot
            g_engine.m_ffb_rate = loopMonitor.GetRate();
            g_engine.m_telemetry_rate = telemMonitor.GetRate();
            g_engine.m_hw_rate = hwMonitor.GetRate();
            g_engine.m_torque_rate = torqueMonitor.GetRate();
            g_engine.m_gen_torque_rate = genTorqueMonitor.GetRate();

            force = g_engine.ApplySafetySlew(force, dt, restricted);
        }

        if (DirectInputFFB::Get().UpdateForce(force)) {
            hwMonitor.RecordEvent();
        }

        // Extended Logging (Issue #133)
        static auto lastExtLogTime = std::chrono::steady_clock::now();
        auto now = std::chrono::steady_clock::now();
        if (std::chrono::duration_cast<std::chrono::seconds>(now - lastExtLogTime).count() >= 5) {
            lastExtLogTime = now;
            if (GameConnector::Get().IsConnected() && g_localData.telemetry.playerHasVehicle) {
                Logger::Get().Log("--- Telemetry Sample Rates (Hz) ---");
                Logger::Get().Log("Loop: %.1f, ET: %.1f, HW: %.1f", loopMonitor.GetRate(), telemMonitor.GetRate(), hwMonitor.GetRate());
                Logger::Get().Log("Torque: Shaft=%.1f, Generic=%.1f", torqueMonitor.GetRate(), genTorqueMonitor.GetRate());
                Logger::Get().Log("Accel: X=%.1f, Y=%.1f, Z=%.1f", mAccX.monitor.GetRate(), mAccY.monitor.GetRate(), mAccZ.monitor.GetRate());
                Logger::Get().Log("Vel: X=%.1f, Y=%.1f, Z=%.1f", mVelX.monitor.GetRate(), mVelY.monitor.GetRate(), mVelZ.monitor.GetRate());
                Logger::Get().Log("Rot: X=%.1f, Y=%.1f, Z=%.1f", mRotX.monitor.GetRate(), mRotY.monitor.GetRate(), mRotZ.monitor.GetRate());
                Logger::Get().Log("RotAcc: X=%.1f, Y=%.1f, Z=%.1f", mRotAccX.monitor.GetRate(), mRotAccY.monitor.GetRate(), mRotAccZ.monitor.GetRate());
                Logger::Get().Log("Steering: Unf=%.1f, Fil=%.1f, RPM=%.1f", mUnfSteer.monitor.GetRate(), mFilSteer.monitor.GetRate(), mRPM.monitor.GetRate());
                Logger::Get().Log("Load: FL=%.1f, FR=%.1f, RL=%.1f, RR=%.1f", mLoadFL.monitor.GetRate(), mLoadFR.monitor.GetRate(), mLoadRL.monitor.GetRate(), mLoadRR.monitor.GetRate());
                Logger::Get().Log("LatForce: FL=%.1f, FR=%.1f, RL=%.1f, RR=%.1f", mLatFL.monitor.GetRate(), mLatFR.monitor.GetRate(), mLatRL.monitor.GetRate(), mLatRR.monitor.GetRate());
                Logger::Get().Log("Pos: X=%.1f, Y=%.1f, Z=%.1f, DeltaTime=%.1f", mPosX.monitor.GetRate(), mPosY.monitor.GetRate(), mPosZ.monitor.GetRate(), mDtMon.monitor.GetRate());
                Logger::Get().Log("-----------------------------------");
            }
        }

        // Precise Timing: Sleep until next tick
        std::this_thread::sleep_until(next_tick);
    }

    std::cout << "[FFB] Loop Stopped." << std::endl;
}

int main(int argc, char* argv[]) {
#ifdef _WIN32
    timeBeginPeriod(1);
#endif

    bool headless = false;
    for (int i = 1; i < argc; ++i) {
        if (std::string(argv[i]) == "--headless") headless = true;
    }

    std::cout << "Starting lmuFFB (C++ Port)..." << std::endl;
    // Initialize persistent debug logging for crash analysis
    Logger::Get().Init("lmuffb_debug.log");
    Logger::Get().Log("Application Started. Version: %s", LMUFFB_VERSION);
    if (headless) Logger::Get().Log("Mode: HEADLESS");
    else Logger::Get().Log("Mode: GUI");

    Preset::ApplyDefaultsToEngine(g_engine);
    Config::Load(g_engine);

    if (!headless) {
        if (!GuiLayer::Init()) {
            std::cerr << "Failed to initialize GUI." << std::endl;
        }
        DirectInputFFB::Get().Initialize((HWND)GuiLayer::GetWindowHandle());
    } else {
        std::cout << "Running in HEADLESS mode." << std::endl;
        DirectInputFFB::Get().Initialize(NULL);
    }

    if (GameConnector::Get().CheckLegacyConflict()) {
        std::cout << "[Info] Legacy rF2 plugin detected (not a problem for LMU 1.2+)" << std::endl;
    }

    if (!GameConnector::Get().TryConnect()) {
        std::cout << "Game not running or Shared Memory not ready. Waiting..." << std::endl;
    }

    std::thread ffb_thread(FFBThread);
    std::cout << "[GUI] Main Loop Started." << std::endl;

    while (g_running) {
        GuiLayer::Render(g_engine);
        // Maintain a consistent 60Hz message loop even when backgrounded
        // to ensure DirectInput performance and reliability.
        std::this_thread::sleep_for(std::chrono::milliseconds(16));
    }
    
    Config::Save(g_engine);
    if (!headless) {
        Logger::Get().Log("Shutting down GUI...");
        GuiLayer::Shutdown(g_engine);
    }
    if (ffb_thread.joinable()) {
        Logger::Get().Log("Stopping FFB Thread...");
        g_running = false; // Ensure loop breaks
        ffb_thread.join();
        Logger::Get().Log("FFB Thread Stopped.");
    }
    DirectInputFFB::Get().Shutdown();
    Logger::Get().Log("Main Loop Ended. Clean Exit.");
    
    return 0;
}

```

# File: src\MathUtils.h
```cpp
#ifndef MATH_UTILS_H
#define MATH_UTILS_H

#include <cmath>
#include <algorithm>
#include <array>

namespace ffb_math {

// Mathematical Constants
static constexpr double PI = 3.14159265358979323846;
static constexpr double TWO_PI = 2.0 * PI;

/**
 * @brief Bi-quad Filter (Direct Form II)
 * 
 * Used for filtering oscillations (e.g., steering wheel "death wobbles") 
 * and smoothing out high-frequency road noise.
 */
struct BiquadNotch {
    
    // Coefficients
    double b0 = 0.0, b1 = 0.0, b2 = 0.0, a1 = 0.0, a2 = 0.0;
    // State history (Inputs x, Outputs y)
    double x1 = 0.0, x2 = 0.0;
    double y1 = 0.0, y2 = 0.0;

    // Update coefficients based on dynamic frequency
    void Update(double center_freq, double sample_rate, double Q) {
        // Safety: Clamp frequency to Nyquist (sample_rate / 2) and min 1Hz
        center_freq = (std::max)(1.0, (std::min)(center_freq, sample_rate * 0.49));
        
        double omega = 2.0 * PI * center_freq / sample_rate;
        double sn = std::sin(omega);
        double cs = std::cos(omega);
        double alpha = sn / (2.0 * Q);

        double a0 = 1.0 + alpha;
        
        // Calculate and Normalize
        b0 = 1.0 / a0;
        b1 = (-2.0 * cs) / a0;
        b2 = 1.0 / a0;
        a1 = (-2.0 * cs) / a0;
        a2 = (1.0 - alpha) / a0;
    }

    // Apply filter to single sample
    double Process(double in) {
        double out = b0 * in + b1 * x1 + b2 * x2 - a1 * y1 - a2 * y2;
        
        // Shift history
        x2 = x1; x1 = in;
        y2 = y1; y1 = out;
        
        return out;
    }
    
    void Reset() {
        x1 = x2 = y1 = y2 = 0.0;
    }
};

// Helper: Inverse linear interpolation
// Returns normalized position of value between min and max
// Returns 0 if value >= min, 1 if value <= max (for negative threshold use)
// Clamped to [0, 1] range
inline double inverse_lerp(double min_val, double max_val, double value) {
    double range = max_val - min_val;
    if (std::abs(range) >= 0.0001) {
        double t = (value - min_val) / (std::abs(range) >= 0.0001 ? range : 1.0);
        return (std::max)(0.0, (std::min)(1.0, t));
    }
    
    // Degenerate case when range is zero or near-zero
    if (max_val >= min_val) return (value >= min_val) ? 1.0 : 0.0;
    return (value <= min_val) ? 1.0 : 0.0;
}

// Helper: Smoothstep interpolation
// Returns smooth S-curve interpolation from 0 to 1
// Uses Hermite polynomial: t² × (3 - 2t)
// Zero derivative at both endpoints for seamless transitions
inline double smoothstep(double edge0, double edge1, double x) {
    double range = edge1 - edge0;
    if (std::abs(range) >= 0.0001) {
        double t = (x - edge0) / (std::abs(range) >= 0.0001 ? range : 1.0);
        t = (std::max)(0.0, (std::min)(1.0, t));
        return t * t * (3.0 - 2.0 * t);
    }
    return (x < edge0) ? 0.0 : 1.0;
}

// Helper: Apply Slew Rate Limiter
// Clamps the rate of change of a signal.
inline double apply_slew_limiter(double input, double& prev_val, double limit, double dt) {
    double delta = input - prev_val;
    double max_change = limit * dt;
    delta = std::clamp(delta, -max_change, max_change);
    prev_val += delta;
    return prev_val;
}

// Helper: Adaptive Non-Linear Smoothing
// t=0 (Steady) uses slow_tau, t=1 (Transient) uses fast_tau
inline double apply_adaptive_smoothing(double input, double& prev_out, double dt,
                                double slow_tau, double fast_tau, double sensitivity) {
    double delta = std::abs(input - prev_out);
    double t = delta / (sensitivity + 0.000001);
    t = (std::min)(1.0, t);

    double tau = slow_tau + t * (fast_tau - slow_tau);
    double alpha = dt / (tau + dt + 1e-9);
    alpha = (std::max)(0.0, (std::min)(1.0, alpha));

    prev_out = prev_out + alpha * (input - prev_out);
    return prev_out;
}

// Helper: Calculate Savitzky-Golay First Derivative
// Uses closed-form coefficient generation for quadratic polynomial fit.
template <size_t BufferSize>
inline double calculate_sg_derivative(const std::array<double, BufferSize>& buffer, 
                            const int& buffer_count, const int& window, double dt, const int& buffer_index) {
    // Note: buffer_index passed from caller should be the current write index (next slot)
    
    // Ensure we have enough samples
    if (buffer_count < window) return 0.0;
    
    int M = window / 2;  // Half-width (e.g., window=15 -> M=7)
    
    // Calculate S_2 = M(M+1)(2M+1)/3
    double S2 = (double)M * (M + 1.0) * (2.0 * M + 1.0) / 3.0;
    
    // Correct Indexing (v0.7.0 Fix)
    // m_slope_buffer_index points to the next slot to write.
    // Latest sample is at (index - 1). Center is at (index - 1 - M).
    // buffer_index MUST be the same as m_slope_buffer_index
    int latest_idx = (buffer_index - 1 + BufferSize) % BufferSize;
    int center_idx = (latest_idx - M + BufferSize) % BufferSize;
    
    double sum = 0.0;
    for (int k = 1; k <= M; ++k) {
        int idx_pos = (center_idx + k + BufferSize) % BufferSize;
        int idx_neg = (center_idx - k + BufferSize) % BufferSize;
        
        // Weights for d=1 are simply k
        sum += (double)k * (buffer[idx_pos] - buffer[idx_neg]);
    }
    
    // Divide by dt to get derivative in units/second
    return sum / (S2 * dt);
}
} // namespace ffb_math

#endif // MATH_UTILS_H

```

# File: src\PerfStats.h
```cpp
#ifndef PERF_STATS_H
#define PERF_STATS_H

#include <cmath>
#include <limits>

// Stats helper
struct ChannelStats {
    // Session-wide stats (Persistent)
    double session_min = 1e9;
    double session_max = -1e9;
    
    // Interval stats (Reset every second)
    double interval_sum = 0.0;
    long interval_count = 0;
    
    // Latched values for display/consumption by other threads (Interval)
    double l_avg = 0.0;
    // Latched values for display/consumption by other threads (Session)
    double l_min = 0.0;
    double l_max = 0.0;
    
    void Update(double val) {
        // Update Session Min/Max
        if (val < session_min) session_min = val;
        if (val > session_max) session_max = val;
        
        // Update Interval Accumulator
        interval_sum += val;
        interval_count++;
    }
    
    // Called every interval (e.g. 1s) to latch data and reset interval counters
    void ResetInterval() {
        if (interval_count > 0) {
            l_avg = interval_sum / interval_count;
        } else {
            l_avg = 0.0;
        }
        // Latch current session min/max for display
        l_min = session_min;
        l_max = session_max;
        
        // Reset interval data
        interval_sum = 0.0; 
        interval_count = 0;
    }
    
    // Compatibility helper
    double Avg() { return interval_count > 0 ? interval_sum / interval_count : 0.0; }
    void Reset() { ResetInterval(); }
};

#endif // PERF_STATS_H

```

# File: src\RateMonitor.h
```cpp
#ifndef RATEMONITOR_H
#define RATEMONITOR_H

#include <chrono>
#include <atomic>

/**
 * @brief Simple utility to monitor event frequency (Hz) over a 1-second sliding window.
 */
class RateMonitor {
public:
    RateMonitor() : m_count(0), m_lastRateScaled(0) {
        m_startTime = std::chrono::steady_clock::now();
    }

    /**
     * @brief Record a single event occurrence.
     */
    void RecordEvent() {
        RecordEventAt(std::chrono::steady_clock::now());
    }

    /**
     * @brief Record an event at a specific time (useful for testing).
     */
    void RecordEventAt(std::chrono::steady_clock::time_point now) {
        m_count++;
        auto duration_ms = std::chrono::duration_cast<std::chrono::milliseconds>(now - m_startTime).count();

        // Update rate every second
        if (duration_ms >= 1000) {
            long count = m_count.exchange(0);
            double rate = (double)count * 1000.0 / (double)duration_ms;
            m_lastRateScaled.store((long)(rate * 100.0));
            m_startTime = now;
        }
    }

    /**
     * @brief Get the last calculated rate in Hz.
     */
    double GetRate() const {
        return (double)m_lastRateScaled.load() / 100.0;
    }

private:
    std::atomic<long> m_count;
    std::chrono::steady_clock::time_point m_startTime;
    std::atomic<long> m_lastRateScaled; // Rate multiplied by 100 for atomic storage
};

#endif // RATEMONITOR_H

```

# File: src\resource.h
```cpp
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by res.rc
//
#define IDI_ICON1                       112

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        116
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

# File: src\VehicleUtils.cpp
```cpp
#include "VehicleUtils.h"
#include <algorithm>
#include <string>

// Helper: Parse car class from strings (v0.7.44 Refactor)
// Returns a ParsedVehicleClass enum for internal logic and categorization
ParsedVehicleClass ParseVehicleClass(const char* className, const char* vehicleName) {
    std::string cls = className ? className : "";
    std::string name = vehicleName ? vehicleName : "";

    // Normalize for case-insensitive matching
    std::transform(cls.begin(), cls.end(), cls.begin(), ::toupper);
    std::transform(name.begin(), name.end(), name.begin(), ::toupper);

    // 1. Primary Identification via Class Name (Hierarchical)
    if (cls.find("HYPERCAR") != std::string::npos || cls.find("LMH") != std::string::npos || cls.find("LMDH") != std::string::npos) {
        return ParsedVehicleClass::HYPERCAR;
    }
    
    if (cls.find("LMP2") != std::string::npos) {
        if (cls.find("ELMS") != std::string::npos || name.find("DERESTRICTED") != std::string::npos) { return ParsedVehicleClass::LMP2_UNRESTRICTED; }
        volatile bool is_wec = (cls.find("WEC") != std::string::npos);
        if (is_wec) { return ParsedVehicleClass::LMP2_RESTRICTED; }
        return ParsedVehicleClass::LMP2_UNSPECIFIED;
    }

    if (cls.find("LMP3") != std::string::npos) return ParsedVehicleClass::LMP3;
    if (cls.find("GTE") != std::string::npos) return ParsedVehicleClass::GTE;
    if (cls.find("GT3") != std::string::npos || cls.find("LMGT3") != std::string::npos) return ParsedVehicleClass::GT3;

    // 2. Secondary Identification via Vehicle Name Keywords (Fallback)
    if (!name.empty()) {
        // Hypercars
        if (name.find("499P") != std::string::npos || name.find("GR010") != std::string::npos ||
            name.find("963") != std::string::npos || name.find("9X8") != std::string::npos ||
            name.find("V-SERIES.R") != std::string::npos || name.find("SCG 007") != std::string::npos ||
            name.find("GLICKENHAUS") != std::string::npos || name.find("VANWALL") != std::string::npos ||
            name.find("A424") != std::string::npos || name.find("SC63") != std::string::npos ||
            name.find("VALKYRIE") != std::string::npos || name.find("M HYBRID") != std::string::npos ||
            name.find("TIPO 6") != std::string::npos || name.find("680") != std::string::npos) {
            return ParsedVehicleClass::HYPERCAR;
        }
        
        // LMP2
        if (name.find("ORECA") != std::string::npos || name.find("07") != std::string::npos) {
            return ParsedVehicleClass::LMP2_UNSPECIFIED;
        }

        // LMP3
        if (name.find("LIGIER") != std::string::npos || name.find("GINETTA") != std::string::npos ||
            name.find("DUQUEINE") != std::string::npos || name.find("P320") != std::string::npos ||
            name.find("P325") != std::string::npos || name.find("G61") != std::string::npos ||
            name.find("D09") != std::string::npos) {
            return ParsedVehicleClass::LMP3;
        }

        // GTE
        if (name.find("RSR-19") != std::string::npos || name.find("488 GTE") != std::string::npos ||
            name.find("C8.R") != std::string::npos || name.find("VANTAGE AMR") != std::string::npos) {
            return ParsedVehicleClass::GTE;
        }

        // GT3
        if (name.find("LMGT3") != std::string::npos || name.find("296 GT3") != std::string::npos ||
            name.find("M4 GT3") != std::string::npos || name.find("Z06 GT3") != std::string::npos ||
            name.find("HURACAN") != std::string::npos || name.find("RC F") != std::string::npos ||
            name.find("720S") != std::string::npos || name.find("MUSTANG") != std::string::npos) {
            return ParsedVehicleClass::GT3;
        }
    }

    return ParsedVehicleClass::UNKNOWN;
}

// Lookup table: Map ParsedVehicleClass to Seed Load (Newtons)
double GetDefaultLoadForClass(ParsedVehicleClass vclass) {
    switch (vclass) {
        case ParsedVehicleClass::HYPERCAR:         return 9500.0;
        case ParsedVehicleClass::LMP2_UNRESTRICTED: return 8500.0;
        case ParsedVehicleClass::LMP2_RESTRICTED:   return 7500.0;
        case ParsedVehicleClass::LMP2_UNSPECIFIED:  return 7500.0;
        case ParsedVehicleClass::LMP3:             return 5800.0;
        case ParsedVehicleClass::GTE:              return 5500.0;
        case ParsedVehicleClass::GT3:              return 4800.0;
        default:                                   return 4500.0;
    }
}

// Helper: String representation of parsed class for logging and UI
const char* VehicleClassToString(ParsedVehicleClass vclass) {
    switch (vclass) {
        case ParsedVehicleClass::HYPERCAR:         return "Hypercar";
        case ParsedVehicleClass::LMP2_UNRESTRICTED: return "LMP2 Unrestricted";
        case ParsedVehicleClass::LMP2_RESTRICTED:   return "LMP2 Restricted";
        case ParsedVehicleClass::LMP2_UNSPECIFIED:  return "LMP2 Unspecified";
        case ParsedVehicleClass::LMP3:             return "LMP3";
        case ParsedVehicleClass::GTE:              return "GTE";
        case ParsedVehicleClass::GT3:              return "GT3";
        default:                                   return "Unknown";
    }
}

```

# File: src\VehicleUtils.h
```cpp
#ifndef VEHICLE_UTILS_H
#define VEHICLE_UTILS_H

#include <string>

enum class ParsedVehicleClass {
    UNKNOWN = 0,
    HYPERCAR,
    LMP2_UNRESTRICTED, // 8500N (ELMS/Unrestricted)
    LMP2_RESTRICTED,   // 7500N (WEC/Restricted)
    LMP2_UNSPECIFIED,  // 8000N (Generic Fallback)
    LMP3,              // 5800N
    GTE,               // 5500N
    GT3                // 4800N
};

// Returns a ParsedVehicleClass enum for internal logic and categorization
ParsedVehicleClass ParseVehicleClass(const char* className, const char* vehicleName);

// Lookup table: Map ParsedVehicleClass to Seed Load (Newtons)
double GetDefaultLoadForClass(ParsedVehicleClass vclass);

// Helper: String representation of parsed class for logging and UI
const char* VehicleClassToString(ParsedVehicleClass vclass);

#endif // VEHICLE_UTILS_H

```

# File: src\Version.h
```cpp

```

# File: src\aceFFB\aceFFBEngine.h
```cpp

```

# File: src\lmu_sm_interface\InternalsPlugin.hpp
```
//###########################################################################
//#                                                                         #
//# Module: Header file for internals plugin                                #
//#                                                                         #
//# Description: Interface declarations for internals plugin                #
//#                                                                         #
//# This source code module, and all information, data, and algorithms      #
//# associated with it, are part of isiMotor Technology (tm).               #
//#                 PROPRIETARY AND CONFIDENTIAL                            #
//# Copyright (c) 2025 Studio 397 BV and Motorsport Games Inc.              #
//#                                                                         #
//###########################################################################

#ifndef _INTERNALS_PLUGIN_HPP_
#define _INTERNALS_PLUGIN_HPP_

#include "PluginObjects.hpp"     // base class for plugin objects to derive from
#include <cmath>                 // for sqrt()
#include <windows.h>             // for HWND
// rF2 and plugins must agree on structure packing, so set it explicitly here.
// Whatever the current packing is will be restored at the end of this include
// with another #pragma.
#pragma pack( push, 4 )


//#########################################################################
//# Version01 Structures                                                   #
//##########################################################################

struct TelemVect3
{
    union
    {
        struct
        {
            double x, y, z;
        };

        double data[3];
    };


  void Set( const double a, const double b, const double c )  { x = a; y = b; z = c; }

  // Allowed to reference as [0], [1], or [2], instead of .x, .y, or .z, respectively
        double &operator[]( long i )               { return( data [ i ] ); }
  const double &operator[]( long i ) const         { return( data [ i ] ); }
};


struct TelemQuat
{
  double w, x, y, z;

  // Convert this quaternion to a matrix
  void ConvertQuatToMat( TelemVect3 ori[3] ) const
  {
    const double x2 = x + x;
    const double xx = x * x2;
    const double y2 = y + y;
    const double yy = y * y2;
    const double z2 = z + z;
    const double zz = z * z2;
    const double xz = x * z2;
    const double xy = x * y2;
    const double wy = w * y2;
    const double wx = w * x2;
    const double wz = w * z2;
    const double yz = y * z2;
    ori[0][0] = (double) 1.0 - ( yy + zz );
    ori[0][1] = xy - wz;
    ori[0][2] = xz + wy;
    ori[1][0] = xy + wz;
    ori[1][1] = (double) 1.0 - ( xx + zz );
    ori[1][2] = yz - wx;
    ori[2][0] = xz - wy;
    ori[2][1] = yz + wx;
    ori[2][2] = (double) 1.0 - ( xx + yy );
  }

  // Convert a matrix to this quaternion
  void ConvertMatToQuat( const TelemVect3 ori[3] )
  {
    const double trace = ori[0][0] + ori[1][1] + ori[2][2] + (double) 1.0;
    if( trace > 0.0625f )
    {
      const double sqrtTrace = sqrt( trace );
      const double s = (double) 0.5 / sqrtTrace;
      w = (double) 0.5 * sqrtTrace;
      x = ( ori[2][1] - ori[1][2] ) * s;
      y = ( ori[0][2] - ori[2][0] ) * s;
      z = ( ori[1][0] - ori[0][1] ) * s;
    }
    else if( ( ori[0][0] > ori[1][1] ) && ( ori[0][0] > ori[2][2] ) )
    {
      const double sqrtTrace = sqrt( (double) 1.0 + ori[0][0] - ori[1][1] - ori[2][2] );
      const double s = (double) 0.5 / sqrtTrace;
      w = ( ori[2][1] - ori[1][2] ) * s;
      x = (double) 0.5 * sqrtTrace;
      y = ( ori[0][1] + ori[1][0] ) * s;
      z = ( ori[0][2] + ori[2][0] ) * s;
    }
    else if( ori[1][1] > ori[2][2] )
    {
      const double sqrtTrace = sqrt( (double) 1.0 + ori[1][1] - ori[0][0] - ori[2][2] );
      const double s = (double) 0.5 / sqrtTrace;
      w = ( ori[0][2] - ori[2][0] ) * s;
      x = ( ori[0][1] + ori[1][0] ) * s;
      y = (double) 0.5 * sqrtTrace;
      z = ( ori[1][2] + ori[2][1] ) * s;
    }
    else
    {
      const double sqrtTrace = sqrt( (double) 1.0 + ori[2][2] - ori[0][0] - ori[1][1] );
      const double s = (double) 0.5 / sqrtTrace;
      w = ( ori[1][0] - ori[0][1] ) * s;
      x = ( ori[0][2] + ori[2][0] ) * s;
      y = ( ori[1][2] + ori[2][1] ) * s;
      z = (double) 0.5 * sqrtTrace;
    }
  }
};


struct TelemWheelV01
{
  double mSuspensionDeflection;  // meters
  double mRideHeight;            // meters
  double mSuspForce;             // pushrod load in Newtons
  double mBrakeTemp;             // Celsius
  double mBrakePressure;         // currently 0.0-1.0, depending on driver input and brake balance; will convert to true brake pressure (kPa) in future

  double mRotation;              // radians/sec
  double mLateralPatchVel;       // lateral velocity at contact patch
  double mLongitudinalPatchVel;  // longitudinal velocity at contact patch
  double mLateralGroundVel;      // lateral velocity at contact patch
  double mLongitudinalGroundVel; // longitudinal velocity at contact patch
  double mCamber;                // radians (positive is left for left-side wheels, right for right-side wheels)
  double mLateralForce;          // Newtons
  double mLongitudinalForce;     // Newtons
  double mTireLoad;              // Newtons

  double mGripFract;             // an approximation of what fraction of the contact patch is sliding
  double mPressure;              // kPa (tire pressure)
  double mTemperature[3];        // Kelvin (subtract 273.15 to get Celsius), left/center/right (not to be confused with inside/center/outside!)
  double mWear;                  // wear (0.0-1.0, fraction of maximum) ... this is not necessarily proportional with grip loss
  char mTerrainName[16];         // the material prefixes from the TDF file
  unsigned char mSurfaceType;    // 0=dry, 1=wet, 2=grass, 3=dirt, 4=gravel, 5=rumblestrip, 6=special
  bool mFlat;                    // whether tire is flat
  bool mDetached;                // whether wheel is detached
  unsigned char mStaticUndeflectedRadius; // tire radius in centimeters

  double mVerticalTireDeflection;// how much is tire deflected from its (speed-sensitive) radius
  double mWheelYLocation;        // wheel's y location relative to vehicle y location
  double mToe;                   // current toe angle w.r.t. the vehicle

  double mTireCarcassTemperature;       // rough average of temperature samples from carcass (Kelvin)
  double mTireInnerLayerTemperature[3]; // rough average of temperature samples from innermost layer of rubber (before carcass) (Kelvin)

  unsigned char mExpansion[ 24 ];// for future use
};


// Our world coordinate system is left-handed, with +y pointing up.
// The local vehicle coordinate system is as follows:
//   +x points out the left side of the car (from the driver's perspective)
//   +y points out the roof
//   +z points out the back of the car
// Rotations are as follows:
//   +x pitches up
//   +y yaws to the right
//   +z rolls to the right
// Note that ISO vehicle coordinates (+x forward, +y right, +z upward) are
// right-handed.  If you are using that system, be sure to negate any rotation
// or torque data because things rotate in the opposite direction.  In other
// words, a -z velocity in rFactor is a +x velocity in ISO, but a -z rotation
// in rFactor is a -x rotation in ISO!!!

struct TelemInfoV01
{
  // Time
  long mID;                      // slot ID (note that it can be re-used in multiplayer after someone leaves)
  double mDeltaTime;             // time since last update (seconds)
  double mElapsedTime;           // game session time
  long mLapNumber;               // current lap number
  double mLapStartET;            // time this lap was started
  char mVehicleName[64];         // current vehicle name
  char mTrackName[64];           // current track name

  // Position and derivatives
  TelemVect3 mPos;               // world position in meters
  TelemVect3 mLocalVel;          // velocity (meters/sec) in local vehicle coordinates
  TelemVect3 mLocalAccel;        // acceleration (meters/sec^2) in local vehicle coordinates

  // Orientation and derivatives
  TelemVect3 mOri[3];            // rows of orientation matrix (use TelemQuat conversions if desired), also converts local
                                 // vehicle vectors into world X, Y, or Z using dot product of rows 0, 1, or 2 respectively
  TelemVect3 mLocalRot;          // rotation (radians/sec) in local vehicle coordinates
  TelemVect3 mLocalRotAccel;     // rotational acceleration (radians/sec^2) in local vehicle coordinates

  // Vehicle status
  long mGear;                    // -1=reverse, 0=neutral, 1+=forward gears
  double mEngineRPM;             // engine RPM
  double mEngineWaterTemp;       // Celsius
  double mEngineOilTemp;         // Celsius
  double mClutchRPM;             // clutch RPM

  // Driver input
  double mUnfilteredThrottle;    // ranges  0.0-1.0
  double mUnfilteredBrake;       // ranges  0.0-1.0
  double mUnfilteredSteering;    // ranges -1.0-1.0 (left to right)
  double mUnfilteredClutch;      // ranges  0.0-1.0

  // Filtered input (various adjustments for rev or speed limiting, TC, ABS?, speed sensitive steering, clutch work for semi-automatic shifting, etc.)
  double mFilteredThrottle;      // ranges  0.0-1.0
  double mFilteredBrake;         // ranges  0.0-1.0
  double mFilteredSteering;      // ranges -1.0-1.0 (left to right)
  double mFilteredClutch;        // ranges  0.0-1.0

  // Misc
  double mSteeringShaftTorque;   // torque around steering shaft (used to be mSteeringArmForce, but that is not necessarily accurate for feedback purposes)
  double mFront3rdDeflection;    // deflection at front 3rd spring
  double mRear3rdDeflection;     // deflection at rear 3rd spring

  // Aerodynamics
  double mFrontWingHeight;       // front wing height
  double mFrontRideHeight;       // front ride height
  double mRearRideHeight;        // rear ride height
  double mDrag;                  // drag
  double mFrontDownforce;        // front downforce
  double mRearDownforce;         // rear downforce

  // State/damage info
  double mFuel;                  // amount of fuel (liters)
  double mEngineMaxRPM;          // rev limit
  unsigned char mScheduledStops; // number of scheduled pitstops
  bool  mOverheating;            // whether overheating icon is shown
  bool  mDetached;               // whether any parts (besides wheels) have been detached
  bool  mHeadlights;             // whether headlights are on
  unsigned char mDentSeverity[8];// dent severity at 8 locations around the car (0=none, 1=some, 2=more)
  double mLastImpactET;          // time of last impact
  double mLastImpactMagnitude;   // magnitude of last impact
  TelemVect3 mLastImpactPos;     // location of last impact

  // Expanded
  double mEngineTorque;          // current engine torque (including additive torque) (used to be mEngineTq, but there's little reason to abbreviate it)
  long mCurrentSector;           // the current sector (zero-based) with the pitlane stored in the sign bit (example: entering pits from third sector gives 0x80000002)
  unsigned char mSpeedLimiter;   // whether speed limiter is on
  unsigned char mMaxGears;       // maximum forward gears
  unsigned char mFrontTireCompoundIndex;   // index within brand
  unsigned char mRearTireCompoundIndex;    // index within brand
  double mFuelCapacity;          // capacity in liters
  unsigned char mFrontFlapActivated;       // whether front flap is activated
  unsigned char mRearFlapActivated;        // whether rear flap is activated
  unsigned char mRearFlapLegalStatus;      // 0=disallowed, 1=criteria detected but not allowed quite yet, 2=allowed
  unsigned char mIgnitionStarter;          // 0=off 1=ignition 2=ignition+starter

  char mFrontTireCompoundName[18];         // name of front tire compound
  char mRearTireCompoundName[18];          // name of rear tire compound

  unsigned char mSpeedLimiterAvailable;    // whether speed limiter is available
  unsigned char mAntiStallActivated;       // whether (hard) anti-stall is activated
  unsigned char mUnused[2];                //
  float mVisualSteeringWheelRange;         // the *visual* steering wheel range

  double mRearBrakeBias;                   // fraction of brakes on rear
  double mTurboBoostPressure;              // current turbo boost pressure if available
  float mPhysicsToGraphicsOffset[3];       // offset from static CG to graphical center
  float mPhysicalSteeringWheelRange;       // the *physical* steering wheel range

  // deltabest
  double mDeltaBest;

  double mBatteryChargeFraction; // Battery charge as fraction [0.0-1.0]

  // electric boost motor
  double mElectricBoostMotorTorque; // current torque of boost motor (can be negative when in regenerating mode)
  double mElectricBoostMotorRPM; // current rpm of boost motor
  double mElectricBoostMotorTemperature; // current temperature of boost motor
  double mElectricBoostWaterTemperature; // current water temperature of boost motor cooler if present (0 otherwise)
  unsigned char mElectricBoostMotorState; // 0=unavailable 1=inactive, 2=propulsion, 3=regeneration
  
  // Future use
  unsigned char mExpansion[111-8]; // for future use (note that the slot ID has been moved to mID above)

  // keeping this at the end of the structure to make it easier to replace in future versions
  TelemWheelV01 mWheel[4];       // wheel info (front left, front right, rear left, rear right)
};


struct GraphicsInfoV01
{
  TelemVect3 mCamPos;            // camera position
  TelemVect3 mCamOri[3];         // rows of orientation matrix (use TelemQuat conversions if desired), also converts local
  HWND mHWND;                    // app handle

  double mAmbientRed;
  double mAmbientGreen;
  double mAmbientBlue;
};


struct GraphicsInfoV02 : public GraphicsInfoV01
{
  long mID;                      // slot ID being viewed (-1 if invalid)

  // Camera types (some of these may only be used for *setting* the camera type in WantsToViewVehicle())
  //    0  = TV cockpit
  //    1  = cockpit
  //    2  = nosecam
  //    3  = swingman
  //    4  = trackside (nearest)
  //    5  = onboard000
  //       :
  //       :
  // 1004  = onboard999
  // 1005+ = (currently unsupported, in the future may be able to set/get specific trackside camera)
  long mCameraType;              // see above comments for possible values

  unsigned char mExpansion[128]; // for future use (possibly camera name)
};


struct CameraControlInfoV01
{
  // Cameras
  long mID;                      // slot ID to view
  long mCameraType;              // see GraphicsInfoV02 comments for values

  // Replays (note that these are asynchronous)
  bool mReplayActive;            // This variable is an *input* filled with whether the replay is currently active (as opposed to realtime).
  bool mReplayUnused;            //
  unsigned char mReplayCommand;  // 0=do nothing, 1=begin, 2=end, 3=rewind, 4=fast backwards, 5=backwards, 6=slow backwards, 7=stop, 8=slow play, 9=play, 10=fast play, 11=fast forward

  bool mReplaySetTime;           // Whether to skip to the following replay time:
  float mReplaySeconds;          // The replay time in seconds to skip to (note: the current replay maximum ET is passed into this variable in case you need it)

  //
  unsigned char mExpansion[120]; // for future use (possibly camera name & positions/orientations)
};


struct MessageInfoV01
{
  char mText[128];               // message to display

  unsigned char mDestination;    // 0 = message center, 1 = chat (can be used for multiplayer chat commands)
  unsigned char mTranslate;      // 0 = do not attempt to translate, 1 = attempt to translate

  unsigned char mExpansion[126]; // for future use (possibly what color, what font, and seconds to display)
};


struct VehicleScoringInfoV01
{
  long mID;                      // slot ID (note that it can be re-used in multiplayer after someone leaves)
  char mDriverName[32];          // driver name
  char mVehicleName[64];         // vehicle name
  short mTotalLaps;              // laps completed
  signed char mSector;           // 0=sector3, 1=sector1, 2=sector2 (don't ask why)
  signed char mFinishStatus;     // 0=none, 1=finished, 2=dnf, 3=dq
  double mLapDist;               // current distance around track
  double mPathLateral;           // lateral position with respect to *very approximate* "center" path
  double mTrackEdge;             // track edge (w.r.t. "center" path) on same side of track as vehicle

  double mBestSector1;           // best sector 1
  double mBestSector2;           // best sector 2 (plus sector 1)
  double mBestLapTime;           // best lap time
  double mLastSector1;           // last sector 1
  double mLastSector2;           // last sector 2 (plus sector 1)
  double mLastLapTime;           // last lap time
  double mCurSector1;            // current sector 1 if valid
  double mCurSector2;            // current sector 2 (plus sector 1) if valid
  // no current laptime because it instantly becomes "last"

  short mNumPitstops;            // number of pitstops made
  short mNumPenalties;           // number of outstanding penalties
  bool mIsPlayer;                // is this the player's vehicle

  signed char mControl;          // who's in control: -1=nobody (shouldn't get this), 0=local player, 1=local AI, 2=remote, 3=replay (shouldn't get this)
  bool mInPits;                  // between pit entrance and pit exit (not always accurate for remote vehicles)
  unsigned char mPlace;          // 1-based position
  char mVehicleClass[32];        // vehicle class

  // Dash Indicators
  double mTimeBehindNext;        // time behind vehicle in next higher place
  long mLapsBehindNext;          // laps behind vehicle in next higher place
  double mTimeBehindLeader;      // time behind leader
  long mLapsBehindLeader;        // laps behind leader
  double mLapStartET;            // time this lap was started

  // Position and derivatives
  TelemVect3 mPos;               // world position in meters
  TelemVect3 mLocalVel;          // velocity (meters/sec) in local vehicle coordinates
  TelemVect3 mLocalAccel;        // acceleration (meters/sec^2) in local vehicle coordinates

  // Orientation and derivatives
  TelemVect3 mOri[3];            // rows of orientation matrix (use TelemQuat conversions if desired), also converts local
                                 // vehicle vectors into world X, Y, or Z using dot product of rows 0, 1, or 2 respectively
  TelemVect3 mLocalRot;          // rotation (radians/sec) in local vehicle coordinates
  TelemVect3 mLocalRotAccel;     // rotational acceleration (radians/sec^2) in local vehicle coordinates

  // tag.2012.03.01 - stopped casting some of these so variables now have names and mExpansion has shrunk, overall size and old data locations should be same
  unsigned char mHeadlights;     // status of headlights
  unsigned char mPitState;       // 0=none, 1=request, 2=entering, 3=stopped, 4=exiting
  unsigned char mServerScored;   // whether this vehicle is being scored by server (could be off in qualifying or racing heats)
  unsigned char mIndividualPhase;// game phases (described below) plus 9=after formation, 10=under yellow, 11=under blue (not used)

  long mQualification;           // 1-based, can be -1 when invalid

  double mTimeIntoLap;           // estimated time into lap
  double mEstimatedLapTime;      // estimated laptime used for 'time behind' and 'time into lap' (note: this may changed based on vehicle and setup!?)

  char mPitGroup[24];            // pit group (same as team name unless pit is shared)
  unsigned char mFlag;           // primary flag being shown to vehicle (currently only 0=green or 6=blue)
  bool mUnderYellow;             // whether this car has taken a full-course caution flag at the start/finish line
  unsigned char mCountLapFlag;   // 0 = do not count lap or time, 1 = count lap but not time, 2 = count lap and time
  bool mInGarageStall;           // appears to be within the correct garage stall

  unsigned char mUpgradePack[16];  // Coded upgrades
  float mPitLapDist;             // location of pit in terms of lap distance

  float mBestLapSector1;         // sector 1 time from best lap (not necessarily the best sector 1 time)
  float mBestLapSector2;         // sector 2 time from best lap (not necessarily the best sector 2 time)

  unsigned long long mSteamID;            // SteamID of the current driver (if any)

  char mVehFilename[32];		// filename of veh file used to identify this vehicle.

  short mAttackMode;

  // 2020.11.12 - Took 1 byte from mExpansion to transmit fuel percentage
  unsigned char mFuelFraction; // Percentage of fuel or battery left in vehicle. 0x00 = 0%; 0xFF = 100%

  // 2021.05.28 - Took 1 byte from mExpansion to transmit DRS (RearFlap) state - consider making this a bitfield if further bools are needed later on
  bool mDRSState;

  // Future use
  unsigned char mExpansion[4];		// for future use
};


struct ScoringInfoV01
{
  char mTrackName[64];           // current track name
  long mSession;                 // current session (0=testday 1-4=practice 5-8=qual 9=warmup 10-13=race)
  double mCurrentET;             // current time
  double mEndET;                 // ending time
  long  mMaxLaps;                // maximum laps
  double mLapDist;               // distance around track
  char *mResultsStream;          // results stream additions since last update (newline-delimited and NULL-terminated)

  long mNumVehicles;             // current number of vehicles

  // Game phases:
  // 0 Before session has begun
  // 1 Reconnaissance laps (race only)
  // 2 Grid walk-through (race only)
  // 3 Formation lap (race only)
  // 4 Starting-light countdown has begun (race only)
  // 5 Green flag
  // 6 Full course yellow / safety car
  // 7 Session stopped
  // 8 Session over
  // 9 Paused (tag.2015.09.14 - this is new, and indicates that this is a heartbeat call to the plugin)
  unsigned char mGamePhase;

  // Yellow flag states (applies to full-course only)
  // -1 Invalid
  //  0 None
  //  1 Pending
  //  2 Pits closed
  //  3 Pit lead lap
  //  4 Pits open
  //  5 Last lap
  //  6 Resume
  //  7 Race halt (not currently used)
  signed char mYellowFlagState;

  signed char mSectorFlag[3];      // whether there are any local yellows at the moment in each sector (not sure if sector 0 is first or last, so test)
  unsigned char mStartLight;       // start light frame (number depends on track)
  unsigned char mNumRedLights;     // number of red lights in start sequence
  bool mInRealtime;                // in realtime as opposed to at the monitor
  char mPlayerName[32];            // player name (including possible multiplayer override)
  char mPlrFileName[64];           // may be encoded to be a legal filename

  // weather
  double mDarkCloud;               // cloud darkness? 0.0-1.0
  double mRaining;                 // raining severity 0.0-1.0
  double mAmbientTemp;             // temperature (Celsius)
  double mTrackTemp;               // temperature (Celsius)
  TelemVect3 mWind;                // wind speed
  double mMinPathWetness;          // minimum wetness on main path 0.0-1.0
  double mMaxPathWetness;          // maximum wetness on main path 0.0-1.0

  // multiplayer
  unsigned char mGameMode; // 1 = server, 2 = client, 3 = server and client
  bool mIsPasswordProtected; // is the server password protected
  unsigned short mServerPort; // the port of the server (if on a server)
  unsigned long mServerPublicIP; // the public IP address of the server (if on a server)
  long mMaxPlayers; // maximum number of vehicles that can be in the session
  char mServerName[32]; // name of the server
  float mStartET; // start time (seconds since midnight) of the event

  //
  double mAvgPathWetness;          // average wetness on main path 0.0-1.0

  // Future use
  unsigned char mExpansion[200];

  // keeping this at the end of the structure to make it easier to replace in future versions
  VehicleScoringInfoV01 *mVehicle; // array of vehicle scoring info's
};


struct CommentaryRequestInfoV01
{
  char mName[32];                  // one of the event names in the commentary INI file
  double mInput1;                  // first value to pass in (if any)
  double mInput2;                  // first value to pass in (if any)
  double mInput3;                  // first value to pass in (if any)
  bool mSkipChecks;                // ignores commentary detail and random probability of event

  // constructor (for noobs, this just helps make sure everything is initialized to something reasonable)
  CommentaryRequestInfoV01()       { mName[0] = 0; mInput1 = 0.0; mInput2 = 0.0; mInput3 = 0.0; mSkipChecks = false; }
};


//#########################################################################
//# Version02 Structures                                                   #
//##########################################################################

struct PhysicsOptionsV01
{
  unsigned char mTractionControl;  // 0 (off) - 3 (high)
  unsigned char mAntiLockBrakes;   // 0 (off) - 2 (high)
  unsigned char mStabilityControl; // 0 (off) - 2 (high)
  unsigned char mAutoShift;        // 0 (off), 1 (upshifts), 2 (downshifts), 3 (all)
  unsigned char mAutoClutch;       // 0 (off), 1 (on)
  unsigned char mInvulnerable;     // 0 (off), 1 (on)
  unsigned char mOppositeLock;     // 0 (off), 1 (on)
  unsigned char mSteeringHelp;     // 0 (off) - 3 (high)
  unsigned char mBrakingHelp;      // 0 (off) - 2 (high)
  unsigned char mSpinRecovery;     // 0 (off), 1 (on)
  unsigned char mAutoPit;          // 0 (off), 1 (on)
  unsigned char mAutoLift;         // 0 (off), 1 (on)
  unsigned char mAutoBlip;         // 0 (off), 1 (on)

  unsigned char mFuelMult;         // fuel multiplier (0x-7x)
  unsigned char mTireMult;         // tire wear multiplier (0x-7x)
  unsigned char mMechFail;         // mechanical failure setting; 0 (off), 1 (normal), 2 (timescaled)
  unsigned char mAllowPitcrewPush; // 0 (off), 1 (on)
  unsigned char mRepeatShifts;     // accidental repeat shift prevention (0-5; see PLR file)
  unsigned char mHoldClutch;       // for auto-shifters at start of race: 0 (off), 1 (on)
  unsigned char mAutoReverse;      // 0 (off), 1 (on)
  unsigned char mAlternateNeutral; // Whether shifting up and down simultaneously equals neutral

  // tag.2014.06.09 - yes these are new, but no they don't change the size of the structure nor the address of the other variables in it (because we're just using the existing padding)
  unsigned char mAIControl;        // Whether player vehicle is currently under AI control
  unsigned char mUnused1;          //
  unsigned char mUnused2;          //

  float mManualShiftOverrideTime;  // time before auto-shifting can resume after recent manual shift
  float mAutoShiftOverrideTime;    // time before manual shifting can resume after recent auto shift
  float mSpeedSensitiveSteering;   // 0.0 (off) - 1.0
};


struct EnvironmentInfoV01
{
  // TEMPORARY buffers (you should copy them if needed for later use) containing various paths that may be needed.  Each of these
  // could be relative ("UserData\") or full ("C:\BlahBlah\rFactorProduct\UserData\").
  // mPath[ 0 ] points to the UserData directory.
  // mPath[ 1 ] points to the CustomPluginOptions.JSON filename.
  // mPath[ 2 ] points to the latest results file
  // (in the future, we may add paths for the current garage setup, fully upgraded physics files, etc., any other requests?)
  const char *mPath[ 16 ];
  unsigned char mExpansion[256];   // future use
};


// deprecated (callbacks are no longer invoked in DX11) since V8
struct ScreenInfoV01
{
  HWND mAppWindow;                      // Application window handle
  void *mDevice;                        // Cast type to LPDIRECT3DDEVICE9
  void *mRenderTarget;                  // Cast type to LPDIRECT3DTEXTURE9
  long mDriver;                         // Current video driver index

  long mWidth;                          // Screen width
  long mHeight;                         // Screen height
  long mPixelFormat;                    // Pixel format
  long mRefreshRate;                    // Refresh rate
  long mWindowed;                       // Really just a boolean whether we are in windowed mode

  long mOptionsWidth;                   // Width dimension of screen portion used by UI
  long mOptionsHeight;                  // Height dimension of screen portion used by UI
  long mOptionsLeft;                    // Horizontal starting coordinate of screen portion used by UI
  long mOptionsUpper;                   // Vertical starting coordinate of screen portion used by UI

  unsigned char mOptionsLocation;       // 0=main UI, 1=track loading, 2=monitor, 3=on track
  char mOptionsPage[ 31 ];              // the name of the options page

  unsigned char mExpansion[ 224 ];      // future use
};


// replaces the ScreenInfoV01 structure that was deprecated since V8
struct ApplicationStateV01 {
  HWND mAppWindow;                      // application window handle
  unsigned long mWidth;                 // screen width
  unsigned long mHeight;                // screen height
  unsigned long mRefreshRate;           // refresh rate
  unsigned long mWindowed;              // really just a boolean whether we are in windowed mode
  unsigned char mOptionsLocation;       // 0=main UI, 1=track loading, 2=monitor, 3=on track
  char mOptionsPage[ 31 ];              // the name of the options page
  unsigned char mExpansion[ 204 ];      // future use
};


struct CustomControlInfoV01
{
  // The name passed through CheckHWControl() will be the mUntranslatedName prepended with an underscore (e.g. "Track Map Toggle" -> "_Track Map Toggle")
  char mUntranslatedName[ 64 ];         // name of the control that will show up in UI (but translated if available)
  long mRepeat;                         // 0=registers once per hit, 1=registers once, waits briefly, then starts repeating quickly, 2=registers as long as key is down
  unsigned char mExpansion[ 64 ];       // future use
};


struct WeatherControlInfoV01
{
  // The current conditions are passed in with the API call. The following ET (Elapsed Time) value should typically be far
  // enough in the future that it can be interpolated smoothly, and allow clouds time to roll in before rain starts. In
  // other words you probably shouldn't have mCloudiness and mRaining suddenly change from 0.0 to 1.0 and expect that
  // to happen in a few seconds without looking crazy.
  double mET;                           // when you want this weather to take effect

  // mRaining[1][1] is at the origin (2013.12.19 - and currently the only implemented node), while the others
  // are spaced at <trackNodeSize> meters where <trackNodeSize> is the maximum absolute value of a track vertex
  // coordinate (and is passed into the API call).
  double mRaining[ 3 ][ 3 ];            // rain (0.0-1.0) at different nodes

  double mCloudiness;                   // general cloudiness (0.0=clear to 1.0=dark), will be automatically overridden to help ensure clouds exist over rainy areas
  double mAmbientTempK;                 // ambient temperature (Kelvin)
  double mWindMaxSpeed;                 // maximum speed of wind (ground speed, but it affects how fast the clouds move, too)

  bool mApplyCloudinessInstantly;       // preferably we roll the new clouds in, but you can instantly change them now
  bool mUnused1;                        //
  bool mUnused2;                        //
  bool mUnused3;                        //

  unsigned char mExpansion[ 508 ];      // future use (humidity, pressure, air density, etc.)
};


//#########################################################################
//# Version07 Structures                                                   #
//##########################################################################

struct CustomVariableV01
{
  char mCaption[ 128 ];                 // Name of variable. This will be used for storage. In the future, this may also be used in the UI (after attempting to translate).
  long mNumSettings;                    // Number of available settings. The special value 0 should be used for types that have limitless possibilities, which will be treated as a string type.
  long mCurrentSetting;                 // Current setting (also the default setting when returned in GetCustomVariable()). This is zero-based, so: ( 0 <= mCurrentSetting < mNumSettings )

  // future expansion
  unsigned char mExpansion[ 256 ];
};

struct CustomSettingV01
{
  char mName[ 128 ];                    // Enumerated name of setting (only used if CustomVariableV01::mNumSettings > 0). This will be stored in the JSON file for informational purposes only. It may also possibly be used in the UI in the future.
};

struct MultiSessionParticipantV01
{
  // input only
  long mID;                             // slot ID (if loaded) or -1 (if currently disconnected)
  char mDriverName[ 32 ];               // driver name
  char mVehicleName[ 64 ];              // vehicle name
  unsigned char mUpgradePack[ 16 ];     // coded upgrades

  float mBestPracticeTime;              // best practice time
  long mQualParticipantIndex;           // once qualifying begins, this becomes valid and ranks participants according to practice time if possible
  float mQualificationTime[ 4 ];        // best qualification time in up to 4 qual sessions
  float mFinalRacePlace[ 4 ];           // final race place in up to 4 race sessions
  float mFinalRaceTime[ 4 ];            // final race time in up to 4 race sessions

  // input/output
  bool mServerScored;                   // whether vehicle is allowed to participate in current session
  long mGridPosition;                   // 1-based grid position for current race session (or upcoming race session if it is currently warmup), or -1 if currently disconnected
// long mPitIndex;
// long mGarageIndex;

  // future expansion
  unsigned char mExpansion[ 128 ];
};

struct MultiSessionRulesV01
{
  // input only
  long mSession;                        // current session (0=testday 1-4=practice 5-8=qual 9=warmup 10-13=race)
  long mSpecialSlotID;                  // slot ID of someone who just joined, or -2 requesting to update qual order, or -1 (default/general)
  char mTrackType[ 32 ];                // track type from GDB
  long mNumParticipants;                // number of participants (vehicles)

  // input/output
  MultiSessionParticipantV01 *mParticipant;       // array of partipants (vehicles)
  long mNumQualSessions;                // number of qualifying sessions configured
  long mNumRaceSessions;                // number of race sessions configured
  long mMaxLaps;                        // maximum laps allowed in current session (LONG_MAX = unlimited) (note: cannot currently edit in *race* sessions)
  long mMaxSeconds;                     // maximum time allowed in current session (LONG_MAX = unlimited) (note: cannot currently edit in *race* sessions)
  char mName[ 32 ];                     // untranslated name override for session (please use mixed case here, it should get uppercased if necessary)

  // future expansion
  unsigned char mExpansion[ 256 ];
};


enum TrackRulesCommandV01               //
{
  TRCMD_ADD_FROM_TRACK = 0,             // crossed s/f line for first time after full-course yellow was called
  TRCMD_ADD_FROM_PIT,                   // exited pit during full-course yellow
  TRCMD_ADD_FROM_UNDQ,                  // during a full-course yellow, the admin reversed a disqualification
  TRCMD_REMOVE_TO_PIT,                  // entered pit during full-course yellow
  TRCMD_REMOVE_TO_DNF,                  // vehicle DNF'd during full-course yellow
  TRCMD_REMOVE_TO_DQ,                   // vehicle DQ'd during full-course yellow
  TRCMD_REMOVE_TO_UNLOADED,             // vehicle unloaded (possibly kicked out or banned) during full-course yellow
  TRCMD_MOVE_TO_BACK,                   // misbehavior during full-course yellow, resulting in the penalty of being moved to the back of their current line
  TRCMD_LONGEST_LINE,                   // misbehavior during full-course yellow, resulting in the penalty of being moved to the back of the longest line
  //------------------
  TRCMD_MAXIMUM                         // should be last
};

struct TrackRulesActionV01
{
  // input only
  TrackRulesCommandV01 mCommand;        // recommended action
  long mID;                             // slot ID if applicable
  unsigned char mLine;                  // line this command applies to (if applicable)
};

enum TrackRulesColumnV01
{
  TRCOL_LEFT_LANE = 0,                  // left (inside)
  TRCOL_MIDDLE_LANE,                    // middle
  TRCOL_RIGHT_LANE,                     // right (outside)
  //------------------
  TRCOL_MAX_LANES,                      // should be after the valid static lane choices
  //------------------
  TRCOL_INVALID = TRCOL_MAX_LANES,      // currently invalid (hasn't crossed line or in pits/garage)
  TRCOL_FREECHOICE,                     // free choice (dynamically chosen by driver)
  TRCOL_PENDING,                        // depends on another participant's free choice (dynamically set after another driver chooses)
  //------------------
  TRCOL_MAXIMUM                         // should be last
};

struct TrackRulesParticipantV01
{
  // input only
  long mID;                             // slot ID
  short mFrozenOrder;                   // 0-based place when caution came out (not valid for formation laps)
  short mPlace;                         // 1-based place (typically used for the initialization of the formation lap track order)
  float mYellowSeverity;                // a rating of how much this vehicle is contributing to a yellow flag (the sum of all vehicles is compared to TrackRulesV01::mSafetyCarThreshold)
  double mCurrentRelativeDistance;      // equal to ( ( ScoringInfoV01::mLapDist * this->mRelativeLaps ) + VehicleScoringInfoV01::mLapDist )

  // input/output
  long mRelativeLaps;                   // current formation/caution laps relative to safety car (should generally be zero except when safety car crosses s/f line); this can be decremented to implement 'wave around' or 'beneficiary rule' (a.k.a. 'lucky dog' or 'free pass')
  TrackRulesColumnV01 mColumnAssignment;// which column (line/lane) that participant is supposed to be in
  long mPositionAssignment;             // 0-based position within column (line/lane) that participant is supposed to be located at (-1 is invalid)
  unsigned char mPitsOpen;              // whether the rules allow this particular vehicle to enter pits right now (input is 2=false or 3=true; if you want to edit it, set to 0=false or 1=true)
  bool mUpToSpeed;                      // while in the frozen order, this flag indicates whether the vehicle can be followed (this should be false for somebody who has temporarily spun and hasn't gotten back up to speed yet)
  bool mUnused[ 2 ];                    //
  double mGoalRelativeDistance;         // calculated based on where the leader is, and adjusted by the desired column spacing and the column/position assignments
  char mMessage[ 96 ];                  // a message for this participant to explain what is going on (untranslated; it will get run through translator on client machines)

  // future expansion
  unsigned char mExpansion[ 192 ];
};

enum TrackRulesStageV01                 //
{
  TRSTAGE_FORMATION_INIT = 0,           // initialization of the formation lap
  TRSTAGE_FORMATION_UPDATE,             // update of the formation lap
  TRSTAGE_NORMAL,                       // normal (non-yellow) update
  TRSTAGE_CAUTION_INIT,                 // initialization of a full-course yellow
  TRSTAGE_CAUTION_UPDATE,               // update of a full-course yellow
  //------------------
  TRSTAGE_MAXIMUM                       // should be last
};

struct TrackRulesV01
{
  // input only
  double mCurrentET;                    // current time
  TrackRulesStageV01 mStage;            // current stage
  TrackRulesColumnV01 mPoleColumn;      // column assignment where pole position seems to be located
  long mNumActions;                     // number of recent actions
  TrackRulesActionV01 *mAction;         // array of recent actions
  long mNumParticipants;                // number of participants (vehicles)

  bool mYellowFlagDetected;             // whether yellow flag was requested or sum of participant mYellowSeverity's exceeds mSafetyCarThreshold
  unsigned char mYellowFlagLapsWasOverridden;     // whether mYellowFlagLaps (below) is an admin request (0=no 1=yes 2=clear yellow)

  bool mSafetyCarExists;                // whether safety car even exists
  bool mSafetyCarActive;                // whether safety car is active
  long mSafetyCarLaps;                  // number of laps
  float mSafetyCarThreshold;            // the threshold at which a safety car is called out (compared to the sum of TrackRulesParticipantV01::mYellowSeverity for each vehicle)
  double mSafetyCarLapDist;             // safety car lap distance
  float mSafetyCarLapDistAtStart;       // where the safety car starts from

  float mPitLaneStartDist;              // where the waypoint branch to the pits breaks off (this may not be perfectly accurate)
  float mTeleportLapDist;               // the front of the teleport locations (a useful first guess as to where to throw the green flag)

  // future input expansion
  unsigned char mInputExpansion[ 256 ];

  // input/output
  signed char mYellowFlagState;         // see ScoringInfoV01 for values
  short mYellowFlagLaps;                // suggested number of laps to run under yellow (may be passed in with admin command)

  long mSafetyCarInstruction;           // 0=no change, 1=go active, 2=head for pits
  float mSafetyCarSpeed;                // maximum speed at which to drive
  float mSafetyCarMinimumSpacing;       // minimum spacing behind safety car (-1 to indicate no limit)
  float mSafetyCarMaximumSpacing;       // maximum spacing behind safety car (-1 to indicate no limit)

  float mMinimumColumnSpacing;          // minimum desired spacing between vehicles in a column (-1 to indicate indeterminate/unenforced)
  float mMaximumColumnSpacing;          // maximum desired spacing between vehicles in a column (-1 to indicate indeterminate/unenforced)

  float mMinimumSpeed;                  // minimum speed that anybody should be driving (-1 to indicate no limit)
  float mMaximumSpeed;                  // maximum speed that anybody should be driving (-1 to indicate no limit)

  char mMessage[ 96 ];                  // a message for everybody to explain what is going on (which will get run through translator on client machines)
  TrackRulesParticipantV01 *mParticipant;         // array of partipants (vehicles)

  // future input/output expansion
  unsigned char mInputOutputExpansion[ 256 ];
};


struct PitMenuV01
{
  long mCategoryIndex;                  // index of the current category
  char mCategoryName[ 32 ];             // name of the current category (untranslated)

  long mChoiceIndex;                    // index of the current choice (within the current category)
  char mChoiceString[ 32 ];             // name of the current choice (may have some translated words)
  long mNumChoices;                     // total number of choices (0 <= mChoiceIndex < mNumChoices)

  unsigned char mExpansion[ 256 ];      // for future use
};


//#########################################################################
//# Plugin classes used to access internals                                #
//##########################################################################

// Note: use class InternalsPluginV01 and have exported function GetPluginVersion() return 1, or
//       use class InternalsPluginV02 and have exported function GetPluginVersion() return 2, etc.
class InternalsPlugin : public PluginObject
{
 public:

  // General internals methods
  InternalsPlugin() {}
  virtual ~InternalsPlugin() {}

  // GAME FLOW NOTIFICATIONS
  virtual void Startup( long version ) {}                      // sim startup with version * 1000
  virtual void Shutdown() {}                                   // sim shutdown

  virtual void Load() {}                                       // scene/track load
  virtual void Unload() {}                                     // scene/track unload

  virtual void StartSession() {}                               // session started
  virtual void EndSession() {}                                 // session ended

  virtual void EnterRealtime() {}                              // entering realtime (where the vehicle can be driven)
  virtual void ExitRealtime() {}                               // exiting realtime

  // SCORING OUTPUT
  virtual bool WantsScoringUpdates() { return( false ); }      // whether we want scoring updates
  virtual void UpdateScoring( const ScoringInfoV01 &info ) {}  // update plugin with scoring info (approximately five times per second)

  // GAME OUTPUT
  virtual long WantsTelemetryUpdates() { return( 0 ); }        // whether we want telemetry updates (0=no 1=player-only 2=all vehicles)
  virtual void UpdateTelemetry( const TelemInfoV01 &info ) {}  // update plugin with telemetry info

  virtual bool WantsGraphicsUpdates() { return( false ); }     // whether we want graphics updates
  virtual void UpdateGraphics( const GraphicsInfoV01 &info ) {}// update plugin with graphics info

  // COMMENTARY INPUT
  virtual bool RequestCommentary( CommentaryRequestInfoV01 &info ) { return( false ); } // to use our commentary event system, fill in data and return true

  // GAME INPUT
  virtual bool HasHardwareInputs() { return( false ); }        // whether plugin has hardware plugins
  virtual void UpdateHardware( const double fDT ) {}           // update the hardware with the time between frames
  virtual void EnableHardware() {}                             // message from game to enable hardware
  virtual void DisableHardware() {}                            // message from game to disable hardware

  // See if the plugin wants to take over a hardware control.  If the plugin takes over the
  // control, this method returns true and sets the value of the double pointed to by the
  // second arg.  Otherwise, it returns false and leaves the double unmodified.
  virtual bool CheckHWControl( const char * const controlName, double &fRetVal ) { return false; }

  virtual bool ForceFeedback( double &forceValue ) { return( false ); } // alternate force feedback computation - return true if editing the value

  // ERROR FEEDBACK
  virtual void Error( const char * const msg ) {} // Called with explanation message if there was some sort of error in a plugin callback
};


class InternalsPluginV01 : public InternalsPlugin  // Version 01 is the exact same as the original
{
  // REMINDER: exported function GetPluginVersion() should return 1 if you are deriving from this InternalsPluginV01!
};


class InternalsPluginV02 : public InternalsPluginV01  // V02 contains everything from V01 plus the following:
{
  // REMINDER: exported function GetPluginVersion() should return 2 if you are deriving from this InternalsPluginV02!

 public:

  // This function is called occasionally
  virtual void SetPhysicsOptions( PhysicsOptionsV01 &options ) {}
};


class InternalsPluginV03 : public InternalsPluginV02  // V03 contains everything from V02 plus the following:
{
  // REMINDER: exported function GetPluginVersion() should return 3 if you are deriving from this InternalsPluginV03!

 public:

  virtual unsigned char WantsToViewVehicle( CameraControlInfoV01 &camControl ) { return( 0 ); } // return values: 0=do nothing, 1=set ID and camera type, 2=replay controls, 3=both

  // EXTENDED GAME OUTPUT
  virtual void UpdateGraphics( const GraphicsInfoV02 &info )          {} // update plugin with extended graphics info

  // MESSAGE BOX INPUT
  virtual bool WantsToDisplayMessage( MessageInfoV01 &msgInfo )       { return( false ); } // set message and return true
};


class InternalsPluginV04 : public InternalsPluginV03  // V04 contains everything from V03 plus the following:
{
  // REMINDER: exported function GetPluginVersion() should return 4 if you are deriving from this InternalsPluginV04!

 public:

  // EXTENDED GAME FLOW NOTIFICATIONS
  virtual void SetEnvironment( const EnvironmentInfoV01 &info )       {} // may be called whenever the environment changes
};


class InternalsPluginV05 : public InternalsPluginV04  // V05 contains everything from V04 plus the following:
{
  // REMINDER: exported function GetPluginVersion() should return 5 if you are deriving from this InternalsPluginV05!

 public:

  // Note: these callbacks below for ScreenInfoV01 are all deprecated and will no longer be invoked in DX11
  // SCREEN INFO NOTIFICATIONS
  virtual void InitScreen( const ScreenInfoV01 &info )                {} // Now happens right after graphics device initialization
  virtual void UninitScreen( const ScreenInfoV01 &info )              {} // Now happens right before graphics device uninitialization

  virtual void DeactivateScreen( const ScreenInfoV01 &info )          {} // Window deactivation
  virtual void ReactivateScreen( const ScreenInfoV01 &info )          {} // Window reactivation

  virtual void RenderScreenBeforeOverlays( const ScreenInfoV01 &info ){} // before rFactor overlays
  virtual void RenderScreenAfterOverlays( const ScreenInfoV01 &info ) {} // after rFactor overlays

  virtual void PreReset( const ScreenInfoV01 &info )                  {} // after detecting device lost but before resetting
  virtual void PostReset( const ScreenInfoV01 &info )                 {} // after resetting

  // CUSTOM CONTROLS
  virtual bool InitCustomControl( CustomControlInfoV01 &info )        { return( false ); } // called repeatedly at startup until false is returned
};


class InternalsPluginV06 : public InternalsPluginV05  // V06 contains everything from V05 plus the following:
{
  // REMINDER: exported function GetPluginVersion() should return 6 if you are deriving from this InternalsPluginV06!

 public:

  // CONDITIONS CONTROL
  virtual bool WantsWeatherAccess()                                   { return( false ); } // change to true in order to read or write weather with AccessWeather() call:
  virtual bool AccessWeather( double trackNodeSize, WeatherControlInfoV01 &info ) { return( false ); } // current weather is passed in; return true if you want to change it

  // ADDITIONAL GAMEFLOW NOTIFICATIONS
  virtual void ThreadStarted( long type )                             {} // called just after a primary thread is started (type is 0=multimedia or 1=simulation)
  virtual void ThreadStopping( long type )                            {} // called just before a primary thread is stopped (type is 0=multimedia or 1=simulation)
};


class InternalsPluginV07 : public InternalsPluginV06  // V07 contains everything from V06 plus the following:
{
  // REMINDER: exported function GetPluginVersion() should return 7 if you are deriving from this InternalsPluginV07!

 public:

  // CUSTOM PLUGIN VARIABLES
  // This relatively simple feature allows plugins to store settings in a shared location without doing their own
  // file I/O. Direct UI support may also be added in the future so that end users can control plugin settings within
  // rFactor. But for now, users can access the data in UserData\Player\CustomPluginOptions.JSON.
  // Plugins should only access these variables through this interface, though:
  virtual bool GetCustomVariable( long i, CustomVariableV01 &var )   { return( false ); } // At startup, this will be called with increasing index (starting at zero) until false is returned. Feel free to add/remove/rearrange the variables when updating your plugin; the index does not have to be consistent from run to run.
  virtual void AccessCustomVariable( CustomVariableV01 &var )        {}                   // This will be called at startup, shutdown, and any time that the variable is changed (within the UI).
  virtual void GetCustomVariableSetting( CustomVariableV01 &var, long i, CustomSettingV01 &setting ) {} // This gets the name of each possible setting for a given variable.

  // SCORING CONTROL (only available in single-player or on multiplayer server)
  virtual bool WantsMultiSessionRulesAccess()                         { return( false ); } // change to true in order to read or write multi-session rules
  virtual bool AccessMultiSessionRules( MultiSessionRulesV01 &info )  { return( false ); } // current internal rules passed in; return true if you want to change them

  virtual bool WantsTrackRulesAccess()                                { return( false ); } // change to true in order to read or write track order (during formation or caution laps)
  virtual bool AccessTrackRules( TrackRulesV01 &info )                { return( false ); } // current track order passed in; return true if you want to change it (note: this will be called immediately after UpdateScoring() when appropriate)

  // PIT MENU INFO (currently, the only way to edit the pit menu is to use this in conjunction with CheckHWControl())
  virtual bool WantsPitMenuAccess()                                   { return( false ); } // change to true in order to view pit menu info
  virtual bool AccessPitMenu( PitMenuV01 &info )                      { return( false ); } // currently, the return code should always be false (because we may allow more direct editing in the future)
};


class InternalsPluginV08 : public InternalsPluginV07 {
  // REMINDER: exported function GetPluginVersion() should return 8 if you are deriving from this InternalsPluginV08!

public:
  // APPLICATION STATE NOTIFICATIONS
  virtual void InitApplication( const ApplicationStateV01 &state )                {} // Now happens right after graphics device initialization
  virtual void UninitApplication( const ApplicationStateV01 &state )              {} // Now happens right before graphics device uninitialization

  virtual void DeactivateApplication( const ApplicationStateV01 &state )          {} // Application window deactivation
  virtual void ReactivateApplication( const ApplicationStateV01 &state )          {} // Application window reactivation

  virtual void ApplicationRenderBeforeOverlays( const ApplicationStateV01 &state ){} // before rFactor 2 overlays
  virtual void ApplicationRenderAfterOverlays( const ApplicationStateV01 &state ) {} // after rFactor 2 overlays

  virtual void PreResetApplication( const ApplicationStateV01 &state )                  {} // after detecting device lost but before resetting
  virtual void PostResetApplication( const ApplicationStateV01 &state )                 {} // after resetting
};

//#########################################################################
//##########################################################################

// See #pragma at top of file
#pragma pack( pop )

#endif // _INTERNALS_PLUGIN_HPP_


```

# File: src\lmu_sm_interface\InternalsPluginWrapper.h
```cpp
#pragma once

// FIX: LMU Plugin Update 2025
// The official InternalsPlugin.hpp provided by Studio 397 depends on
// PluginObjects.hpp which is missing windows.h.
// We include our wrapper here to ensure dependencies are met.

#include "PluginObjectsWrapper.h"
#include "InternalsPlugin.hpp"

```

# File: src\lmu_sm_interface\LinuxMock.h
```cpp
#ifndef LINUXMOCK_H
#define LINUXMOCK_H

#ifndef _WIN32
#include <chrono>
#include <optional>
#include <cstdint>
#include <cstring>
#include <algorithm>
#include <map>
#include <vector>
#include <string>

// Dummy typedefs for Linux compatibility
using DWORD = uint32_t;
using HANDLE = void*;
using HWND = void*;
using BOOL = int;
using UINT = unsigned int;
using LONG = long;
using SHORT = short;
using VOID = void;
using PVOID = void*;
using UINT_PTR = unsigned long;
using LPARAM = long;
using WPARAM = unsigned long;
using LRESULT = long;
using HRESULT = long;
using WORD = uint16_t;
using BYTE = uint8_t;
using LONG_PTR = intptr_t;

typedef struct _GUID {
    uint32_t Data1;
    uint16_t Data2;
    uint16_t Data3;
    uint8_t Data4[8];
} GUID;

#ifndef __cdecl
#define __cdecl
#endif

#ifndef TRUE
#define TRUE 1
#endif

#ifndef FALSE
#define FALSE 0
#endif

#ifndef NULL
#define NULL 0
#endif

#ifndef MAX_PATH
#define MAX_PATH 260
#endif

// Windows Constants for Mocking
#define INVALID_HANDLE_VALUE ((HANDLE)(UINT_PTR)-1)
#define PAGE_READWRITE 0x04
#define FILE_MAP_ALL_ACCESS 0xF001F
#define FILE_MAP_READ 0x04
#define ERROR_ALREADY_EXISTS 183
#define WAIT_OBJECT_0 0
#define WAIT_FAILED 0xFFFFFFFF
#define INFINITE 0xFFFFFFFF
#define SYNCHRONIZE 0x00100000L
#define PROCESS_QUERY_LIMITED_INFORMATION 0x1000

// Memory Mapping Mock (Global Storage)
namespace MockSM {
    inline std::map<std::string, std::vector<uint8_t>>& GetMaps() {
        static std::map<std::string, std::vector<uint8_t>> maps;
        return maps;
    }
    inline DWORD& LastError() {
        static DWORD err = 0;
        return err;
    }
}

// Interlocked functions for Linux mocking
inline long InterlockedCompareExchange(long volatile* Destination, long Exchange, long Comparand) {
    long old = *Destination;
    if (old == Comparand) *Destination = Exchange;
    return old;
}
inline long InterlockedIncrement(long volatile* Addend) { return ++(*Addend); }
inline long InterlockedDecrement(long volatile* Addend) { return --(*Addend); }
inline long InterlockedExchange(long volatile* Target, long Value) {
    long old = *Target;
    *Target = Value;
    return old;
}

// Memory and Event mocks
inline void YieldProcessor() {}
inline DWORD WaitForSingleObject(HANDLE hHandle, DWORD dwMilliseconds) { return WAIT_OBJECT_0; }
inline BOOL SetEvent(HANDLE hEvent) { return TRUE; }
inline BOOL CloseHandle(HANDLE hObject) {
    if (hObject != (HANDLE)0 && hObject != (HANDLE)1 && hObject != (HANDLE)(intptr_t)-1) {
        // We could delete the string* here, but for mocks it's fine to leak a bit in tests
    }
    return TRUE;
}
inline DWORD GetLastError() { return MockSM::LastError(); }

// Shared Memory Mocks
inline HANDLE CreateFileMappingA(HANDLE hFile, void* lpAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, const char* lpName) {
    if (lpName == nullptr) return (HANDLE)1;
    std::string name(lpName);
    auto& maps = MockSM::GetMaps();
    if (maps.find(name) == maps.end()) {
        maps[name].resize(dwMaximumSizeLow);
        MockSM::LastError() = 0;
    } else {
        MockSM::LastError() = ERROR_ALREADY_EXISTS;
    }
    return (HANDLE)new std::string(name);
}

inline HANDLE OpenFileMappingA(DWORD dwDesiredAccess, BOOL bInheritHandle, const char* lpName) {
    if (lpName == nullptr) return nullptr;
    std::string name(lpName);
    auto& maps = MockSM::GetMaps();
    if (maps.find(name) != maps.end()) {
        return (HANDLE)new std::string(name);
    }
    return nullptr;
}

inline void* MapViewOfFile(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, size_t dwNumberOfBytesToMap) {
    if (hFileMappingObject == (HANDLE)1 || hFileMappingObject == nullptr || hFileMappingObject == INVALID_HANDLE_VALUE) return nullptr;
    std::string* name = (std::string*)hFileMappingObject;
    return MockSM::GetMaps()[*name].data();
}

inline BOOL UnmapViewOfFile(const void* lpBaseAddress) { return TRUE; }
inline HANDLE CreateEventA(void* lpEventAttributes, BOOL bManualReset, BOOL bInitialState, const char* lpName) { return (HANDLE)1; }

// Window mocks
inline HWND GetConsoleWindow() { return (HWND)1; }
inline BOOL IsWindow(HWND hWnd) { return hWnd != nullptr; }

#endif // _WIN32

#endif // LINUXMOCK_H

```

# File: src\lmu_sm_interface\LmuSharedMemoryWrapper.h
```cpp
#pragma once

// FIX: LMU Plugin Update 2025
// The official SharedMemoryInterface.hpp provided by Studio 397 is missing
// several standard library includes required for compilation.
// We include them here BEFORE including the vendor file.

#include <optional>  // Required for std::optional
#include <utility>   // Required for std::exchange, std::swap
#include <cstdint>   // Required for uint32_t, uint8_t
#include <cstring>   // Required for memcpy

#ifndef _WIN32
#include "LinuxMock.h"
#endif

#include "InternalsPluginWrapper.h"

// Include the official vendor file
#include "SharedMemoryInterface.hpp"

```

# File: src\lmu_sm_interface\PluginObjects.hpp
```
//###########################################################################
//#                                                                         #
//# Module: Header file for plugin object types                             #
//#                                                                         #
//# Description: interface declarations for plugin objects                  #
//#                                                                         #
//# This source code module, and all information, data, and algorithms      #
//# associated with it, are part of isiMotor Technology (tm).               #
//#                 PROPRIETARY AND CONFIDENTIAL                            #
//# Copyright (c) 2025 Studio 397 BV and Motorsport Games Inc.              #
//#                                                                         #
//# Change history:                                                         #
//#   tag.2008.02.15: created                                               #
//#                                                                         #
//###########################################################################

#ifndef _PLUGIN_OBJECTS_HPP_
#define _PLUGIN_OBJECTS_HPP_


// rF currently uses 4-byte packing ... whatever the current packing is will
// be restored at the end of this include with another #pragma.
#pragma pack( push, 4 )


//#########################################################################
//# types of plugins                                                       #
//##########################################################################

enum PluginObjectType
{
  PO_INVALID      = -1,
  //-------------------
  PO_GAMESTATS    =  0,
  PO_NCPLUGIN     =  1,
  PO_IVIBE        =  2,
  PO_INTERNALS    =  3,
  PO_RFONLINE     =  4,
  //-------------------
  PO_MAXIMUM
};


//#########################################################################
//#  PluginObject                                                          #
//#    - interface used by plugin classes.                                 #
//##########################################################################

class PluginObject
{
 private:

  class PluginInfo *mInfo;             // used by main executable to obtain info about the plugin that implements this object

 public:

  void SetInfo( class PluginInfo *p )  { mInfo = p; }        // used by main executable
  class PluginInfo *GetInfo() const    { return( mInfo ); }  // used by main executable
  class PluginInfo *GetInfo()          { return( mInfo ); }  // used by main executable
};


//#########################################################################
//# typedefs for dll functions - easier to use a typedef than to type      #
//# out the crazy syntax for declaring and casting function pointers       #
//##########################################################################

typedef const char *      ( __cdecl *GETPLUGINNAME )();
typedef PluginObjectType  ( __cdecl *GETPLUGINTYPE )();
typedef int               ( __cdecl *GETPLUGINVERSION )();
typedef PluginObject *    ( __cdecl *CREATEPLUGINOBJECT )();
typedef void              ( __cdecl *DESTROYPLUGINOBJECT )( PluginObject *obj );


//#########################################################################
//##########################################################################

// See #pragma at top of file
#pragma pack( pop )

#endif // _PLUGIN_OBJECTS_HPP_


```

# File: src\lmu_sm_interface\PluginObjectsWrapper.h
```cpp
#pragma once

// FIX: LMU Plugin Update 2025
// The official PluginObjects.hpp provided by Studio 397 is missing 
// windows.h include which is required for some of the types/definitions used.
// We include it here BEFORE including the vendor file.

#ifdef _WIN32
#include <windows.h>
#else
#include "LinuxMock.h"
#endif

// Include the official vendor file
#include "PluginObjects.hpp"

```

# File: src\lmu_sm_interface\SafeSharedMemoryLock.h
```cpp
#pragma once
#include "LmuSharedMemoryWrapper.h"

// Wrapper for SharedMemoryLock that adds timeout support without modifying vendor code
// This avoids the maintenance burden of modifying the vendor's SharedMemoryInterface.hpp
class SafeSharedMemoryLock {
public:
    // Factory method that returns a SafeSharedMemoryLock wrapper
    static std::optional<SafeSharedMemoryLock> MakeSafeSharedMemoryLock() {
        auto vendorLock = SharedMemoryLock::MakeSharedMemoryLock();
        if (vendorLock.has_value()) {
            return SafeSharedMemoryLock(std::move(vendorLock.value()));
        }
        return std::nullopt;
    }

    // Lock with timeout support - wraps the vendor's Lock() method
    // Returns false if timeout expires or lock acquisition fails
    bool Lock(DWORD timeout_ms = 50) {
        // The vendor implementation already supports timeout parameter
        // We just expose it through our wrapper
        return m_vendorLock.Lock(timeout_ms);
    }

    void Unlock() {
        m_vendorLock.Unlock();
    }

    // Move constructor and assignment to allow std::optional usage
    SafeSharedMemoryLock(SafeSharedMemoryLock&& other) = default;
    SafeSharedMemoryLock& operator=(SafeSharedMemoryLock&& other) = default;

private:
    // Private constructor - use factory method
    explicit SafeSharedMemoryLock(SharedMemoryLock&& vendorLock) 
        : m_vendorLock(std::move(vendorLock)) {}

    SharedMemoryLock m_vendorLock;
};

```

# File: src\lmu_sm_interface\SharedMemoryInterface.hpp
```
#pragma once
#include "InternalsPlugin.hpp"

/*
* Usage example:

int main(int argc, char* argv[])
{
    int retVal = 0;
    if (argc < 2) {
        std::cerr << "Usage: child.exe <LMU-pid>\n";
        return 1;
    }
    // Get the LMU Handle
    DWORD parentPid = 0;
    try {
        parentPid = static_cast<DWORD>(std::stoul(argv[1]));
    }
    catch (...) {
        std::cerr << "Invalid parent PID argument.\n";
        return 1;
    }
    auto smLock = SharedMemoryLock::MakeSharedMemoryLock();
    if (!smLock.has_value()) {
        std::cerr << "Cannot initialize SharedMemoryLock.\n";
        return 1;
    }
    static SharedMemoryObjectOut copiedMem;
    // Try to open a handle to the parent process with SYNCHRONIZE right.
    // SYNCHRONIZE is enough to wait on the process handle for exit.
    HANDLE hParent = OpenProcess(SYNCHRONIZE | PROCESS_QUERY_LIMITED_INFORMATION, FALSE, parentPid);
    HANDLE hEvent = OpenEventA(SYNCHRONIZE, FALSE, "LMU_Data_Event");
    HANDLE hMapFile = OpenFileMapping(FILE_MAP_ALL_ACCESS, FALSE, L"LMU_Data");
    if (hParent && hEvent && hMapFile) {
        if (SharedMemoryLayout* pBuf = (SharedMemoryLayout*)MapViewOfFile(hMapFile, FILE_MAP_ALL_ACCESS, 0, 0, sizeof(SharedMemoryLayout))) {
            HANDLE objectHandlesArray[2] = { hParent, hEvent };
            for (DWORD waitObject = WaitForMultipleObjects(2, objectHandlesArray, FALSE, INFINITE); waitObject != WAIT_OBJECT_0; waitObject = WaitForMultipleObjects(2, objectHandlesArray, FALSE, INFINITE)) {
                if (waitObject == WAIT_OBJECT_0 + 1) {
                    smLock->Lock();
                    CopySharedMemoryObj(copiedMem, pBuf->data);
                    smLock->Unlock();
                    // >>>>> ProcessSharedMemory(copiedMem); <<<<<<
                }
                else {
                    std::cerr << "Wait failed: " << GetLastError() << "\n";
                    break;
                }
            }
            UnmapViewOfFile(pBuf);
        }
        else {
            std::cerr << "Could not map view of file. Error: " << GetLastError() << std::endl;
            retVal = 1;
        }
    }
    else {
        std::cerr << "Something went wrong durin initialization. Error: " << GetLastError() << std::endl;
        retVal = 1;
    }
    if (hMapFile)
        CloseHandle(hMapFile);
    if (hEvent)
        CloseHandle(hEvent);
    if (hParent)
        CloseHandle(hParent);

    return retVal;
}

*/

#ifdef _WIN32
#include <windows.h>
#elif defined(HEADLESS_GUI)
#include "LinuxMock.h"
#endif

#define LMU_SHARED_MEMORY_FILE "LMU_Data"
#define LMU_SHARED_MEMORY_EVENT "LMU_Data_Event"
enum SharedMemoryEvent : uint32_t {
    SME_ENTER,
    SME_EXIT,
    SME_STARTUP,
    SME_SHUTDOWN,
    SME_LOAD,
    SME_UNLOAD,
    SME_START_SESSION,
    SME_END_SESSION,
    SME_ENTER_REALTIME,
    SME_EXIT_REALTIME,
    SME_UPDATE_SCORING,
    SME_UPDATE_TELEMETRY,
    SME_INIT_APPLICATION,
    SME_UNINIT_APPLICATION,
    SME_SET_ENVIRONMENT,
    SME_FFB,
    SME_MAX
};

class SharedMemoryLock {
public:
    static std::optional<SharedMemoryLock> MakeSharedMemoryLock() {
#if defined(_WIN32) || defined(HEADLESS_GUI)
        SharedMemoryLock memoryLock;
        if (memoryLock.Init()) {
            return std::move(memoryLock);
        }
#endif
        return std::nullopt;
    }
    bool Lock(DWORD dwMilliseconds = 0xFFFFFFFF) {
#if defined(_WIN32) || defined(HEADLESS_GUI)
        auto* data = (LockData*)mDataPtr;
        int MAX_SPINS = 4000;
        for (int spins = 0; spins < MAX_SPINS; ++spins) {
            if (InterlockedCompareExchange(&data->busy, 1, 0) == 0)
                return true;
            YieldProcessor(); // CPU pause hint
        }
        InterlockedIncrement(&data->waiters);
        while (true) {
            if (InterlockedCompareExchange(&data->busy, 1, 0) == 0) {
                InterlockedDecrement(&data->waiters);
                return true;
            }
            return WaitForSingleObject(mWaitEventHandle, dwMilliseconds) == 0; // WAIT_OBJECT_0
        }
#else
        return false;
#endif
    }
    void Unlock() {
#if defined(_WIN32) || defined(HEADLESS_GUI)
        auto* data = (LockData*)mDataPtr;
        InterlockedExchange(&data->busy, 0);
        if (data->waiters > 0) {
            SetEvent(mWaitEventHandle);
        }
#endif
    }
    void Reset() {
#if defined(_WIN32) || defined(HEADLESS_GUI)
        auto* data = (LockData*)mDataPtr;
        data->waiters = 0;
        data->busy = 0;
#endif
    }
    ~SharedMemoryLock() {
#if defined(_WIN32) || defined(HEADLESS_GUI)
        if (mWaitEventHandle)
            CloseHandle(mWaitEventHandle);
        if (mMapHandle)
            CloseHandle(mMapHandle);
        if (mDataPtr)
            UnmapViewOfFile(mDataPtr);
#endif
    }
    SharedMemoryLock(SharedMemoryLock&& other) : mMapHandle(std::exchange(other.mMapHandle, nullptr)), mWaitEventHandle(std::exchange(other.mWaitEventHandle, nullptr)) ,
        mDataPtr(std::exchange(other.mDataPtr, nullptr)) {}
    SharedMemoryLock& operator=(SharedMemoryLock&& other) {
        std::swap(mMapHandle, other.mMapHandle);
        std::swap(mWaitEventHandle, other.mWaitEventHandle);
        std::swap(mDataPtr, other.mDataPtr);
        return *this;
    }
private:
#if defined(_WIN32) || defined(HEADLESS_GUI)
    struct LockData {
        volatile LONG waiters;
        volatile LONG busy;
    };
#endif
    SharedMemoryLock() = default;
    bool Init() {
#if defined(_WIN32) || defined(HEADLESS_GUI)
        mMapHandle = CreateFileMappingA(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE, 0, (DWORD)sizeof(LockData), "LMU_SharedMemoryLockData");
        if (!mMapHandle) {
            return false;
        }
        mDataPtr = (LockData*)MapViewOfFile(mMapHandle, FILE_MAP_ALL_ACCESS, 0, 0, sizeof(LockData));
        if (!mDataPtr) {
            CloseHandle(mMapHandle);
            return false;
        }
        if (GetLastError() != ERROR_ALREADY_EXISTS) {
            Reset();
        }
        mWaitEventHandle = CreateEventA(NULL, FALSE, FALSE, "LMU_SharedMemoryLockEvent");
        if (!mWaitEventHandle) {
            UnmapViewOfFile(mDataPtr);
            CloseHandle(mMapHandle);
            return false;
        }
        return true;
#else
        return false;
#endif
    }
    HANDLE mMapHandle = NULL;
    HANDLE mWaitEventHandle = NULL;
    void* mDataPtr = nullptr;
};

struct SharedMemoryScoringData { // Remember to check CopySharedMemoryObj still works properly when updating this struct
    ScoringInfoV01 scoringInfo;
    size_t scoringStreamSize;
    VehicleScoringInfoV01 vehScoringInfo[104]; // MUST NOT BE MOVED!
    char scoringStream[65536];
};

struct SharedMemoryTelemtryData { // Remember to check CopySharedMemoryObj still works properly when updating this struct
    uint8_t activeVehicles;
    uint8_t playerVehicleIdx;
    bool playerHasVehicle;
    TelemInfoV01 telemInfo[104];
};

struct SharedMemoryPathData {
    char userData[MAX_PATH];
    char customVariables[MAX_PATH];
    char stewardResults[MAX_PATH];
    char playerProfile[MAX_PATH];
    char pluginsFolder[MAX_PATH];
};

struct SharedMemoryGeneric {
    SharedMemoryEvent events[SharedMemoryEvent::SME_MAX];
    long gameVersion;
    float FFBTorque;
    ApplicationStateV01 appInfo;
};

struct SharedMemoryObjectOut { // Remember to check CopySharedMemoryObj still works properly when updating this struct
    SharedMemoryGeneric generic;
    SharedMemoryPathData paths;
    SharedMemoryScoringData scoring;
    SharedMemoryTelemtryData telemetry;
};

struct SharedMemoryLayout {
    SharedMemoryObjectOut data;
};

static void CopySharedMemoryObj(SharedMemoryObjectOut& dst, SharedMemoryObjectOut& src) {
    memcpy(&dst.generic, &src.generic, sizeof(SharedMemoryGeneric));
    if (src.generic.events[SME_UPDATE_SCORING]) {
        memcpy(&dst.scoring.scoringInfo, &src.scoring.scoringInfo, sizeof(ScoringInfoV01));
        memcpy(&dst.scoring.vehScoringInfo, &src.scoring.vehScoringInfo, src.scoring.scoringInfo.mNumVehicles * sizeof(VehicleScoringInfoV01));
        memcpy(&dst.scoring.scoringStream, &src.scoring.scoringStream, src.scoring.scoringStreamSize);
        dst.scoring.scoringStreamSize = src.scoring.scoringStreamSize;
        dst.scoring.scoringStream[dst.scoring.scoringStreamSize] = '\0';
        dst.scoring.scoringInfo.mVehicle = &dst.scoring.vehScoringInfo[0];
        dst.scoring.scoringInfo.mResultsStream = &dst.scoring.scoringStream[0];
    }
    if (src.generic.events[SME_UPDATE_TELEMETRY]) {
        dst.telemetry.activeVehicles = src.telemetry.activeVehicles;
        dst.telemetry.playerHasVehicle = src.telemetry.playerHasVehicle;
        dst.telemetry.playerVehicleIdx = src.telemetry.playerVehicleIdx;
        memcpy(&dst.telemetry.telemInfo, &src.telemetry.telemInfo, src.telemetry.activeVehicles * sizeof(TelemInfoV01));
    }
    if (src.generic.events[SME_ENTER] || src.generic.events[SME_EXIT] || src.generic.events[SME_SET_ENVIRONMENT]) {
        memcpy(&dst.paths, &src.paths, sizeof(SharedMemoryPathData));
    }
}
```

# File: src\lmu_sm_interface\linux_mock\windows.h
```cpp
#ifndef WINDOWS_H_MOCK
#define WINDOWS_H_MOCK

#include "../LinuxMock.h"

// Any additional Windows-specific macros needed by ISI headers
#ifndef CALLBACK
#define CALLBACK __cdecl
#endif

#ifndef WINAPI
#define WINAPI __cdecl
#endif

#endif // WINDOWS_H_MOCK

```

# File: src\rF2\rF2Data.h
```cpp
#ifndef RF2DATA_H
#define RF2DATA_H

#include <cstdint>

// rFactor 2 Telemetry Data Structures
// Based on The Iron Wolf's rF2SharedMemoryMapPlugin and rFactor 2 SDK

// Ensure strict alignment if necessary, but standard rF2 SDK usually works with default packing.
// However, the Shared Memory Plugin might align things specifically.
// We will use standard alignment matching the Python definition (which used native).
// Usually in C++ on Windows x64, doubles are 8-byte aligned.

#pragma pack(push, 4) // rFactor 2 often uses 4-byte packing for some legacy reasons, or default. 
// We will assume default packing for now, but if offsets are off, we might need #pragma pack(push, 1) or 4.
// Looking at the Python struct, we didn't specify _pack_, so it used native.
// Let's use standard layout.

struct rF2Vec3 {
    double x;
    double y;
    double z;
};

struct rF2Wheel {
    double mSuspensionDeflection;
    double mRideHeight;
    double mSuspForce;
    double mBrakeTemp;
    double mBrakePressure;
    double mRotation;
    double mLateralPatchVel;
    double mLongitudinalPatchVel;
    double mLateralGroundVel;
    double mLongitudinalGroundVel;
    double mCamber;
    double mLateralForce;
    double mLongitudinalForce;
    double mTireLoad;
    double mGripFract;
    double mPressure;
    double mTemperature[3]; // Inner, Middle, Outer
    double mWear;
    char mTerrainName[16];
    unsigned char mSurfaceType;
    unsigned char mFlat;
    unsigned char mDetached;
    unsigned char mPadding[5]; // Align next double? Python handled this automatically.
                               // In Python ctypes: c_byte, c_byte, c_byte follow each other.
                               // Then c_double starts. on x64, double aligns to 8.
                               // 16 + 1 + 1 + 1 = 19. Next double at 24. Padding = 5.
    
    double mStaticCamber;
    double mToeIn;
    double mTireRadius;
    double mVerticalTireDeflection;
    double mWheelYLocation;
    double mToe;
    double mCaster;
    double mHAngle;
    double mVAngle;
    double mSlipAngle;
    double mSlipRatio;
    double mMaxSlipAngle;
    double mMaxLatGrip;
};

struct rF2Telemetry {
    double mTime;
    double mDeltaTime;
    double mElapsedTime;
    int mLapNumber;
    double mLapStartET;
    char mVehicleName[64];
    char mTrackName[64];
    rF2Vec3 mPos;
    rF2Vec3 mLocalVel;
    rF2Vec3 mLocalAccel;
    rF2Vec3 mOri[3]; // [3][3] rotation matrix rows/cols? Usually 3 vectors.
    rF2Vec3 mLocalRot;
    rF2Vec3 mLocalRotAccel;
    double mSpeed;
    double mEngineRPM;
    double mEngineWaterTemp;
    double mEngineOilTemp;
    double mClutchRPM;
    double mUnfilteredThrottle;
    double mUnfilteredBrake;
    double mUnfilteredSteering;
    double mUnfilteredClutch;
    double mSteeringArmForce;
    double mFuel;
    double mEngineMaxRPM;
    unsigned char mScheduledStops;
    unsigned char mOverheating;
    unsigned char mDetached;
    unsigned char mHeadlights;
    // Padding to align int?
    // 4 chars = 4 bytes. Next is int (4 bytes). Aligned.
    int mGear;
    int mNumGears;
    // Next is rF2Wheel which starts with double (8 bytes).
    // Current pos: int(4) + int(4) = 8. Aligned.
    
    rF2Wheel mWheels[4]; // FL, FR, RL, RR
};

#pragma pack(pop)

#endif // RF2DATA_H

```

# File: tests\CMakeLists.txt
```cmake
﻿cmake_minimum_required(VERSION 3.10)
project(LMUFFB_Tests)

set(CMAKE_CXX_STANDARD 17)


# Include main source dir for headers
include_directories(..)
include_directories(../src)
include_directories(${CMAKE_BINARY_DIR})
include_directories(${CMAKE_BINARY_DIR}/src)

if(NOT WIN32)
    include_directories(linux_mock)
    include_directories(../src/lmu_sm_interface/linux_mock)
    include_directories(../src/lmu_sm_interface)
endif()

# Combined Test Executable
set(TEST_SOURCES 
    main_test_runner.cpp 
    test_ffb_accuracy_tools.cpp
    test_ffb_advanced_slope.cpp
    test_ffb_slope_edge_cases.cpp
    test_ffb_common.cpp
    test_ffb_core_physics.cpp
    test_ffb_slope_detection.cpp
    test_ffb_slope_fix.cpp
    test_ffb_understeer.cpp
    test_ffb_smoothstep.cpp
    test_ffb_smoothing.cpp
    test_ffb_yaw_gyro.cpp
    test_ffb_coordinates.cpp
    test_ffb_features.cpp
    test_ffb_road_texture.cpp
    test_ffb_lockup_braking.cpp
    test_ffb_config.cpp
    test_ffb_slip_grip.cpp
    test_ffb_internal.cpp
    test_ffb_coverage_refactor.cpp
    test_persistence_v0625.cpp
    test_persistence_v0628.cpp
    test_async_logger.cpp
    test_ffb_load_normalization.cpp
    test_versioned_presets.cpp
    test_preset_improvements.cpp
    test_ffb_stability.cpp
    test_gui_tooltips_presence.cpp
    test_ffb_logic.cpp
    test_ffb_safety.cpp
    test_issue_100_timing.cpp
    test_issue_104_slope_disconnect.cpp
    test_ffb_dynamic_weight.cpp
    test_rate_monitor.cpp
    test_math_utils.cpp
    test_perf_stats.cpp
    test_vehicle_utils.cpp
    test_coverage_boost.cpp
    test_ffb_coverage_target.cpp
)

# ImGui Core is now always available if vendor exists

if(IMGUI_CORE_SOURCES)
    list(APPEND TEST_SOURCES
        test_gui_interaction.cpp
    )
endif()

if(WIN32)
    list(APPEND TEST_SOURCES 
        test_windows_platform.cpp 
        test_security_metadata.cpp
        ${CMAKE_BINARY_DIR}/src/res.rc
    )
else()
    # On Linux, backend file is in LMUFFB_Core
    if(BUILD_HEADLESS)
        add_definitions(-DHEADLESS_GUI)
        # Enable some Windows-style tests on Linux using mocks
        list(APPEND TEST_SOURCES test_windows_platform.cpp)
    endif()
endif()

enable_testing()
add_executable(run_combined_tests ${TEST_SOURCES})
target_compile_definitions(run_combined_tests PRIVATE HEADLESS_GUI)
target_link_libraries(run_combined_tests PRIVATE LMUFFB_Core)

if(WIN32)
    target_link_libraries(run_combined_tests PRIVATE version imm32 dxgi)
endif()

# Add to CTest
add_test(NAME CombinedTests COMMAND run_combined_tests)


```

# File: tests\main_test_runner.cpp
```cpp
#include <iostream>
#include <atomic>
#include <mutex>
#include <cstdio>
#include <thread>
#include <chrono>
#include <filesystem>
#include "src/Config.h"

#ifdef _WIN32
#include <windows.h>
#endif

// Shared globals required by GuiLayer
std::atomic<bool> g_running(true);
std::mutex g_engine_mutex;

namespace FFBEngineTests { 
    extern int g_tests_passed; 
    extern int g_tests_failed; 
    extern int g_test_cases_run;
    extern int g_test_cases_passed;
    extern int g_test_cases_failed;
    void Run();
    void ParseTagArguments(int argc, char* argv[]);
}

int main(int argc, char* argv[]) {
    // Parse tag filtering arguments
    FFBEngineTests::ParseTagArguments(argc, argv);
    
    int total_passed = 0;
    int total_failed = 0;

    // Redirect config to a test-specific file to avoid overwriting user settings
    Config::m_config_path = "test_config_runner.ini";
    std::remove(Config::m_config_path.c_str());
    std::remove("imgui.ini");

    // --- Unified Test Suite Execution ---
    // All tests (including Windows-specific ones if compiled) are now auto-registered
    try {
        FFBEngineTests::Run();
        total_passed = FFBEngineTests::g_tests_passed;
        total_failed = FFBEngineTests::g_tests_failed;
    } catch (const std::exception& e) {
        std::cout << "\n[FATAL] Test Runner encountered unhandled exception: " << e.what() << std::endl;
        total_failed++;
    } catch (...) {
        std::cout << "\n[FATAL] Test Runner encountered unknown exception" << std::endl;
        total_failed++;
    }

    std::cout << "\n==============================================" << std::endl;
    std::cout << "           COMBINED TEST SUMMARY              " << std::endl;
    std::cout << "==============================================" << std::endl;
    std::cout << "  TEST CASES   : " << FFBEngineTests::g_test_cases_passed << "/" << FFBEngineTests::g_test_cases_run << std::endl;
    std::cout << "  ASSERTIONS   : " << total_passed << " passed, " << total_failed << " failed" << std::endl;
    std::cout << "==============================================" << std::endl;

    // Ensure output is visible on Windows before console closes
    std::cout << std::flush;
    std::this_thread::sleep_for(std::chrono::milliseconds(50));

    // Robust cleanup of test artifacts
    auto cleanup = []() {
        std::vector<std::string> to_remove = {
            Config::m_config_path,
            "test_persistence.ini", "test_config_win.ini", "test_config_top.ini",
            "test_config_preset_temp.ini", "test_config_brake.ini", "test_config_sg.ini",
            "test_config_ap.ini", "test_version.ini", "roundtrip.ini",
            "test_clamp.ini", "test_isolation.ini", "test_order.ini",
            "test_legacy.ini", "test_comments.ini", "imgui.ini",
            "config.ini", "test_config_runner.ini", "test_val.ini",
            "test_stability.ini", "tmp_invalid.ini", "test_config.ini",
            "test_preset_persistence.ini", "test_preservation.ini",
            "test_global_save.ini", "test_config_logic_window.ini",
            "test_config_logic_brake.ini", "test_config_logic_legacy.ini",
            "test_config_logic_legacy_slope.ini", "test_config_logic_legacy_slope_min.ini",
            "test_slope_config.ini", "test_slope_minmax.ini", "test_slope_migration.ini",
            "test_config_logic_guid.ini", "test_config_logic_top.ini", "test_config_logic_preset.ini",
            "tmp_unsafe_config_test.ini", "test_export_preset.ini", "collision_test.ini",
            "test_bad_config.ini", "test_version_presets.ini", "test_legacy_presets.ini"
        };

        for (const auto& file : to_remove) {
            try {
                if (!file.empty() && std::filesystem::exists(file)) {
                    std::filesystem::remove(file);
                }
            } catch (...) {}
        }

        try {
            if (std::filesystem::exists("test_logs")) {
                std::filesystem::remove_all("test_logs");
            }
        } catch (...) {}
    };

    cleanup();

    return (total_failed > 0) ? 1 : 0;
}

```

# File: tests\test_ffb_common.cpp
```cpp
#include "test_ffb_common.h"

namespace FFBEngineTests {

// --- Global Test Counters ---
int g_tests_passed = 0;
int g_tests_failed = 0;
int g_test_cases_run = 0;
int g_test_cases_passed = 0;
int g_test_cases_failed = 0;

// --- Tag Filtering Globals ---
std::vector<std::string> g_tag_filter;
std::vector<std::string> g_tag_exclude;
std::vector<std::string> g_category_filter;
bool g_enable_tag_filtering = false;

// --- Helper: Parse Command Line Arguments ---
void ParseTagArguments(int argc, char* argv[]) {
    for (int i = 1; i < argc; i++) {
        std::string arg = argv[i];
        
        // --tag=Physics,Math
        if (arg.find("--tag=") == 0) {
            g_enable_tag_filtering = true;
            std::string tags_str = arg.substr(6);
            std::stringstream ss(tags_str);
            std::string tag;
            while (std::getline(ss, tag, ',')) {
                g_tag_filter.push_back(tag);
            }
        }
        // --exclude=Performance
        else if (arg.find("--exclude=") == 0) {
            g_enable_tag_filtering = true;
            std::string tags_str = arg.substr(10);
            std::stringstream ss(tags_str);
            std::string tag;
            while (std::getline(ss, tag, ',')) {
                g_tag_exclude.push_back(tag);
            }
        }
        // --category=CorePhysics,SlipGrip
        else if (arg.find("--category=") == 0) {
            g_enable_tag_filtering = true;
            std::string cats_str = arg.substr(11);
            std::stringstream ss(cats_str);
            std::string cat;
            while (std::getline(ss, cat, ',')) {
                g_category_filter.push_back(cat);
            }
        }
        // --help
        else if (arg == "--help" || arg == "-h") {
            std::cout << "\nLMUFFB Test Suite - Tag Filtering\n";
            std::cout << "==================================\n\n";
            std::cout << "Usage: run_combined_tests.exe [options]\n\n";
            std::cout << "Options:\n";
            std::cout << "  --tag=TAG1,TAG2       Run only tests with specified tags (OR logic)\n";
            std::cout << "  --exclude=TAG1,TAG2   Exclude tests with specified tags\n";
            std::cout << "  --category=CAT1,CAT2  Run only specified test categories\n";
            std::cout << "  --help, -h            Show this help message\n\n";
            std::cout << "Available Tags:\n";
            std::cout << "  Functional: Physics, Math, Integration, Config, Regression, Edge, Performance\n";
            std::cout << "  Component: SoP, Slope, Texture, Grip, Coordinates, Smoothing\n\n";
            std::cout << "Available Categories:\n";
            std::cout << "  CorePhysics, SlipGrip, Understeer, SlopeDetection, Texture,\n";
            std::cout << "  YawGyro, Coordinates, Config, SpeedGate, Internal\n\n";
            std::cout << "Examples:\n";
            std::cout << "  run_combined_tests.exe --tag=Physics\n";
            std::cout << "  run_combined_tests.exe --tag=Physics,Regression\n";
            std::cout << "  run_combined_tests.exe --exclude=Performance\n";
            std::cout << "  run_combined_tests.exe --category=CorePhysics,SlipGrip\n\n";
            std::cout << "For more information, see: docs/dev_docs/test_tagging_system.md\n\n";
            exit(0);
        }
    }
    
    // Print active filters
    if (g_enable_tag_filtering) {
        std::cout << "\n=== Tag Filtering Active ===\n";
        if (!g_tag_filter.empty()) {
            std::cout << "Include Tags: ";
            for (size_t i = 0; i < g_tag_filter.size(); i++) {
                std::cout << g_tag_filter[i];
                if (i < g_tag_filter.size() - 1) std::cout << ", ";
            }
            std::cout << "\n";
        }
        if (!g_tag_exclude.empty()) {
            std::cout << "Exclude Tags: ";
            for (size_t i = 0; i < g_tag_exclude.size(); i++) {
                std::cout << g_tag_exclude[i];
                if (i < g_tag_exclude.size() - 1) std::cout << ", ";
            }
            std::cout << "\n";
        }
        if (!g_category_filter.empty()) {
            std::cout << "Categories: ";
            for (size_t i = 0; i < g_category_filter.size(); i++) {
                std::cout << g_category_filter[i];
                if (i < g_category_filter.size() - 1) std::cout << ", ";
            }
            std::cout << "\n";
        }
        std::cout << "============================\n";
    }
}


// --- Helper: Create Basic Test Telemetry ---
TelemInfoV01 CreateBasicTestTelemetry(double speed, double slip_angle) {
    TelemInfoV01 data;
    std::memset(&data, 0, sizeof(data));
    data.mDeltaTime = 0.0025;
    
    // Time
    data.mDeltaTime = 0.01; // 100Hz
    
    // Velocity
    data.mLocalVel.z = -speed; // Game uses -Z for forward
    
    // Wheel setup (all 4 wheels)
    for (int i = 0; i < 4; i++) {
        data.mWheel[i].mGripFract = 0.0; // Trigger approximation mode
        data.mWheel[i].mTireLoad = 4000.0; // Realistic load
        data.mWheel[i].mStaticUndeflectedRadius = 30; // 0.3m radius
        data.mWheel[i].mRotation = speed * 3.33f; // Match speed (rad/s)
        data.mWheel[i].mLongitudinalGroundVel = speed;
        data.mWheel[i].mLateralPatchVel = slip_angle * speed; // Convert to m/s
        data.mWheel[i].mBrakePressure = 1.0; // Default for tests (v0.6.0)
        data.mWheel[i].mSuspForce = 4000.0; // Grounded (v0.6.0)
        data.mWheel[i].mVerticalTireDeflection = 0.001; // Avoid "missing data" warning (v0.6.21)
    }
    
    return data;
}

// --- Helper: Initialize Engine with Test Defaults ---
void InitializeEngine(FFBEngine& engine) {
    Preset::ApplyDefaultsToEngine(engine);
    // v0.5.12: Force consistent baseline for legacy tests
    engine.m_max_torque_ref = 20.0f;
    engine.m_invert_force = false;
    
    // v0.6.31: Zero out all auxiliary effects for clean physics testing by default.
    // Individual tests can re-enable what they need.
    engine.m_steering_shaft_smoothing = 0.0f; 
    engine.m_slip_angle_smoothing = 0.0f;
    engine.m_sop_smoothing_factor = 1.0f; // 1.0 = Instant/No smoothing
    engine.m_yaw_accel_smoothing = 0.0f;
    engine.m_gyro_smoothing = 0.0f;
    engine.m_chassis_inertia_smoothing = 0.0f;
    engine.m_dynamic_weight_smoothing = 0.0f;
    engine.m_grip_smoothing_steady = 0.0f;
    engine.m_grip_smoothing_fast = 0.0f;
    engine.m_grip_smoothing_sensitivity = 1.0f;
    
    engine.m_sop_effect = 0.0f;
    engine.m_sop_yaw_gain = 0.0f;
    engine.m_oversteer_boost = 0.0f;
    engine.m_rear_align_effect = 0.0f;
    engine.m_gyro_gain = 0.0f;
    
    engine.m_slide_texture_enabled = false;
    engine.m_road_texture_enabled = false;
    engine.m_lockup_enabled = false;
    engine.m_spin_enabled = false;
    engine.m_abs_pulse_enabled = false;
    engine.m_scrub_drag_gain = 0.0f;
    engine.m_min_force = 0.0f;
    
    // v0.6.25: Disable speed gate by default for legacy tests (avoids muting physics at 0 speed)
    engine.m_speed_gate_lower = -10.0f;
    engine.m_speed_gate_upper = -5.0f;
}

// ============================================================
// Auto-Registration Implementation
// ============================================================

// Category ordering for consistent output
static const std::vector<std::string> CATEGORY_ORDER = {
    "CorePhysics", "SlopeDetection", "Understeer", "SpeedGate",
    "YawGyro", "Coordinates", "RoadTexture", "Texture",
    "LockupBraking", "Config", "SlipGrip", "Internal",
    "Windows", "Screenshot", "Persistence", "GUI"
};

static int GetCategoryOrder(const std::string& cat) {
    auto it = std::find(CATEGORY_ORDER.begin(), CATEGORY_ORDER.end(), cat);
    if (it != CATEGORY_ORDER.end()) {
        return static_cast<int>(std::distance(CATEGORY_ORDER.begin(), it));
    }
    return 999; // Unknown categories go last
}

TestRegistry& TestRegistry::Instance() {
    static TestRegistry instance;
    return instance;
}

void TestRegistry::Register(const std::string& name, 
                            const std::string& category,
                            const std::vector<std::string>& tags,
                            std::function<void()> func,
                            int order) {
    m_tests.push_back({name, category, tags, func, order});
}

void TestRegistry::SortByCategory() {
    if (m_sorted) return;
    std::stable_sort(m_tests.begin(), m_tests.end(), 
        [](const TestEntry& a, const TestEntry& b) {
            int orderA = GetCategoryOrder(a.category);
            int orderB = GetCategoryOrder(b.category);
            if (orderA != orderB) return orderA < orderB;
            return a.order_hint < b.order_hint;
        });
    m_sorted = true;
}

const std::vector<TestEntry>& TestRegistry::GetTests() const {
    return m_tests;
}

AutoRegister::AutoRegister(const std::string& name, 
                           const std::string& category, 
                           const std::vector<std::string>& tags,
                           std::function<void()> func,
                           int order) {
    TestRegistry::Instance().Register(name, category, tags, func, order);
}

void Run() {
    std::cout << "\n--- FFTEngine Regression Suite ---" << std::endl;
    
    // Auto-Registered Tests
    auto& registry = TestRegistry::Instance();
    if (!registry.GetTests().empty()) {
        registry.SortByCategory();
        auto& tests = registry.GetTests();
        
        std::cout << "\n--- Auto-Registered Tests (" << tests.size() << ") ---" << std::endl;
        
        std::string current_category;
        for (const auto& test : tests) {
            if (test.category != current_category) {
                current_category = test.category;
                std::cout << "\n=== " << current_category << " Tests ===" << std::endl;
            }
            
            if (!ShouldRunTest(test.tags, test.category)) continue;

            try {
                int initial_fails = g_tests_failed;
                test.func();

                g_test_cases_run++;
                if (g_tests_failed > initial_fails) {
                    g_test_cases_failed++;
                } else {
                    g_test_cases_passed++;
                }
            } catch (const std::exception& e) {
                std::cout << "[FAIL] " << test.name << " threw exception: " << e.what() << std::endl;
                g_tests_failed++;
                g_test_cases_run++;
                g_test_cases_failed++;
            } catch (...) {
                std::cout << "[FAIL] " << test.name << " threw unknown exception" << std::endl;
                g_tests_failed++;
                g_test_cases_run++;
                g_test_cases_failed++;
            }
        }
    }

    std::cout << "\n--- Physics Engine Test Summary ---" << std::endl;
    std::cout << "Test Cases: " << g_test_cases_passed << "/" << g_test_cases_run << " passed" << std::endl;
    std::cout << "Assertions: " << g_tests_passed << " passed, " << g_tests_failed << " failed" << std::endl;
}

} // namespace FFBEngineTests
```

# File: tests\test_ffb_common.h
```cpp
// test_ffb_common.h
#pragma once

#include <iostream>
#include <vector>
#include <string>
#include <cmath>
#include <cstring>
#include <algorithm>
#include <fstream>
#include <cstdio>
#include <random>
#include <sstream>
#include <functional>

#include "../src/FFBEngine.h"
#include "../src/lmu_sm_interface/InternalsPlugin.hpp"
#include "../src/lmu_sm_interface/LmuSharedMemoryWrapper.h"
#include "../src/Config.h"

namespace FFBEngineTests {

// --- Test Counters (defined in test_ffb_common.cpp) ---
extern int g_tests_passed;
extern int g_tests_failed;
extern int g_test_cases_run;
extern int g_test_cases_passed;
extern int g_test_cases_failed;

// --- Assert Macros ---
#define ASSERT_TRUE(condition) \
    if (condition) { \
        std::cout << "[PASS] " << #condition << std::endl; \
        g_tests_passed++; \
    } else { \
        std::cout << "[FAIL] " << #condition << " (" << __FILE__ << ":" << __LINE__ << ")" << std::endl; \
        g_tests_failed++; \
    }

#define ASSERT_FALSE(condition) \
    if (!(condition)) { \
        std::cout << "[PASS] !" << #condition << std::endl; \
        g_tests_passed++; \
    } else { \
        std::cout << "[FAIL] !" << #condition << " (" << __FILE__ << ":" << __LINE__ << ")" << std::endl; \
        g_tests_failed++; \
    }

#define ASSERT_NEAR(a, b, epsilon) \
    if (std::abs((a) - (b)) < (epsilon)) { \
        std::cout << "[PASS] " << #a << " approx " << #b << std::endl; \
        g_tests_passed++; \
    } else { \
        std::cout << "[FAIL] " << #a << " (" << (a) << ") != " << #b << " (" << (b) << ")" << std::endl; \
        g_tests_failed++; \
    }

#define ASSERT_GT(a, b) \
    if ((a) > (b)) { \
        std::cout << "[PASS] " << #a << " > " << #b << std::endl; \
        g_tests_passed++; \
    } else { \
        std::cout << "[FAIL] " << #a << " (" << (a) << ") <= " << #b << " (" << (b) << ")" << std::endl; \
        g_tests_failed++; \
    }

#define ASSERT_EQ(a, b) \
    if ((a) == (b)) { \
        std::cout << "[PASS] " << #a << " == " << #b << std::endl; \
        g_tests_passed++; \
    } else { \
        std::cout << "[FAIL] " << #a << " (" << (a) << ") != " << #b << " (" << (b) << ")" << std::endl; \
        g_tests_failed++; \
    }

#define ASSERT_GE(a, b) \
    if ((a) >= (b)) { \
        std::cout << "[PASS] " << #a << " >= " << #b << std::endl; \
        g_tests_passed++; \
    } else { \
        std::cout << "[FAIL] " << #a << " (" << (a) << ") < " << #b << " (" << (b) << ")" << std::endl; \
        g_tests_failed++; \
    }

#define ASSERT_LE(a, b) \
    if ((a) <= (b)) { \
        std::cout << "[PASS] " << #a << " <= " << #b << std::endl; \
        g_tests_passed++; \
    } else { \
        std::cout << "[FAIL] " << #a << " (" << (a) << ") > " << #b << " (" << (b) << ")" << std::endl; \
        g_tests_failed++; \
    }

#define ASSERT_EQ_STR(a, b) \
    if (std::string(a) == std::string(b)) { \
        std::cout << "[PASS] " << #a << " == " << #b << std::endl; \
        g_tests_passed++; \
    } else { \
        std::cout << "[FAIL] " << #a << " (" << a << ") != " << #b << " (" << b << ")" << std::endl; \
        g_tests_failed++; \
    }

// --- Test Constants ---
const int FILTER_SETTLING_FRAMES = 40;

// --- Test Tagging System ---
// Global tag filter (set via command line arguments)
extern std::vector<std::string> g_tag_filter;
extern std::vector<std::string> g_tag_exclude;
extern std::vector<std::string> g_category_filter;
extern bool g_enable_tag_filtering;

// Tag checking helper
inline bool ShouldRunTest(const std::vector<std::string>& test_tags, const std::string& category) {
    if (!g_enable_tag_filtering) return true;
    
    // Category filter (if specified)
    if (!g_category_filter.empty()) {
        bool category_match = false;
        for (const auto& cat : g_category_filter) {
            if (cat == category) {
                category_match = true;
                break;
            }
        }
        if (!category_match) return false;
    }
    
    // Tag exclude filter (if specified)
    if (!g_tag_exclude.empty()) {
        for (const auto& exclude_tag : g_tag_exclude) {
            for (const auto& test_tag : test_tags) {
                if (test_tag == exclude_tag) return false;
            }
        }
    }
    
    // Tag include filter (if specified)
    if (!g_tag_filter.empty()) {
        for (const auto& filter_tag : g_tag_filter) {
            for (const auto& test_tag : test_tags) {
                if (test_tag == filter_tag) return true;
            }
        }
        return false; // No matching tags found
    }
    
    return true; // No filters, run all tests
}

// Parse command line arguments for tag filtering
void ParseTagArguments(int argc, char* argv[]);

// --- Helper Functions ---
TelemInfoV01 CreateBasicTestTelemetry(double speed = 20.0, double slip_angle = 0.0);
void InitializeEngine(FFBEngine& engine);


void Run(); // Main runner

// --- Friend Access for Testing ---
class FFBEngineTestAccess {
public:
    static bool HasWarnings(const FFBEngine& engine) {
        return engine.m_warned_load || engine.m_warned_grip || engine.m_warned_dt;
    }
    static void test_unit_sop_lateral();
    static void test_unit_gyro_damping();
    static void test_unit_abs_pulse();

    // Load Normalization Test Access
    static double GetAutoPeakLoad(const FFBEngine& e) { return e.m_auto_peak_load; }
    static void SetAutoPeakLoad(FFBEngine& e, double val) { e.m_auto_peak_load = val; }
    static void SetAutoNormalizationEnabled(FFBEngine& e, bool enabled) { e.m_auto_load_normalization_enabled = enabled; }

    // Smoothing Test Access
    static double GetDynamicWeightSmoothed(const FFBEngine& e) { return e.m_dynamic_weight_smoothed; }
    static void SetDynamicWeightSmoothed(FFBEngine& e, double val) { e.m_dynamic_weight_smoothed = val; }
    static double GetFrontGripSmoothedState(const FFBEngine& e) { return e.m_front_grip_smoothed_state; }
    static void SetFrontGripSmoothedState(FFBEngine& e, double val) { e.m_front_grip_smoothed_state = val; }
    static void SetStaticFrontLoad(FFBEngine& e, double val) { e.m_static_front_load = val; }
    static double GetStaticFrontLoad(const FFBEngine& e) { return e.m_static_front_load; }
    // Wrappers for extracted utilities removed. Tests invoke them directly.
    static void SetSlopeDetectionEnabled(FFBEngine& e, bool val) { e.m_slope_detection_enabled = val; }
    static void SetSlopeBufferIndex(FFBEngine& e, int idx) { e.m_slope_buffer_index = idx; }
    static void SetSlopeBuffer(FFBEngine& e, const std::array<double, 41>& lat_g) { e.m_slope_lat_g_buffer = lat_g; }
    static void SetSlopeBufferCount(FFBEngine& e, int count) { e.m_slope_buffer_count = count; }
    static void SetSlopeTorqueBuffer(FFBEngine& e, const std::array<double, 41>& torque) { e.m_slope_torque_buffer = torque; }
    static void SetSlopeSteerBuffer(FFBEngine& e, const std::array<double, 41>& steer) { e.m_slope_steer_buffer = steer; }
    static void SetSlopeSlipBuffer(FFBEngine& e, const std::array<double, 41>& slip) { e.m_slope_slip_buffer = slip; }
    static void SetSlopeUseTorque(FFBEngine& e, bool val) { e.m_slope_use_torque = val; }
    static double CallCalculateSlopeGrip(FFBEngine& e, double lat_g, double slip, double dt, const TelemInfoV01* data) {
        return e.calculate_slope_grip(lat_g, slip, dt, data);
    }
    static double CallApplySignalConditioning(FFBEngine& e, double raw_torque, const TelemInfoV01* data, FFBCalculationContext& ctx) {
        return e.apply_signal_conditioning(raw_torque, data, ctx);
    }
    static void CallCalculateGyroDamping(FFBEngine& e, const TelemInfoV01* data, FFBCalculationContext& ctx) {
        e.calculate_gyro_damping(data, ctx);
    }
    static void CallCalculateABSPulse(FFBEngine& e, const TelemInfoV01* data, FFBCalculationContext& ctx) {
        e.calculate_abs_pulse(data, ctx);
    }
    static void SetFlatspotSuppression(FFBEngine& e, bool val) { e.m_flatspot_suppression = val; }
    static void SetFlatspotStrength(FFBEngine& e, float val) { e.m_flatspot_strength = val; }
    static void SetABSPulseEnabled(FFBEngine& e, bool val) { e.m_abs_pulse_enabled = val; }
    static void SetLastLogTime(FFBEngine& e, std::chrono::steady_clock::time_point t) { e.last_log_time = t; }
    static ChannelStats& GetTorqueStats(FFBEngine& e) { return e.s_torque; }
    
    // Coverage Restoration Accessors
    static void CallUpdateStaticLoadReference(FFBEngine& e, double load, double speed, double dt) {
        e.update_static_load_reference(load, speed, dt);
    }
    static void CallInitializeLoadReference(FFBEngine& e, const char* vehicleClass, const char* vehicleName) {
        e.InitializeLoadReference(vehicleClass, vehicleName);
    }
    static void CallCalculateWheelSpin(FFBEngine& e, const TelemInfoV01* data, FFBCalculationContext& ctx) {
        e.calculate_wheel_spin(data, ctx);
    }
    static void CallCalculateSlideTexture(FFBEngine& e, const TelemInfoV01* data, FFBCalculationContext& ctx) {
        e.calculate_slide_texture(data, ctx);
    }
    static void CallCalculateRoadTexture(FFBEngine& e, const TelemInfoV01* data, FFBCalculationContext& ctx) {
        e.calculate_road_texture(data, ctx);
    }
    static void CallCalculateSuspensionBottoming(FFBEngine& e, const TelemInfoV01* data, FFBCalculationContext& ctx) {
        e.calculate_suspension_bottoming(data, ctx);
    }
    static void SetScrubDragGain(FFBEngine& e, float val) { e.m_scrub_drag_gain = val; }
    static void SetBottomingEnabled(FFBEngine& e, bool val) { e.m_bottoming_enabled = val; }
    static void SetBottomingGain(FFBEngine& e, float val) { e.m_bottoming_gain = val; }
    static void SetBottomingMethod(FFBEngine& e, int val) { e.m_bottoming_method = val; }
};

} // namespace FFBEngineTests

// ============================================================
// Auto-Registration System (v0.7.8)
// ============================================================

namespace FFBEngineTests {

struct TestEntry {
    std::string name;
    std::string category;
    std::vector<std::string> tags;
    std::function<void()> func;
    int order_hint; // For sorting within a category
};

class TestRegistry {
public:
    static TestRegistry& Instance();
    void Register(const std::string& name, 
                  const std::string& category, 
                  const std::vector<std::string>& tags,
                  std::function<void()> func,
                  int order = 0);
    const std::vector<TestEntry>& GetTests() const;
    void SortByCategory(); 

private:
    std::vector<TestEntry> m_tests;
    bool m_sorted = false;
};

// Helper class for static registration
struct AutoRegister {
    AutoRegister(const std::string& name, 
                 const std::string& category, 
                 const std::vector<std::string>& tags,
                 std::function<void()> func,
                 int order = 0);
};

} // namespace FFBEngineTests

// Usage: TEST_CASE(test_my_feature, "CorePhysics", {"Physics", "Regression"})
#define TEST_CASE_TAGGED(test_name, category, tags) \
    static void test_name(); \
    static FFBEngineTests::AutoRegister reg_##test_name( \
        #test_name, category, tags, test_name); \
    static void test_name()

// Simple version without tags (defaults to {"Functional"})
#define TEST_CASE(test_name, category_name) \
    TEST_CASE_TAGGED(test_name, category_name, {"Functional"})


```

# File: tools\lmuffb_log_analyzer\cli.py
```python
import click
from pathlib import Path
from rich.console import Console
from rich.table import Table
from rich.panel import Panel

from .loader import load_log
from .analyzers.slope_analyzer import (
    analyze_slope_stability,
    detect_oscillation_events,
    detect_singularities
)
from .plots import (
    plot_slope_timeseries,
    plot_slip_vs_latg,
    plot_dalpha_histogram,
    plot_slope_correlation
)
from .reports import generate_text_report

console = Console()

def _show_info(metadata, df):
    console.print(Panel.fit(
        f"[bold blue]Session Information[/bold blue]\n\n"
        f"Driver: {metadata.driver_name}\n"
        f"Vehicle: {metadata.vehicle_name}\n"
        f"Track: {metadata.track_name}\n"
        f"Duration: {df['Time'].max():.1f} seconds\n"
        f"Frames: {len(df)}\n"
        f"App Version: {metadata.app_version}",
        title="Log File Info"
    ))

def _run_analyze(metadata, df, verbose=False):
    # Run slope analysis
    slope_results = analyze_slope_stability(df)
    oscillations = detect_oscillation_events(df)
    singularity_count, worst_slope = detect_singularities(df)
    
    # Display results
    table = Table(title="Slope Detection Analysis")
    table.add_column("Metric", style="cyan")
    table.add_column("Value", style="green")
    table.add_column("Status", style="yellow")
    
    table.add_row(
        "Slope Std Dev",
        f"{slope_results['slope_std']:.2f}",
        "HIGH" if slope_results['slope_std'] > 5.0 else "OK"
    )
    table.add_row(
        "Slope Range",
        f"{slope_results['slope_min']:.1f} to {slope_results['slope_max']:.1f}",
        "WIDE" if (slope_results['slope_max'] - slope_results['slope_min']) > 20 else "OK"
    )
    
    if slope_results.get('active_percentage') is not None:
        table.add_row(
            "Active %",
            f"{slope_results['active_percentage']:.1f}%",
            "LOW" if slope_results['active_percentage'] < 30 else "OK"
        )
        
    if slope_results.get('floor_percentage') is not None:
        table.add_row(
            "Floor Hits",
            f"{slope_results['floor_percentage']:.1f}%",
            "HIGH" if slope_results['floor_percentage'] > 5 else "OK"
        )
        
    table.add_row(
        "Oscillation Events",
        str(len(oscillations)),
        "MANY" if len(oscillations) > 3 else "OK"
    )
    table.add_row(
        "Singularity Events",
        str(singularity_count),
        "CRITICAL" if singularity_count > 0 else "OK"
    )
    if singularity_count > 0:
        table.add_row(
            "Worst Singularity",
            f"{worst_slope:.1f}",
            "SEVERE" if worst_slope > 20.0 else "WARN"
        )
    
    console.print(table)
    
    # Show issues
    if slope_results['issues']:
        console.print("\n[bold red]Issues Detected:[/bold red]")
        for issue in slope_results['issues']:
            console.print(f"  • {issue}")
    else:
        console.print("\n[bold green]No issues detected in slope analysis.[/bold green]")

from rich.progress import Progress, SpinnerColumn, TextColumn

def _run_plots(metadata, df, output_dir, logfile_stem, plot_all=False):
    output_path = Path(output_dir)
    output_path.mkdir(parents=True, exist_ok=True)
    
    with Progress(
        SpinnerColumn(),
        TextColumn("[progress.description]{task.description}"),
        console=console,
        transient=True
    ) as progress:
        task = progress.add_task(f"Generating plots for {logfile_stem}...", total=None)
        
        def update_status(msg):
            progress.update(task, description=f" {logfile_stem}: {msg}")

        # Time series plot
        ts_path = output_path / f"{logfile_stem}_timeseries.png"
        plot_slope_timeseries(df, str(ts_path), show=False, status_callback=update_status)
        console.print(f"  [OK] Created: {ts_path}")
        
        if plot_all:
            # Tire curve
            tc_path = output_path / f"{logfile_stem}_tire_curve.png"
            plot_slip_vs_latg(df, str(tc_path), show=False, status_callback=update_status)
            console.print(f"  [OK] Created: {tc_path}")
            
            # dAlpha histogram
            hist_path = output_path / f"{logfile_stem}_dalpha_hist.png"
            plot_dalpha_histogram(df, str(hist_path), show=False, status_callback=update_status)
            console.print(f"  [OK] Created: {hist_path}")

            # Slope correlation
            corr_path = output_path / f"{logfile_stem}_slope_corr.png"
            plot_slope_correlation(df, str(corr_path), show=False, status_callback=update_status)
            console.print(f"  [OK] Created: {corr_path}")

@click.group()
@click.version_option(version='1.1.0')
def cli():
    """lmuFFB Log Analyzer - Analyze FFB telemetry logs for diagnostics."""
    pass

@cli.command()
@click.argument('logfile', type=click.Path(exists=True))
def info(logfile):
    """Display session info from a log file."""
    try:
        metadata, df = load_log(logfile)
        _show_info(metadata, df)
    except Exception as e:
        console.print(f"[bold red]Error loading log:[/bold red] {e}")

@cli.command()
@click.argument('logfile', type=click.Path(exists=True))
@click.option('--verbose', '-v', is_flag=True, help='Show detailed output')
def analyze(logfile, verbose):
    """Analyze a log file and show summary."""
    console.print(f"[bold]Analyzing:[/bold] {logfile}")
    try:
        metadata, df = load_log(logfile)
        _run_analyze(metadata, df, verbose)
    except Exception as e:
        console.print(f"[bold red]Error analyzing log:[/bold red] {e}")

@cli.command()
@click.argument('logfile', type=click.Path(exists=True))
@click.option('--output', '-o', default='.', help='Output directory for plots')
@click.option('--all', 'plot_all', is_flag=True, help='Generate all plot types')
def plots(logfile, output, plot_all):
    """Generate diagnostic plots from a log file."""
    console.print(f"[bold]Generating plots for:[/bold] {logfile}")
    try:
        metadata, df = load_log(logfile)
        _run_plots(metadata, df, output, Path(logfile).stem, plot_all)
        console.print("\n[bold green]Done![/bold green]")
    except Exception as e:
        console.print(f"[bold red]Error generating plots:[/bold red] {e}")

@cli.command()
@click.argument('logfile', type=click.Path(exists=True))
@click.option('--output', '-o', help='Output file path')
def report(logfile, output):
    """Generate a full diagnostic report."""
    try:
        metadata, df = load_log(logfile)
        report_text = generate_text_report(metadata, df)
        
        if output:
            with open(output, 'w') as f:
                f.write(report_text)
            console.print(f"[bold green]Report saved to:[/bold green] {output}")
        else:
            console.print(report_text)
    except Exception as e:
        console.print(f"[bold red]Error generating report:[/bold red] {e}")

@cli.command()
@click.argument('logdir', type=click.Path(exists=True, file_okay=False, dir_okay=True))
@click.option('--output', '-o', default='analyzer_results', help='Output directory for batch results')
def batch(logdir, output):
    """Run all analysis commands for all log files in a directory."""
    log_path = Path(logdir)
    output_path = Path(output)
    output_path.mkdir(parents=True, exist_ok=True)

    csv_files = sorted(list(log_path.glob("*.csv")))
    if not csv_files:
        # Try finding in subdirectories if direct search fails (sometimes happens on Windows with deep paths)
        csv_files = sorted(list(log_path.rglob("*.csv")))

    if not csv_files:
        console.print(f"[yellow]No .csv files found in {logdir}[/yellow]")
        return

    console.print(f"[bold green]Found {len(csv_files)} log files. Starting batch processing...[/bold green]")

    for logfile in csv_files:
        console.print(f"\n[bold blue]Processing: {logfile.name}[/bold blue]")
        try:
            # Load ONCE for all operations
            metadata, df = load_log(str(logfile))
            
            # 1. Info
            _show_info(metadata, df)
            
            # 2. Analyze
            _run_analyze(metadata, df)
            
            # 3. Plots
            _run_plots(metadata, df, output_path, logfile.stem, plot_all=True)
            
            # 4. Report
            report_file = output_path / f"{logfile.stem}_report.txt"
            report_text = generate_text_report(metadata, df)
            with open(report_file, 'w') as f:
                f.write(report_text)
            console.print(f"  [OK] Created: {report_file}")

        except Exception as e:
            console.print(f"[bold red]Error processing {logfile.name}:[/bold red] {e}")

    console.print(f"\n[bold green]Batch processing complete! Results saved to: {output}[/bold green]")

if __name__ == '__main__':
    cli()

```

# File: tools\lmuffb_log_analyzer\loader.py
```python
import pandas as pd
from pathlib import Path
from typing import Tuple, Optional
from datetime import datetime
from .models import SessionMetadata

def load_log(filepath: str) -> Tuple[SessionMetadata, pd.DataFrame]:
    """
    Load lmuFFB telemetry log file.
    
    Returns:
        Tuple of (SessionMetadata, DataFrame with telemetry data)
    """
    path = Path(filepath)
    if not path.exists():
        raise FileNotFoundError(f"Log file not found: {filepath}")
    
    # Parse header comments
    metadata = _parse_header(path)
    
    # Find data start line (first non-comment line)
    data_start = 0
    with open(path, 'r') as f:
        for i, line in enumerate(f):
            if not line.startswith('#'):
                data_start = i
                break
    
    # Load CSV data
    df = pd.read_csv(filepath, skiprows=data_start)
    
    return metadata, df

def _parse_datetime(date_str: str) -> datetime:
    """Parse datetime from log header"""
    try:
        return datetime.strptime(date_str, "%Y-%m-%d %H:%M:%S")
    except ValueError:
        return datetime.now()

def _safe_float(val: Optional[str]) -> Optional[float]:
    """Safely convert string to float"""
    if val is None or val.lower() == 'none' or val == '':
        return None
    try:
        return float(val)
    except ValueError:
        return None

def _parse_header(path: Path) -> SessionMetadata:
    """Extract metadata from header comments"""
    header_data = {}
    
    with open(path, 'r') as f:
        for line in f:
            if not line.startswith('#'):
                break
            
            line = line.lstrip('# ').strip()
            if ':' in line:
                key, value = line.split(':', 1)
                header_data[key.strip().lower().replace(' ', '_')] = value.strip()
            elif 'LMUFFB Telemetry Log' in line:
                # Handle the first line differently if needed
                parts = line.split(':')
                if len(parts) > 1:
                    header_data['log_version'] = parts[1].strip()
                else:
                    # Alternative format "LMUFFB Telemetry Log: 1.0.0" (actually the plan says # LMUFFB Telemetry Log: 1.0.0)
                    pass

    return SessionMetadata(
        log_version=header_data.get('lmuffb_telemetry_log', 'unknown'),
        timestamp=_parse_datetime(header_data.get('date', '')),
        app_version=header_data.get('app_version', 'unknown'),
        driver_name=header_data.get('driver', 'Unknown'),
        vehicle_name=header_data.get('vehicle', 'Unknown'),
        track_name=header_data.get('track', 'Unknown'),
        gain=float(header_data.get('gain', 1.0)),
        understeer_effect=float(header_data.get('understeer_effect', 1.0)),
        sop_effect=float(header_data.get('sop_effect', 1.0)),
        slope_enabled=header_data.get('slope_detection', '').lower() == 'enabled',
        slope_sensitivity=float(header_data.get('slope_sensitivity', 0.5)),
        slope_threshold=float(header_data.get('slope_threshold', -0.3)),
        slope_alpha_threshold=_safe_float(header_data.get('slope_alpha_threshold')),
        slope_decay_rate=_safe_float(header_data.get('slope_decay_rate')),
    )

```

# File: tools\lmuffb_log_analyzer\models.py
```python
from pydantic import BaseModel
from typing import Optional, List
from datetime import datetime

class SessionMetadata(BaseModel):
    """Extracted from log file header"""
    log_version: str
    timestamp: datetime
    app_version: str
    driver_name: str
    vehicle_name: str
    track_name: str
    
    # Settings snapshot
    gain: float
    understeer_effect: float
    sop_effect: float
    slope_enabled: bool
    slope_sensitivity: float
    slope_threshold: float
    slope_alpha_threshold: Optional[float] = None
    slope_decay_rate: Optional[float] = None

class MarkerEvent(BaseModel):
    """User-triggered marker"""
    timestamp: float
    frame_index: int
    context: dict

```

# File: tools\lmuffb_log_analyzer\plots.py
```python
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
from pathlib import Path
from typing import Optional

def _safe_legend(ax, loc='upper right'):
    """Only show legend if there are labeled artists."""
    handles, labels = ax.get_legend_handles_labels()
    if labels:
        ax.legend(loc=loc)

MAX_PLOT_POINTS = 20000

def _downsample_df(df: pd.DataFrame, max_points: int = MAX_PLOT_POINTS) -> pd.DataFrame:
    """Downsample dataframe for plotting if it exceeds max_points."""
    if len(df) <= max_points:
        return df
    
    # We want to preserve the temporal order, so we use step-based downsampling
    # instead of random sampling for time-series plots.
    step = len(df) // max_points
    return df.iloc[::step].copy()

def plot_slope_timeseries(
    df: pd.DataFrame, 
    output_path: Optional[str] = None,
    show: bool = True,
    status_callback = None
) -> str:
    """
    Generate 4-panel time-series plot for slope detection analysis.
    """
    if status_callback: status_callback("Initializing plot...")
    fig, axes = plt.subplots(4, 1, figsize=(14, 12), sharex=True)
    fig.suptitle('Slope Detection Analysis - Time Series', fontsize=14, fontweight='bold')
    
    # Downsample for performance
    if status_callback: status_callback("Downsampling data...")
    plot_df = _downsample_df(df)
    time = plot_df['Time'] if 'Time' in plot_df.columns else np.arange(len(plot_df)) * 0.01
    
    # Panel 1: Inputs (Lat G and Slip Angle)
    if status_callback: status_callback("Rendering Panel 1 (Inputs)...")
    ax1 = axes[0]
    ax1.plot(time, plot_df['LatAccel'] / 9.81, label='Lateral G', color='#2196F3', alpha=0.8)
    ax1.set_ylabel('Lateral G', color='#2196F3')
    ax1.tick_params(axis='y', labelcolor='#2196F3')
    _safe_legend(ax1, loc='upper left')
    ax1.grid(True, alpha=0.3)
    
    ax1_twin = ax1.twinx()
    if 'calc_slip_angle_front' in plot_df.columns:
        ax1_twin.plot(time, plot_df['calc_slip_angle_front'], label='Slip Angle', 
                      color='#FF9800', alpha=0.8)
    ax1_twin.set_ylabel('Slip Angle (rad)', color='#FF9800')
    ax1_twin.tick_params(axis='y', labelcolor='#FF9800')
    _safe_legend(ax1_twin, loc='upper right')
    ax1.set_title('Inputs: Lateral G and Slip Angle')
    
    # Panel 2: Derivatives
    if status_callback: status_callback("Rendering Panel 2 (Derivatives)...")
    ax2 = axes[1]
    if 'dG_dt' in plot_df.columns:
        ax2.plot(time, plot_df['dG_dt'], label='dG/dt', color='#2196F3', alpha=0.8)
    if 'dAlpha_dt' in plot_df.columns:
        ax2.plot(time, plot_df['dAlpha_dt'], label='dAlpha/dt', color='#FF9800', alpha=0.8)
        ax2.axhline(0.02, color='#F44336', linestyle='--', alpha=0.5, label='Threshold (0.02)')
        ax2.axhline(-0.02, color='#F44336', linestyle='--', alpha=0.5)
    ax2.set_ylabel('Derivative')
    _safe_legend(ax2, loc='upper right')
    ax2.grid(True, alpha=0.3)
    ax2.set_title('Derivatives: dG/dt and dAlpha/dt')
    
    # Panel 3: Slope
    if status_callback: status_callback("Rendering Panel 3 (Slope)...")
    ax3 = axes[2]
    if 'SlopeCurrent' in plot_df.columns:
        ax3.plot(time, plot_df['SlopeCurrent'], label='Slope (dG/dAlpha)', color='#9C27B0', linewidth=0.8)
        ax3.axhline(-0.3, color='#F44336', linestyle='--', alpha=0.5, label='Neg Threshold (-0.3)')
        ax3.axhline(0, color='#4CAF50', linestyle='-', alpha=0.3)
    ax3.set_ylabel('Slope (G/rad)')
    ax3.set_ylim(-15, 15)  # Clamp for visibility
    _safe_legend(ax3, loc='upper right')
    ax3.grid(True, alpha=0.3)
    ax3.set_title('Calculated Slope (dG/dAlpha)')
    
    # Panel 4: Grip Output
    if status_callback: status_callback("Rendering Panel 4 (Output)...")
    ax4 = axes[3]
    grip_col = 'GripFactor' if 'GripFactor' in plot_df.columns else 'SlopeSmoothed'
    if grip_col in plot_df.columns:
        ax4.plot(time, plot_df[grip_col], label='Grip Factor', color='#4CAF50', linewidth=1.0)
        ax4.axhline(0.2, color='#9E9E9E', linestyle='--', alpha=0.5, label='Floor (0.2)')
        ax4.axhline(1.0, color='#9E9E9E', linestyle='--', alpha=0.5)
    ax4.set_ylabel('Grip Factor')
    ax4.set_xlabel('Time (s)')
    ax4.set_ylim(0, 1.1)
    _safe_legend(ax4, loc='upper right')
    ax4.grid(True, alpha=0.3)
    ax4.set_title('Output: Grip Factor')
    
    # Add markers if present
    if 'Marker' in plot_df.columns:
        marker_times = time[plot_df['Marker'] == 1]
        if len(marker_times) > 0:
            if status_callback: status_callback(f"Adding {len(marker_times)} markers...")
            for ax in axes:
                # Use vlines for performance instead of multiple axvline calls
                ax.vlines(marker_times, -100, 100, color='#E91E63', linestyle='-', alpha=0.7, linewidth=2, transform=ax.get_xaxis_transform())
    
    if status_callback: status_callback("Finalizing layout...")
    plt.tight_layout()
    
    if output_path:
        if status_callback: status_callback(f"Saving to {Path(output_path).name}...")
        plt.savefig(output_path, dpi=150, bbox_inches='tight')
        plt.close(fig)
        return output_path
    
    if show:
        plt.show()
    
    return ""

def plot_slip_vs_latg(
    df: pd.DataFrame,
    output_path: Optional[str] = None,
    show: bool = True,
    status_callback = None
) -> str:
    """
    Scatter plot of Slip Angle vs Lateral G (tire curve visualization).
    """
    if status_callback: status_callback("Initializing tire curve plot...")
    fig, ax = plt.subplots(figsize=(10, 8))
    
    slip_col = 'calc_slip_angle_front' if 'calc_slip_angle_front' in df.columns else None
    if slip_col is None:
        return ""
    
    # Downsample for performance (crucial for ax.scatter)
    if status_callback: status_callback("Downsampling data...")
    plot_df = _downsample_df(df)
    
    slip = np.abs(plot_df[slip_col])
    lat_g = np.abs(plot_df['LatAccel'] / 9.81) if 'LatAccel' in plot_df.columns else None
    
    if lat_g is None:
        return ""
    
    # Color by speed
    speed = plot_df['Speed'] * 3.6 if 'Speed' in plot_df.columns else None
    
    if status_callback: status_callback("Rendering scatter plot...")
    scatter = ax.scatter(slip, lat_g, c=speed, cmap='viridis', alpha=0.3, s=2)
    
    ax.set_xlabel('Slip Angle (rad)')
    ax.set_ylabel('Lateral G')
    ax.set_title('Tire Curve: Slip Angle vs Lateral G')
    ax.grid(True, alpha=0.3)
    
    if speed is not None:
        cbar = plt.colorbar(scatter, ax=ax)
        cbar.set_label('Speed (km/h)')
    
    # Mark the theoretical peak region
    ax.axvline(0.08, color='#F44336', linestyle='--', alpha=0.5, label='Typical Peak (~0.08 rad)')
    _safe_legend(ax)
    
    plt.tight_layout()
    
    if output_path:
        if status_callback: status_callback(f"Saving to {Path(output_path).name}...")
        plt.savefig(output_path, dpi=150, bbox_inches='tight')
        plt.close(fig)
        return output_path
    
    if show:
        plt.show()
    
    return ""

def plot_dalpha_histogram(
    df: pd.DataFrame,
    output_path: Optional[str] = None,
    show: bool = True,
    status_callback = None
) -> str:
    """
    Histogram of dAlpha/dt values (shows when slope calculation is "active").
    """
    if 'dAlpha_dt' not in df.columns:
        return ""
    
    if status_callback: status_callback("Rendering dAlpha histogram...")
    fig, ax = plt.subplots(figsize=(10, 6))
    
    dalpha = df['dAlpha_dt'].values
    
    # Create histogram
    ax.hist(dalpha, bins=100, color='#2196F3', alpha=0.7, edgecolor='white')
    
    # Mark the threshold
    threshold = 0.02
    ax.axvline(threshold, color='#F44336', linestyle='--', linewidth=2, label=f'Threshold (+{threshold})')
    ax.axvline(-threshold, color='#F44336', linestyle='--', linewidth=2, label=f'Threshold (-{threshold})')
    
    # Calculate percentages
    above_threshold = (np.abs(dalpha) > threshold).mean() * 100
    
    ax.set_xlabel('dAlpha/dt (rad/s)')
    ax.set_ylabel('Frequency')
    ax.set_title(f'Distribution of dAlpha/dt\n{above_threshold:.1f}% of frames above threshold (active calculation)')
    _safe_legend(ax)
    ax.grid(True, alpha=0.3)
    
    plt.tight_layout()
    
    if output_path:
        if status_callback: status_callback(f"Saving to {Path(output_path).name}...")
        plt.savefig(output_path, dpi=150, bbox_inches='tight')
        plt.close(fig)
        return output_path
    
    if show:
        plt.show()
    
    return ""

def plot_slope_correlation(
    df: pd.DataFrame,
    output_path: Optional[str] = None,
    show: bool = True,
    status_callback = None
) -> str:
    """
    Scatter plot of dAlpha/dt vs SlopeCurrent to detect numerical instability.
    """
    if 'dAlpha_dt' not in df.columns or 'SlopeCurrent' not in df.columns:
        return ""

    if status_callback: status_callback("Rendering slope correlation plot...")
    # Downsample if too large for performance
    if len(df) > 20000:
        plot_df = df.sample(n=20000, random_state=42)
    else:
        plot_df = df

    fig, ax = plt.subplots(figsize=(10, 8))

    ax.scatter(plot_df['dAlpha_dt'], plot_df['SlopeCurrent'],
               alpha=0.1, s=10, color='#9C27B0')

    # Annotate thresholds
    ax.axvline(0.02, color='#F44336', linestyle='--', alpha=0.5, label='Threshold (0.02)')
    ax.axvline(-0.02, color='#F44336', linestyle='--', alpha=0.5)

    ax.set_xlabel('dAlpha/dt (rad/s)')
    ax.set_ylabel('Slope (G/rad)')
    ax.set_title('Instability Check: dAlpha/dt vs SlopeCurrent')
    ax.set_ylim(-50, 50)  # Focus on the relevant range, even if outliers exist
    ax.grid(True, alpha=0.3)
    _safe_legend(ax)

    plt.tight_layout()

    if output_path:
        if status_callback: status_callback(f"Saving to {Path(output_path).name}...")
        plt.savefig(output_path, dpi=150, bbox_inches='tight')
        plt.close(fig)
        return output_path
    
    if show:
        plt.show()
    
    return ""

```

# File: tools\lmuffb_log_analyzer\reports.py
```python
import pandas as pd
from .models import SessionMetadata
from .analyzers.slope_analyzer import (
    analyze_slope_stability,
    detect_oscillation_events,
    detect_singularities
)

def generate_text_report(metadata: SessionMetadata, df: pd.DataFrame) -> str:
    """
    Generate a formatted text report for the session.
    """
    slope_results = analyze_slope_stability(df)
    oscillations = detect_oscillation_events(df)
    singularity_count, worst_slope = detect_singularities(df)
    
    report = []
    report.append("=" * 60)
    report.append(" " * 15 + "LMUFFB DIAGNOSTIC REPORT")
    report.append("=" * 60)
    report.append("")
    
    report.append("SESSION INFORMATION")
    report.append("-" * 20)
    report.append(f"Driver:       {metadata.driver_name}")
    report.append(f"Vehicle:      {metadata.vehicle_name}")
    report.append(f"Track:        {metadata.track_name}")
    report.append(f"Date:         {metadata.timestamp}")
    report.append(f"App Version:  {metadata.app_version}")
    report.append("")
    
    report.append("SETTINGS")
    report.append("-" * 20)
    report.append(f"Gain:               {metadata.gain:.2f}")
    report.append(f"Understeer Effect:  {metadata.understeer_effect:.2f}")
    report.append(f"SOP Effect:          {metadata.sop_effect:.2f}")
    report.append(f"Slope Detection:    {'Enabled' if metadata.slope_enabled else 'Disabled'}")
    report.append(f"Slope Sensitivity:  {metadata.slope_sensitivity:.2f}")
    report.append(f"Slope Threshold:    {metadata.slope_threshold:.2f}")
    report.append("")
    
    report.append("SLOPE ANALYSIS")
    report.append("-" * 20)
    report.append(f"Slope Mean:       {slope_results['slope_mean']:.2f}")
    report.append(f"Slope Std Dev:    {slope_results['slope_std']:.2f}")
    report.append(f"Slope Range:      {slope_results['slope_min']:.1f} to {slope_results['slope_max']:.1f}")
    
    if slope_results.get('active_percentage') is not None:
        report.append(f"Active Time:      {slope_results['active_percentage']:.1f}%")
        
    if slope_results.get('floor_percentage') is not None:
        report.append(f"Floor Hits:       {slope_results['floor_percentage']:.1f}%")
        
    report.append(f"Oscillations:      {len(oscillations)} events detected")
    report.append(f"Singularities:     {singularity_count} events detected (Worst: {worst_slope:.1f})")
    report.append("")

    report.append("SIGNAL QUALITY & STABILITY")
    report.append("-" * 20)
    if slope_results.get('zero_crossing_rate') is not None:
        report.append(f"Zero-Crossing Rate: {slope_results['zero_crossing_rate']:.2f} Hz")
    if slope_results.get('binary_residence') is not None:
        report.append(f"Binary Residence:   {slope_results['binary_residence']:.1f}%")
    if slope_results.get('derivative_energy_ratio') is not None:
        report.append(f"D-Energy Ratio:     {slope_results['derivative_energy_ratio']:.2f}")
    report.append("")
    
    if slope_results['issues']:
        report.append("ISSUES DETECTED")
        report.append("-" * 20)
        for issue in slope_results['issues']:
            report.append(f"  [!] {issue}")
        report.append("")
    else:
        report.append("No significant issues detected in slope analysis.")
        report.append("")
        
    report.append("=" * 60)
    
    return "\n".join(report)

```

# File: tools\lmuffb_log_analyzer\__init__.py
```python
# lmuffb_log_analyzer package

```

# File: tools\lmuffb_log_analyzer\analyzers\slope_analyzer.py
```python
import pandas as pd
import numpy as np
from typing import Dict, List, Any

def analyze_slope_stability(df: pd.DataFrame, threshold: float = 0.02) -> Dict[str, Any]:
    """
    Analyze the stability of slope detection algorithm.
    """
    results = {}
    
    # Basic slope statistics
    slope = df['SlopeCurrent']
    results['slope_mean'] = float(slope.mean())
    results['slope_std'] = float(slope.std())
    results['slope_min'] = float(slope.min())
    results['slope_max'] = float(slope.max())
    results['slope_range'] = (float(slope.min()), float(slope.max()))
    results['slope_variance'] = float(slope.var())
    
    # Percentage of time slope is actively calculated
    if 'dAlpha_dt' in df.columns:
        active_mask = np.abs(df['dAlpha_dt']) > threshold
        results['active_percentage'] = float(active_mask.mean() * 100)
    else:
        results['active_percentage'] = None
    
    # Percentage of time at grip floor (0.2)
    grip_col = 'GripFactor' if 'GripFactor' in df.columns else 'SlopeSmoothed'
    if grip_col in df.columns:
        floor_mask = df[grip_col] <= 0.21
        results['floor_percentage'] = float(floor_mask.mean() * 100)
    else:
        results['floor_percentage'] = None
    
    # Grip on straights analysis
    straight_mask = (
        (df['Speed'] > 27.8) &  # > 100 km/h
        (np.abs(df.get('calc_slip_angle_front', 0)) < 0.02)
    )
    if straight_mask.any():
        results['grip_on_straights_mean'] = float(df.loc[straight_mask, grip_col].mean())
        results['grip_on_straights_std'] = float(df.loc[straight_mask, grip_col].std())
    else:
        results['grip_on_straights_mean'] = None
        results['grip_on_straights_std'] = None
    
    # Signal Quality Metrics
    # 1. Zero-Crossing Rate (Hz)
    if 'SlopeCurrent' in df.columns:
        # Count sign changes
        diffs = np.diff(np.sign(df['SlopeCurrent']))
        crossings = np.count_nonzero(diffs)
        duration = df['Time'].iloc[-1] - df['Time'].iloc[0] if 'Time' in df.columns else len(df) * 0.01
        results['zero_crossing_rate'] = float(crossings / duration) if duration > 0 else 0.0
    else:
        results['zero_crossing_rate'] = None

    # 2. Binary State Residence
    if grip_col in df.columns:
        binary_mask = (df[grip_col] <= 0.25) | (df[grip_col] >= 0.95)
        results['binary_residence'] = float(binary_mask.mean() * 100)
    else:
        results['binary_residence'] = None

    # 3. Derivative Energy Ratio
    if 'dG_dt' in df.columns and 'dAlpha_dt' in df.columns:
        std_alpha = df['dAlpha_dt'].std()
        results['derivative_energy_ratio'] = float(df['dG_dt'].std() / std_alpha) if std_alpha > 0 else 0.0
    else:
        results['derivative_energy_ratio'] = None

    # Issue detection
    results['issues'] = []
    
    if results['slope_std'] > 5.0:
        results['issues'].append(
            f"HIGH SLOPE VARIANCE ({results['slope_std']:.2f}) - Algorithm may be unstable"
        )
    
    if results.get('floor_percentage', 0) > 5.0:
        results['issues'].append(
            f"FREQUENT FLOOR HITS ({results['floor_percentage']:.1f}%) - Algorithm too aggressive"
        )
    
    if results.get('active_percentage') is not None and results['active_percentage'] < 30.0:
        results['issues'].append(
            f"LOW ACTIVE PERCENTAGE ({results['active_percentage']:.1f}%) - Slope rarely calculated"
        )
    
    if results.get('grip_on_straights_mean') is not None and results['grip_on_straights_mean'] < 0.9:
        results['issues'].append(
            f"LOW GRIP ON STRAIGHTS ({results['grip_on_straights_mean']:.2f}) - Slope stuck at negative"
        )

    if results.get('zero_crossing_rate', 0) > 5.0:
        results['issues'].append(
            f"HIGH SIGNAL NOISE ({results['zero_crossing_rate']:.1f} Hz) - Slope signal is jittery"
        )

    return results

def detect_oscillation_events(
    df: pd.DataFrame, 
    column: str = 'SlopeCurrent',
    threshold: float = 5.0,
    min_duration: float = 0.1
) -> List[Dict[str, Any]]:
    """
    Detect periods where a signal oscillates rapidly between extremes.
    """
    events = []
    
    if column not in df.columns:
        return events
    
    signal = df[column].values
    time = df['Time'].values if 'Time' in df.columns else np.arange(len(signal)) * 0.01
    
    # Calculate rolling std to detect high-variance periods
    window = 50  # 0.5 seconds at 100Hz
    rolling_std = pd.Series(signal).rolling(window, center=True).std().values
    
    # Vectorized search for events
    # Find frames where std exceeds threshold
    std_above = (rolling_std > threshold).astype(int)
    # Detect starts and ends (1 = starts, -1 = ends)
    # prepend/append 0 ensures we catch events leading to/from the edges
    diff = np.diff(std_above, prepend=0, append=0)
    starts = np.where(diff == 1)[0]
    ends = np.where(diff == -1)[0]
    
    for s, e in zip(starts, ends):
        # Index e is the point just after the event, adjust to inclusive range [s, e-1]
        actual_end = e - 1
        duration = time[actual_end] - time[s]
        
        if duration >= min_duration:
            events.append({
                'start_time': float(time[s]),
                'end_time': float(time[actual_end]),
                'duration': float(duration),
                'amplitude': float(np.abs(signal[s:e]).max()),
                'frame_start': int(s),
                'frame_end': int(actual_end)
            })
    
    return events

def analyze_grip_correlation(df: pd.DataFrame) -> Dict[str, float]:
    """
    Analyze correlation between calculated grip and expected physics.
    """
    results = {}
    
    grip_col = 'GripFactor' if 'GripFactor' in df.columns else 'SlopeSmoothed'
    
    if grip_col in df.columns:
        # Correlation with absolute slip angle
        if 'calc_slip_angle_front' in df.columns:
            slip = np.abs(df['calc_slip_angle_front'])
            results['grip_vs_slip_correlation'] = float(-df[grip_col].corr(slip))
        
        # Correlation with lateral G
        if 'LatAccel' in df.columns:
            lat_g = np.abs(df['LatAccel'])
            results['grip_vs_latg_correlation'] = float(df[grip_col].corr(lat_g))
    
    return results

def detect_singularities(
    df: pd.DataFrame,
    slope_thresh: float = 10.0,
    alpha_rate_thresh: float = 0.05
) -> (int, float):
    """
    Detect "Singularity Events" (high slope with low slip rate).
    """
    if 'SlopeCurrent' not in df.columns or 'dAlpha_dt' not in df.columns:
        return 0, 0.0

    mask = (np.abs(df['SlopeCurrent']) > slope_thresh) & (np.abs(df['dAlpha_dt']) < alpha_rate_thresh)
    count = int(mask.sum())
    worst = float(df.loc[mask, 'SlopeCurrent'].abs().max()) if count > 0 else 0.0

    return count, worst

```

# File: tools\lmuffb_log_analyzer\analyzers\__init__.py
```python
# analyzers subpackage

```
